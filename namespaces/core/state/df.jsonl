{"_at":[1768201106279,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1768180747361,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nPhase 2 implementation must be verified before Phase 3 starts.\n\n**Context**\n- REALTIME_PLAN.md §18: CBOR hashing stability, apply idempotence, note collision detection, LWW merge ordering\n- Depends on: Phase 2 implementation + Phase 2 test infrastructure\n\n**Design**\nDeterministic tests for:\n- Canonical CBOR EventBody hashing stability (bytes identical across runs)\n- Apply idempotence: apply same event twice → no change\n- Note collision detection: same note_id, different content → error\n- Decoder bounds: reject indefinite length or out-of-bounds payloads\n- LWW merge ordering: concurrent updates resolve deterministically\n\n**Acceptance**\n- [ ] tests/phase2_cbor.rs: hashing stability tests\n- [ ] tests/phase2_apply.rs: apply idempotence tests\n- [ ] Test: note_id collision with different content fails\n- [ ] Test: LWW merge ordering is deterministic for concurrent updates\n- [ ] cargo test phase2_ passes\n\n**Files:** tests/phase2_cbor.rs (new), tests/phase2_apply.rs (new)","id":"bd-3m5.56","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 2 tests: canonical hashing + apply idempotence","type":"task"}
{"_at":[1768487643359,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768448635632,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nREALTIME_PLAN §16.3 adds CLI flags `--namespace`, `--durability`, `--client-request-id`. We want these to remain, but semantics should be config‑first: repo/user config provides defaults and flags override those defaults. Env vars must remain supported and take precedence over config (but not over explicit CLI flags).\n\n**Design**\n- Keep existing CLI flags.\n- Resolve defaults from layered config (repo `beads.toml` + user config) with env overrides.\n- Precedence: CLI flag > env var > repo config > user config > hardcoded defaults.\n- `--client-request-id` remains explicit‑only (no default); used mainly by automation.\n\n**Acceptance**\n- [ ] CLI behavior matches precedence above for namespace/durability defaults.\n- [ ] Env vars for replication/config remain supported.\n- [ ] CLI flags continue to pass through IPC unchanged.\n- [ ] Tests cover: config default used when no flags; CLI overrides config; env overrides config.","id":"bd-3m5.98","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"CLI namespace/durability/client-request-id flags become config-backed overrides","type":"task"}
{"_at":[1770617270055,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmcstudio2.lan","created_at":[1770611168570,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nTop-level parse/dispatch and command-name wiring still lives primarily in `crates/beads-rs/src/cli/mod.rs` and `crates/beads-rs/src/cli/commands/mod.rs`, even as handler logic migrates. This keeps ownership ambiguous and adds duplication risk.\n\n**Design**\nMove command parse/dispatch ownership into `beads-cli` (or a dedicated `beads-cli` entry surface), keeping `beads-rs` as a minimal orchestration shell that delegates execution.\n\n**Acceptance**\n- [ ] Primary dispatch table and command-name mapping are owned by `beads-cli`.\n- [ ] `beads-rs` entrypoint remains a thin wrapper with explicit compatibility behavior.\n- [ ] CLI flags and aliases remain backward compatible.\n- [ ] Integration tests confirm unchanged behavior for major command families.\n- [ ] Verification gate passes (`fmt`, `dylint`, `clippy`, `test`, `slow-tests`).\n\n**Files**\n- crates/beads-cli/src/**\n- crates/beads-rs/src/cli/mod.rs\n- crates/beads-rs/src/cli/commands/mod.rs\n- crates/beads-rs/src/bin/main.rs","id":"bd-atsg.4","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Move top-level CLI parse/dispatch ownership into beads-cli","type":"chore"}
{"_at":[1768622431666,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622431666,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIn multi-rig setups (orchestrator with multiple rigs), commands should auto-route to the correct rig based on issue ID prefix. The Go beads has routes.jsonl for prefix-to-path mapping, enabling seamless cross-rig operations.\n\n**What the Feature Does**\nAutomatic command routing based on issue ID prefix:\n- `bd show bd-abc` - Routes to rig with \"bd-\" prefix\n- `bd show gt-xyz` - Routes to rig with \"gt-\" prefix\n- `bd update bd-abc --status in_progress` - Routes to correct rig\n- No need to `cd` to correct directory - routing is transparent\n\nConfiguration via `routes.jsonl` in town root (e.g., `~/gt/.beads/routes.jsonl`):\n```jsonl\n{\"prefix\": \"bd-\", \"path\": \"beads/mayor/rig\"}\n{\"prefix\": \"gt-\", \"path\": \"gastown/mayor/rig\"}\n{\"prefix\": \"poly-\", \"path\": \"polecats/mayor/rig\"}\n```\n\nRoutes resolve:\n- Prefix to .beads directory\n- Path is relative to town root (found by walking up to `mayor/town.json`)\n- Supports symlinks (via redirect files)\n\n**Why It Needs Design Work**\n\n1. **Daemon Architecture**:\n   - Go beads: One daemon per workspace\n   - Routing opens connections to foreign databases\n   - Rust architecture: Same approach or different?\n   - Per-rig daemon vs centralized router?\n\n2. **Database Lifecycle**:\n   - Who owns the routed database connection?\n   - Do we keep connections open or open/close per operation?\n   - Cache strategy for routes.jsonl?\n   - Handle database lock contention?\n\n3. **Error Handling**:\n   - What if target rig doesn't exist?\n   - What if prefix not found in routes.jsonl?\n   - Fallback behavior?\n   - Clear error messages for users?\n\n4. **ID Resolution**:\n   - Partial ID resolution (bd-abc vs full hash)\n   - Cross-rig duplicate detection\n   - Collision prevention across rigs\n\n**Key Decisions to Make**\n\n1. **Routes File Location**:\n   - Go approach: Find town root by walking up to `mayor/town.json`\n   - Alternative: Configuration setting?\n   - Multiple routes files (rig-local + town-level)?\n   - How to handle non-orchestrator setups?\n\n2. **Connection Model**:\n   ```rust\n   // Option A: Route at API layer\n   fn show(id: &str) -> Result<Issue> {\n       let beads_dir = resolve_beads_dir_for_id(id)?;\n       let storage = Storage::open(beads_dir)?;\n       storage.get_issue(id)\n   }\n   \n   // Option B: Route at storage layer\n   impl Storage {\n       fn get_issue(&self, id: &str) -> Result<Issue> {\n           if let Some(routed) = self.routes.lookup(id) {\n               return routed.get_issue(id);\n           }\n           // fallback to local\n       }\n   }\n   ```\n\n3. **Command Coverage**:\n   - Which commands support routing? (show, update, close, comment - yes)\n   - Which don't? (create always local? or use --rig flag?)\n   - Read-only vs write operations - different rules?\n\n4. **Sync Interactions**:\n   - Does routing affect sync behavior?\n   - Do routed operations trigger sync in target rig?\n   - How to handle daemon mode with routing?\n\n**Trade-offs to Consider**\n\n1. **Complexity vs Transparency**:\n   - Pro: Seamless UX, no CD required\n   - Con: Action-at-a-distance can confuse\n   - Solution: Clear output showing which rig was used?\n\n2. **Performance**:\n   - Opening foreign databases adds latency\n   - Could cache connections but adds complexity\n   - Trade-off: Speed vs memory/file handles\n\n3. **Lock Contention**:\n   - Multiple rigs = multiple daemons\n   - Each daemon has exclusive db lock\n   - Routing from one daemon to another's db = potential conflict\n   - May need read-only mode for routed access?\n\n4. **Backward Compatibility**:\n   - Routes.jsonl is optional - works without it\n   - Non-orchestrator repos unaffected\n   - But what about existing Rust users?\n\n**Reference Files in Go Beads**\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/routing/routes.go` - Route loading/resolution\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/routing/routing.go` - Routing logic\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/docs/ROUTING.md` - Routing documentation\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/docs/MULTI_REPO_AGENTS.md` - Agent workflows\n\n**Go Implementation Details**\n- `ExtractPrefix(id)` - Gets \"bd-\" from \"bd-abc123\"\n- `LoadRoutes(beadsDir)` - Parses routes.jsonl\n- `ResolveBeadsDirForID(id, currentBeadsDir)` - Maps ID to .beads directory\n- `findTownRoot()` - Walks up to find mayor/town.json\n- `resolveRedirect()` - Follows symlink redirects\n\n**Acceptance**\n- [ ] Design document for routing architecture (daemon model, connection lifecycle)\n- [ ] Route resolution algorithm adapted to Rust\n- [ ] Error handling spec (missing routes, missing rigs, locks)\n- [ ] Command-by-command routing support plan\n- [ ] Sync interaction design\n- [ ] Performance considerations (caching, connection pooling)\n- [ ] Decision on read-only vs read-write routing","id":"bd-ze0x.16","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":1133274413160658948,"replica":"40030a2b-543a-2576-3660-d1f421f9a7d7"}]}},"priority":2,"status":"open","title":"Prefix-based routing - Cross-rig command routing","type":"feature"}
{"_at":[1768622398748,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622398748,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nShell completion for issue IDs requires typing the full ID manually. Go beads implements dynamic completion that queries the database for matching IDs as you type.\n\n**Design**\nImplement `issueIDCompletion` function that:\n- Uses prefix filtering at the database level (`IDPrefix` filter in SearchIssues)\n- Returns completions in format: `ID\\tTitle` (tab-separated for display)\n- Opens read-only database connection for completion queries\n- Handles database errors gracefully (returns empty on failure)\n- Uses 30s timeout for database locks by default\n\nReference implementation: `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/cmd/bd/completions.go`\n\n**Design Notes**\n- Clap supports dynamic completions via `ValueHint::Other`\n- Need to add completion script generation (bash/zsh/fish)\n- Optimize for performance - prefix filtering in SQL prevents full table scans\n- Must work without daemon running (uses direct read-only connection)\n\n**Acceptance**\n- [ ] Tab completion for issue IDs in bash/zsh/fish\n- [ ] Completions show ID + title during typing\n- [ ] Prefix filtering optimized at database level\n- [ ] Works without daemon (read-only connection)\n- [ ] Graceful error handling (returns empty on DB errors)\n\n**Files:**\n- `src/cli/completions.rs` (new)\n- `src/cli/mod.rs` (wire completion)\n- `src/bin/main.rs` (clap shell completion subcommand)","id":"bd-ze0x.4","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"open","title":"Dynamic shell completions for issue IDs","type":"feature"}
