{"_at":[1766124452235,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1766116454864,0],"darin@dusk"],"claim":[[1766124452135,0],"darin@dusk"],"description":[[1766116454864,0],"darin@dusk"],"design":[[1766116454864,0],"darin@dusk"],"estimated_minutes":[[1766116454864,0],"darin@dusk"],"external_ref":[[1766116454864,0],"darin@dusk"],"labels":[[1766116454864,0],"darin@dusk"],"priority":[[1766116454864,0],"darin@dusk"],"source_repo":[[1766116454864,0],"darin@dusk"],"title":[[1766116454864,0],"darin@dusk"],"type":[[1766116454864,0],"darin@dusk"]},"assignee":"darin@dusk","assignee_at":[1766124452135,0],"assignee_expires":1766128052135,"closed_at":[1766124452235,0],"closed_by":"darin@dusk","created_at":[1766116454864,0],"created_by":"darin@dusk","description":"**Problem**\n`SyncProcess::fetch` force-updates `refs/heads/beads/store` to match remote and uses `unwrap_or(Oid::zero())` for ref lookup. If local is ahead/diverged, this overwrites local commits; if ref lookup errors, we treat it as missing. Both can lose durable local history.\n\n**Design**\n- Use ref lookup that distinguishes NotFound vs error.\n- Only fast-forward local ref when it is an ancestor of remote.\n- If local is ahead/diverged, create a backup ref (e.g., `refs/beads/backup/<oid>`) before any update and avoid forcing local to remote.\n- Keep commit parent as remote head for linear history.\n- Add tests covering local-ahead and diverged scenarios.\n\n**Acceptance**\n- [ ] No forced local ref update when local ahead/diverged\n- [ ] Backup refs created for diverged local history\n- [ ] Ref lookup errors are surfaced\n- [ ] Tests cover ancestry check + backup behavior\n- [ ] Tests pass\n\n**Files:** src/git/sync.rs, src/git/error.rs","id":"bd-34g","labels":[],"priority":0,"status":"closed","title":"Sync fetch must not clobber local ref (ancestry check + backup)","type":"bug"}
