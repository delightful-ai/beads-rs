{"_at":[1768530397553,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Dirty shard tracking uses a typed shard/path type, not `String`.\n- [ ] Snapshot serialization still emits the same on-disk shard paths.\n- [ ] Dirty shard tests updated to use the typed value.","assignee":"darin@book","created_at":[1768503238667,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`StoreRuntime` tracks checkpoint dirty shards as `BTreeSet<String>` of shard paths (`checkpoint_dirty_shards` / `checkpoint_dirty_inflight`). This mixes path construction with storage and makes it easy to emit inconsistent shard paths or forget to update a path format. It also spreads stringly-typed shard logic across the runtime.\n\n**Files**\n- src/daemon/store_runtime.rs\n- src/daemon/checkpoint_snapshot.rs (or snapshot builder)\n- src/daemon/checkpoint.rs helpers (shard_path)","design":"Introduce a typed `CheckpointShardPath` (or `CheckpointShardKey` + `to_path()`), containing namespace, shard kind, and shard id. Store these in the dirty shard sets instead of raw strings, and only render to path strings when serializing snapshots. Update helpers like `shard_path` to construct the typed value.","id":"bd-1vk","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Checkpoint dirty shards should be typed (no raw String paths)","type":"chore"}
{"_at":[1768622522322,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] socket_path() returns natural path when short enough\n- [ ] socket_path() returns /tmp/beads-<hash> for long paths\n- [ ] Hash is deterministic for same workspace\n- [ ] Symlinks resolve to same hash\n- [ ] macOS case-insensitive paths handled via realpath\n- [ ] Socket directory created with 0700 permissions\n- [ ] Socket directory cleaned up on daemon shutdown\n- [ ] Works on both macOS and Linux\n- [ ] No regression for short paths","created_at":[1768622522322,0],"created_by":"darin@darinsmcstudio2.lan","description":"","design":"Port the long socket path handling from Go beads to beads-rs.\n\n## Problem\n\nUnix domain sockets have strict path length limits:\n- macOS: 104 bytes (including null terminator)\n- Linux: 108 bytes\n\nWhen workspace path is deep, `.beads/bd.sock` exceeds this limit and daemon fails to start.\n\n## Go beads solution\n\nUse hash-based short paths in /tmp for deep directories:\n1. Compute SHA256 hash of canonicalized workspace path\n2. Create socket at `/tmp/beads-{hash}/bd.sock`\n3. Use natural path `.beads/bd.sock` when short enough\n\nThis ensures:\n- Different workspaces get different socket dirs\n- Same workspace always gets same hash (deterministic)\n- Symlinks and case differences resolve to same hash\n\n## Implementation approach\n\n**Core utilities** (`src/daemon/socket_path.rs`):\n```rust\n/// Maximum Unix socket path length (macOS: 103, Linux: 107)\nconst MAX_SOCKET_PATH: usize = 103;\n\n/// Returns appropriate socket path for workspace\npub fn socket_path(workspace: &Path) -> PathBuf {\n    // Canonicalize for consistent hashing\n    let canonical = normalize_path_for_comparison(workspace);\n    \n    let natural_path = workspace.join(\".beads/bd.sock\");\n    \n    if natural_path.as_os_str().len() <= MAX_SOCKET_PATH {\n        natural_path\n    } else {\n        short_socket_path(&canonical)\n    }\n}\n\nfn short_socket_path(canonical_path: &Path) -> PathBuf {\n    use sha2::{Sha256, Digest};\n    \n    let mut hasher = Sha256::new();\n    hasher.update(canonical_path.as_os_str().as_bytes());\n    let hash = hasher.finalize();\n    \n    // Use first 8 hex chars (4 bytes)\n    let hash_str = hex::encode(&hash[..4]);\n    \n    Path::new(\"/tmp\")\n        .join(format!(\"beads-{}\", hash_str))\n        .join(\"bd.sock\")\n}\n\n/// Create socket directory if needed\npub fn ensure_socket_dir(socket_path: &Path) -> Result<()> {\n    let dir = socket_path.parent().unwrap();\n    \n    // Only create for /tmp/beads-* directories\n    // Don't create .beads directories (should exist)\n    if dir.starts_with(\"/tmp/beads-\") {\n        fs::create_dir_all(dir)?;\n        // Set permissions 0700 for security\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            fs::set_permissions(dir, fs::Permissions::from_mode(0o700))?;\n        }\n    }\n    \n    Ok(())\n}\n\n/// Cleanup socket directory on shutdown\npub fn cleanup_socket_dir(socket_path: &Path) -> Result<()> {\n    let dir = socket_path.parent().unwrap();\n    \n    // Only remove /tmp/beads-* directories we created\n    if dir.starts_with(\"/tmp/beads-\") {\n        let _ = fs::remove_file(socket_path);\n        let _ = fs::remove_dir(dir); // Fails if not empty, that's fine\n    } else {\n        // For .beads/ directories, just remove socket\n        let _ = fs::remove_file(socket_path);\n    }\n    \n    Ok(())\n}\n```\n\n**Path canonicalization** (`src/daemon/path.rs`):\n```rust\n/// Normalize path for comparison (handles symlinks, case-insensitive FS)\npub fn normalize_path_for_comparison(path: &Path) -> PathBuf {\n    // 1. Resolve to absolute\n    let abs = path.canonicalize().unwrap_or_else(|_| path.to_path_buf());\n    \n    // 2. Resolve symlinks\n    let canonical = abs.canonicalize().unwrap_or(abs);\n    \n    // 3. On macOS, resolve to true filesystem case\n    #[cfg(target_os = \"macos\")]\n    {\n        if let Ok(resolved) = resolve_canonical_case(&canonical) {\n            return resolved;\n        }\n    }\n    \n    canonical\n}\n\n#[cfg(target_os = \"macos\")]\nfn resolve_canonical_case(path: &Path) -> Result<PathBuf> {\n    use std::process::Command;\n    \n    let output = Command::new(\"realpath\")\n        .arg(path)\n        .output()?;\n    \n    if output.status.success() {\n        let resolved = String::from_utf8_lossy(&output.stdout)\n            .trim()\n            .to_string();\n        Ok(PathBuf::from(resolved))\n    } else {\n        Err(Error::PathCanonicalization)\n    }\n}\n```\n\n## Files to reference\n\nGo implementation:\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/rpc/socket_path.go`\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/utils/path.go`\n\n## Design notes\n\n**Why /tmp and not $TMPDIR**:\n- On macOS, $TMPDIR is very long: `/var/folders/xx/xxxxxxxxxxxx/T/`\n- /tmp is short and standard across Unix systems\n- Defeats the purpose if temp dir is also too long\n\n**Case-insensitive filesystems** (macOS, Windows):\n- Must use `realpath` to get true filesystem case\n- Ensures `/Users/foo/Desktop` and `/users/foo/desktop` hash the same\n- Critical for daemon socket discovery\n\n**Socket directory cleanup**:\n- Remove on daemon shutdown\n- Only if directory is in /tmp/beads-*\n- Don't remove .beads directories (user data)\n\n**Backwards compatibility**:\n- If natural path is short enough, use it\n- Existing workspaces with short paths unaffected\n- Only deep paths trigger hash-based fallback\n\n## Questions\n\n1. Should we warn user when using hash-based path?\n2. Should hash use full SHA256 or truncated?\n3. Should we document the hash mapping somewhere?\n4. Handle Windows path limits differently?","id":"bd-ze0x.42","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":7218166669106337976,"replica":"0713bf96-b9f2-5698-c808-388c14318112"}]}},"priority":2,"status":"open","title":"Handle long socket paths - Unix socket 103-108 byte limit via /tmp/beads-<hash>/","type":"bug"}
