{"_at":[1768530397553,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768503238667,1],"darin@book"],"claim":[[1768529807546,1],"darin@book"],"description":[[1768503238667,1],"darin@book"],"design":[[1768503238667,1],"darin@book"],"estimated_minutes":[[1768503238667,1],"darin@book"],"external_ref":[[1768503238667,1],"darin@book"],"labels":[[1768503238667,1],"darin@book"],"priority":[[1768503238667,1],"darin@book"],"source_repo":[[1768503238667,1],"darin@book"],"title":[[1768503238667,1],"darin@book"],"type":[[1768503238667,1],"darin@book"]},"acceptance_criteria":"- [ ] Dirty shard tracking uses a typed shard/path type, not `String`.\n- [ ] Snapshot serialization still emits the same on-disk shard paths.\n- [ ] Dirty shard tests updated to use the typed value.","assignee":"darin@book","assignee_at":[1768529807546,1],"assignee_expires":1768533407546,"closed_at":[1768530397553,1],"closed_by":"darin@book","created_at":[1768503238667,1],"created_by":"darin@book","description":"**Problem**\n`StoreRuntime` tracks checkpoint dirty shards as `BTreeSet<String>` of shard paths (`checkpoint_dirty_shards` / `checkpoint_dirty_inflight`). This mixes path construction with storage and makes it easy to emit inconsistent shard paths or forget to update a path format. It also spreads stringly-typed shard logic across the runtime.\n\n**Files**\n- src/daemon/store_runtime.rs\n- src/daemon/checkpoint_snapshot.rs (or snapshot builder)\n- src/daemon/checkpoint.rs helpers (shard_path)","design":"Introduce a typed `CheckpointShardPath` (or `CheckpointShardKey` + `to_path()`), containing namespace, shard kind, and shard id. Store these in the dirty shard sets instead of raw strings, and only render to path strings when serializing snapshots. Update helpers like `shard_path` to construct the typed value.","id":"bd-1vk","labels":[],"priority":2,"status":"closed","title":"Checkpoint dirty shards should be typed (no raw String paths)","type":"chore"}
