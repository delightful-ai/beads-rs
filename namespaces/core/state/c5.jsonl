{"_at":[1769560826154,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769204890711,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Segment:** crdt/7-cleanup (bd-3zoj.11, bd-3zoj.12)\n**Files:** 33 files, -880 lines net (major deletions: src/git/collision.rs, DepEdge/DepLife, NoteLog)\n**RepoPrompt chat:** crdt-cleanup-review-801B27\n\n---\n\n## Summary (what these changes accomplish)\n\n- **WAL snapshot dep serialization is now JSON-safe and deterministic**: `DepStore` is encoded as a `WalDepStore { cc, entries[], stamp }` (mirrors the checkpoint/git approach of \"entry lists\"), and legacy dep snapshots are still convertible via `dep_store_from_legacy`.\n- **Core CRDT model looks cleaned of legacy dep/note/label structures** in the provided context:\n  - Core deps are `DepKey` OR-Set membership (no core `DepEdge`/`DepLife`).\n  - Notes are in `NoteStore` (no `NoteLog` embedded in `Bead`).\n  - Labels are OR-Set state in `LabelStore` (no LWW label field in `BeadFields`).\n- **Git sync merge path is simplified**: `src/git/sync.rs` merges via `CanonicalState::join` directly; there's no collision \"remap\" module or call site shown.\n\n## Critical issues / must-address\n\n### 1) \"Collision ApplyError paths are gone\" is **not true yet**\nIn `src/core/apply.rs` the enum still includes:\n- `ApplyError::BeadCollision`\n- `ApplyError::NoteCollision`\n\nAnd at least one is still referenced:\n\n```rs\nstate\n  .insert(bead)\n  .map_err(|_| ApplyError::BeadCollision { id: id.clone() })?;\n```\n\nEven if this is \"effectively unreachable\" after the earlier collision-handling logic, it still violates the segment 7 acceptance criterion you cited (\"ApplyError/collision legacy paths are gone\").\n\n**Action**:\n- If collisions are now always resolved deterministically, **remove these variants** and refactor the remaining callsites to be infallible (or treat failures as internal invariants with `expect`/panic + metrics).\n- If there are still legitimate failure cases, document them explicitly and reconcile with the \"apply total\" constraint.\n\n### 2) WAL format change may break \"recent-but-not-ancient\" WAL snapshots\n`WalStateV2.deps` changed from `DepStore` → `WalDepStore`. With the current untagged enum:\n\n```rs\nenum WalStateRepr {\n  V2(WalStateV2),        // now expects WalDepStore\n  LegacyVecs(...),       // expects Vec<LegacyWalDep>\n  LegacyMaps(...),       // expects BTreeMap<DepKey, ...>\n}\n```\n\nA WAL written by the immediately previous code (when deps were a `DepStore` JSON object) likely won't match *any* variant, because:\n- it won't deserialize as `WalDepStore`, and\n- it won't look like the legacy vec/map shapes.\n\nGiven your global constraint (\"old local stores unsupported; wipe\"), this might be acceptable — but then keeping legacy parsing paths is a bit inconsistent.\n\n**Action** (pick one):\n- **Accept breakage** and explicitly document that WAL files from earlier builds are unsupported and should be deleted on upgrade.\n- Or add a transitional variant that can deserialize the previous `DepStore`-shaped deps (even if only for dev ergonomics).\n\n### 3) `WalDepStore::into_dep_store` inserts empty-dot entries (potentially unsafe)\nThis code:\n\n```rs\nif dots.is_empty() {\n    map.entry(entry.key).or_default();\n} else {\n    map.insert(entry.key, dots);\n}\n```\n\nRisks creating OR-Set `entries` containing keys with empty dot sets. Whether that's harmless depends on `OrSet` invariants:\n- If `OrSet::values()`/`is_empty()`/`contains()` assume \"no empty dot sets\", you can get subtle bugs (phantom values, incorrect emptiness, etc.).\n\n**Action**:\n- Prefer **skipping empty-dot entries entirely**, or normalize through an `OrSet` constructor that prunes empties.\n- If empty entries are intentionally meaningful, add an explicit comment explaining why and ensure `OrSet` APIs treat them correctly.\n\n## Minor improvements (quality/cleanup)\n\n- **DRY**: `WalDepStore` is structurally very similar to `WireDepStoreV1`/`WireDepEntryV1`. If layering allows, consider reusing the existing wire structs (or extracting a shared internal representation) to avoid divergence.\n- **`Labels::remove` returns `true` unconditionally** (`src/core/collections.rs`). That's misleading and can hide bugs at call sites. Either:\n  - return the real \"changed?\" boolean (`before_len \\!= after_len`), or\n  - make it `fn remove(&mut self, label: &str)` without a return value.\n\n## What's done particularly well\n\n- **The WAL deps change is targeted and solves a real problem**: serializing `BTreeMap<DepKey, ...>` to JSON is not viable (non-string keys), and the new entry-list format aligns with the checkpoint/git dep encoding.\n- **Git sync is now cleanly CRDT-based**: merge uses `CanonicalState::join` with no sign of ID remap collision hacks, which is exactly the desired direction.\n- **Core model cleanup appears consistent**: DepKey-only deps, OR-Set labels, NoteStore notes, and no bead-embedded NoteLog in the shown files.\n\n## Specific next steps\n\n1. **Remove collision error variants** (`ApplyError::BeadCollision`, `ApplyError::NoteCollision`) and any remaining call sites that can surface them, or justify them with explicit invariants/docs.\n2. **Decide on WAL backward-compat stance**:\n   - If \"wipe is fine\", add a comment and possibly a more explicit error message instructing deletion.\n   - If not, add a transitional deserialization branch for the previous `DepStore` JSON shape.\n3. **Prune empty-dot handling** in `WalDepStore::into_dep_store` unless you can prove `OrSet` tolerates it.\n4. Run a final grep-based audit (or CI check) for the explicit delete list tokens:\n   - `NoteLog`, `DepLife`, core `DepEdge`, `WireDepV1`, `WireDepDeleteV1`, `WireBeadPatch.labels`, `git::collision`/remap callsites, and the collision ApplyError variants.","id":"bd-ogvs.7","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Segment 7: Cleanup review","type":"task"}
{"_at":[1767920141478,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1767916544774,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`BeadOp` and `Request::to_op`/`to_query` duplicate the IPC field definitions but are not used by the runtime path (`Daemon::handle_request` does its own parsing). This duplication adds surface area without benefit and makes it harder to reason about which path is authoritative.\n\n**Design**\nSimplify the IPC/ops surface by removing unused conversion helpers:\n- Audit call sites to confirm `BeadOp` and `Request::to_op`/`to_query` are unused outside tests.\n- Remove `Request::to_op`/`to_query` and the `BeadOp` type if unused; update tests accordingly.\n- If external API concerns exist, replace with a small internal helper or mark the methods `#[deprecated]` and keep a single authoritative path (`handle_request`).\n\n**Design Notes**\nGoal is to reduce duplication and keep one clear entry point for validation and parsing.\n\n**Acceptance**\n- [ ] Unused `BeadOp`/`Request::to_op`/`to_query` code is removed or deprecated with no functional change.\n- [ ] IPC request handling continues to use a single authoritative parsing path.\n- [ ] Run `codex review --uncommitted` (timeout 10m) and address findings.\n- [ ] Tests pass.\n\n**Files:** `src/daemon/ipc.rs`, `src/daemon/ops.rs`, `src/daemon/core.rs`","id":"bd-omw.6","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Remove unused BeadOp / Request::to_op duplication","type":"chore"}
