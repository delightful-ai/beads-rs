{"_at":[1768279233651,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1768271759318,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nInserting an event with the same (namespace, origin_replica_id, origin_seq) but different sha triggers a SQLite constraint error and is mapped to index_corrupt, leaving equivocation unreachable.\n\n**Where**\n- src/daemon/wal/index.rs: SqliteWalIndexTxn::record_event inserts into events with PK on (namespace, origin_replica_id, origin_seq)\n- src/daemon/ops.rs: wal_index_error_code maps WalIndexError::Sqlite(_) to index_corrupt\n\n**Design**\n- On conflict, detect existing row and compare sha256; if different, emit equivocation with details (namespace, origin_replica_id, origin_seq, expected_sha256, got_sha256).\n- Avoid using generic SQLite error for equivocation.\n\n**Acceptance**\n- Equivocation is reported via ErrorCode::Equivocation, not index_corrupt.\n- Normal duplicate insert with same sha remains idempotent (no error).\n\n**Files**\n- src/daemon/wal/index.rs\n- src/daemon/ops.rs\n- src/daemon/ipc.rs","id":"bd-3m5.72","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"WAL index: detect equivocation on EventId reuse","type":"bug"}
{"_at":[1768492134064,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1765744422313,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nThe invariant \"live ∩ tombstones = ∅\" is enforced by careful method design:\n```rust\npub struct CanonicalState {\n    live: BTreeMap<BeadId, Bead>,\n    tombstones: BTreeMap<BeadId, Tombstone>,\n    // ...\n}\n```\n\nThis relies on `insert`/`delete` being correct. A bug could violate the invariant.\n\n**Design**\nMake the invariant structurally impossible:\n```rust\npub enum BeadEntry {\n    Live(Bead),\n    Tombstone(Tombstone),\n}\n\npub struct CanonicalState {\n    beads: BTreeMap<BeadId, BeadEntry>,\n    deps: BTreeMap<DepKey, DepEdge>,\n}\n```\n\nNow a bead cannot be both live and tombstoned - the type system prevents it.\n\n**Design Notes**\n- Bigger refactor than the other type improvements\n- Consider doing this when touching `state.rs` for other reasons\n- `get_live`/`get_tombstone` become pattern matches on entry\n- Iteration patterns change (`live.values()` → `beads.values().filter_map(...)`)\n- Wire format (`src/git/wire.rs`) may need adjustment\n\n**Acceptance**\n- [ ] `BeadEntry` enum in `src/core/state.rs`\n- [ ] `CanonicalState` uses single `beads: BTreeMap<BeadId, BeadEntry>`\n- [ ] All accessors (`get_live`, `get_tombstone`, iteration) updated\n- [ ] Wire format handles the change\n- [ ] Invariant comment updated to note its now structural\n- [ ] Tests pass\n\n**Files:** src/core/state.rs, src/git/wire.rs","id":"bd-di1","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Collapse live/tombstones into single BeadEntry map","type":"chore"}
