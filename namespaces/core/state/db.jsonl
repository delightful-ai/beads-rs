{"_at":[1770502825649,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] All identified consumers migrated\n- [ ] Existing model/fuzz workflows build\n- [ ] No daemon-internal imports remain in migrated consumers","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1770498238598,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nExternal consumers are pinned to old daemon-internal paths.","design":"Update imports/adapters in stateright models, fuzz targets, and model adapters to shared crate.","id":"bd-21eg.26","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Migrate stateright/fuzz/model adapters to shared daemon-core crate","type":"task"}
{"_at":[1768454029760,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Inbound session rejects EVENTS for namespaces not in incoming_namespaces.\n- [ ] Outbound streaming/hot cache only sends namespaces in accepted_namespaces.\n- [ ] Outbound WANT handling is scoped to accepted_namespaces.\n- [ ] Tests cover accept/reject behavior.\n\n**Files:** src/daemon/repl/session.rs, src/daemon/repl/manager.rs, src/daemon/repl/server.rs","assignee":"darin@book","created_at":[1768448953374,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nInbound replication accepts EVENTS for any namespace, regardless of negotiated namespaces. Outbound replication continues to publish events for namespaces the peer did not accept. This breaks namespace policy invariants and makes the allowlist in HELLO/WELCOME advisory only.\n\n**Evidence**\n- src/daemon/repl/session.rs: handle_events() never checks frame.eid.namespace against peer.incoming_namespaces (stored on SessionPeer).\n- src/daemon/repl/manager.rs: run_peer_loop() filters outgoing events using offered_set (plan/offered), not the negotiated accepted_namespaces from session.peer().\n- src/daemon/repl/manager.rs: handle_want() has no allowed_set filter, so it can send events for namespaces the peer never accepted.\n\n**Why this hurts**\nNamespace policy is meant to be a hard boundary. Without enforcement, a misconfigured or malicious peer can ingest or receive data outside its allowed namespaces.","design":"**Design**\n1) Enforce inbound namespaces in Session::handle_events(): if namespace not in peer.incoming_namespaces, return an error payload (NamespacePolicyViolation or InvalidRequest) and close.\n2) Outbound: after handshake, derive accepted_set from session.peer().accepted_namespaces and use it for filtering pending events + hot cache + live stream. Replace offered_set usage.\n3) Update manager::handle_want() to accept an allowed_set (like server.rs) and ignore or error on wants outside accepted_set.\n4) Add tests for both directions (reject unexpected namespace; only send accepted namespaces).\n\nNote: inbound server already builds accepted_set; align outbound to use the negotiated set.","id":"bd-23h","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Replication does not enforce namespace allowlists","type":"bug"}
{"_at":[1769511982141,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `Request::info()` (or equivalent) exists and is the **only** match that maps requests → repo/namespace/actor/read/op.\n- [ ] `RequestContext::from_request()` and `read_gate_request()` are removed from `crates/beads-rs/src/daemon/server.rs`.\n- [ ] Tracing spans include the same fields/values as before for all ops.\n- [ ] Read gate behavior is unchanged for all ops.\n- [ ] `cargo test` passes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769481316008,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIPC request metadata is extracted in multiple places with large, partially overlapping matches:\n- `crates/beads-rs/src/daemon/server.rs` has `RequestContext::from_request()` for span metadata and `read_gate_request()` for read gating.\n- `crates/beads-rs/src/daemon/coord.rs` has the big request dispatch match that re-states which ops are mutation/read/repo-only.\nThis duplication makes it easy to forget to update one path when new ops are added, causing silent drift in logging or read-gate coverage.\n\n**Design**\nAfter the ctx/payload refactor (bd-ebhh), introduce a single request metadata extraction path and route all span + read-gate logic through it.\n\n1) Add a shared metadata carrier:\n- `RequestInfo` (or `RequestExt`) with fields:\n  - `op: &'static str` (request type string for tracing)\n  - `repo: Option<&Path>`\n  - `namespace: Option<&str>`\n  - `actor_id: Option<&str>`\n  - `client_request_id: Option<&str>`\n  - `read: Option<&ReadConsistency>`\n- Implement `Request::info(&self) -> RequestInfo<'_>` using a **single match** on `Request` variants.\n  - Mutations use `MutationCtx` fields.\n  - Reads use `ReadCtx` fields.\n  - Repo-only ops use `RepoCtx` with no namespace/read.\n  - Admin flush/checkpoint read namespace from payload (not `ReadCtx`).\n  - `Ping`/`Shutdown` return `None` repo.\n\n2) Add convenience methods on `Request`:\n- `read_gate(&self) -> Option<ReadGateRequest>` built from `RequestInfo` (repo + read), to fully replace the current `read_gate_request()` match.\n- (Optional) `request_type(&self) -> &'static str` if it helps keep spans simple.\n\n3) Update server span + read gate logic:\n- Replace `RequestContext::from_request()` usage with `request.info()`.\n- Delete `RequestContext` struct entirely if no longer needed.\n- Replace `read_gate_request()` with the new `Request::read_gate()`.\n- Keep `read_consistency_tag()` and its semantics intact, but feed it from `RequestInfo.read`.\n\n4) Ensure the op names used in spans are **exactly** the current names (e.g., \"add_labels\", \"admin_reload_limits\").\n\n**Design Notes**\n- This is strictly a refactor: no wire format or behavior changes.\n- The single match should live in one place. Prefer `beads-surface` if it’s useful across crates, or a daemon-only extension (e.g., `crates/beads-rs/src/daemon/ipc/request_info.rs`) if we want to keep it internal.\n- Pay special attention to Admin ops with namespace payloads and to read-gated operations: the read gate coverage must remain identical.\n\n**Files**\n- `crates/beads-rs/src/daemon/server.rs`\n- `crates/beads-rs/src/daemon/ipc/mod.rs` (if adding extension helpers)\n- `crates/beads-surface/src/ipc/types.rs` (if implementing `Request::info` there)\n- `crates/beads-rs/src/daemon/server.rs` tests (span/read-gate coverage)","id":"bd-m7v0","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Centralize IPC request metadata extraction","type":"chore"}
{"_at":[1769502647044,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] It is impossible to construct a dep add/remove op with `from == to` without a fallible conversion.\n- [ ] Wire serialization remains backward-compatible (same JSON fields).\n- [ ] `validate_event_body_semantics` no longer needs a self-dep check.\n- [ ] Existing dep-related tests pass; add at least one compile-time or conversion test for self-dep rejection.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769483948227,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nDependency self-edges are only prevented by runtime validation (`validate_event_body_semantics` checks `from == to`). Yet the domain already has `DepKey::new` which makes self-deps impossible. Wire ops (`WireDepAddV1`/`WireDepRemoveV1`) still carry raw `from/to/kind`, so invalid states are representable until runtime. This makes it easy for new codepaths to forget validation and introduce self-deps, and it violates the “information holds its shape” / “types tell the truth” principles.\n\nKey references:\n- `crates/beads-core/src/dep.rs:52` — `DepKey::new` enforces non-self.\n- `crates/beads-core/src/event.rs:2371` — runtime self-dep check.\n- `crates/beads-core/src/wire_bead.rs:683` — wire dep ops store raw `from/to/kind`.\n\nSeverity: Self-deps are logically invalid and can cause cycle detection/path logic to misbehave. Relying on runtime checks here is fragile and non-local.","design":"**Design**\nRepresent dependency operations in terms of `DepKey` (or a `NonSelfDepKey` newtype) so self-deps are unrepresentable.\n\n1) Introduce `NonSelfDepKey(DepKey)` (or reuse `DepKey` directly) with serde that preserves the existing wire shape `{from,to,kind}`.\n2) Update `WireDepAddV1`/`WireDepRemoveV1` to store `key: NonSelfDepKey` and expose accessors for `from/to/kind`.\n3) Provide serde impls that encode/decode to the same JSON layout to maintain compatibility.\n4) Update `TxnOpV1::key()` and any dep handling to use the new key field.\n5) Remove the self-dep check in `validate_event_body_semantics` once it’s structurally impossible, leaving only the tombstone lineage validation.\n\nMigration notes:\n- If serde compatibility is risky, add `#[serde(flatten)]` with a custom proxy to preserve wire form.\n- Add a small conversion layer for old tests/fixtures if needed.","id":"bd-qn3o","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Make dependency ops carry non-self DepKey in wire types","type":"bug"}
{"_at":[1768622413176,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622413176,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nUsers need contextual guidance after commands. Go beads has a tip system that shows hints based on conditions, with frequency throttling and probability rolls.\n\n**Design**\nImplement tip system with:\n- `Tip` struct: ID, condition function, message, frequency (min gap), priority, probability (0.0-1.0)\n- `maybeShowTip()`: selects and displays tip respecting --json and --quiet flags\n- `selectNextTip()`: filters eligible tips by condition + frequency, sorts by priority, applies probability roll\n- `BEADS_TIP_SEED` env var for deterministic testing\n- Metadata storage: `tip_{id}_last_shown` timestamp in database\n\nSelection algorithm:\n1. Filter to eligible tips (condition true AND frequency elapsed)\n2. Sort by priority (descending)\n3. Apply probability roll in priority order (higher priority tips get first chance)\n\nBuilt-in tips:\n- Claude setup: priority 100, 24h gap, 60% probability when Claude detected but not configured\n- Sync conflict: priority 200, no frequency limit, 100% probability (always show when sync broken)\n\nReference: `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/cmd/bd/tips.go`\n\n**Design Notes**\n- Tips are informational, not errors (use stdout, not stderr)\n- Skip in JSON mode or quiet mode\n- Thread-safe tip registry with RwLock\n- InjectTip/RemoveTip for dynamic tips at runtime\n- Use chrono for time parsing/formatting (RFC3339)\n\n**Acceptance**\n- [ ] Tip struct with condition, message, frequency, priority, probability\n- [ ] maybeShowTip respects --json and --quiet\n- [ ] selectNextTip filters by condition and frequency\n- [ ] Priority-ordered probability rolls (higher priority first)\n- [ ] BEADS_TIP_SEED for deterministic testing\n- [ ] Built-in Claude setup and sync conflict tips\n- [ ] Metadata tracking (last shown timestamp)\n\n**Files:**\n- `src/cli/tips.rs` (new)\n- `src/cli/mod.rs` (integrate into post-command hook)","id":"bd-ze0x.9","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"open","title":"Tip system with contextual hints","type":"feature"}
