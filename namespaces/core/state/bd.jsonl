{"_at":[1768531457476,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `src/daemon/ipc/` contains separate `types`, `codec`, and `client` modules.\n- [ ] Existing imports continue to compile via re-exports.\n- [ ] No behavior change; `cargo test` passes.","created_at":[1768508732893,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n- `src/daemon/ipc.rs` is ~3k LOC and mixes protocol schema, codecs, socket path logic, and daemon auto-start client logic.\n- This blurs boundaries and makes changes risky.\n\n**Files:**\n- src/daemon/ipc.rs\n- src/daemon/mod.rs\n- src/cli/mod.rs (imports)\n- src/api/mod.rs (only if types move)","design":"- Convert `ipc.rs` into `src/daemon/ipc/` with `mod.rs`.\n- Move request/response types into `ipc/types.rs`.\n- Move encode/decode and error mapping into `ipc/codec.rs`.\n- Move socket path + autostart + send_request/subscribe into `ipc/client.rs`.\n- Re-export the same symbols from `ipc/mod.rs` to keep the public API stable.","id":"bd-0jl3","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Split IPC into types/codec/client modules","type":"chore"}
{"_at":[1768200219626,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1768178911548,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nCheckpoint hashes require canonical JSON (sorted keys, no whitespace). serde_json doesn't guarantee key order.\n\n**Context**\n- REALTIME_PLAN.md §13.3 (canonical JSON normative)\n\n**Design**\n- Create src/core/json_canon.rs (or src/git/checkpoint/json_canon.rs)\n- API: fn to_canon_json_bytes<T: Serialize>(v: &T) -> Vec<u8>\n- Requirements:\n  - Keys sorted by UTF-8 byte order ascending, recursively\n  - No insignificant whitespace\n  - No NaN/Infinity floats (reject if encountered)\n  - Deterministic escaping\n- Used by checkpoint export and manifest/meta writers\n\n**Acceptance**\n- [ ] to_canon_json_bytes produces deterministic output\n- [ ] Keys sorted recursively\n- [ ] Tests verify byte-for-byte reproducibility\n- [ ] NaN/Infinity rejected\n\n**Files:** src/core/json_canon.rs (new), src/git/checkpoint/export.rs","id":"bd-3m5.44","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 2: Canonical JSON encoder for checkpoints","type":"task"}
{"_at":[1768207345883,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Can append and read back a record frame with crc32c validation.\n- [ ] Segment creation and rotation follow naming and fsync rules.\n- [ ] MAX_WAL_RECORD_BYTES enforced before writing.","assignee":"darin@darinsmacstudio.lan","created_at":[1768177813446,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nPhase 3: implement the event WAL segment format and framing. Current `src/daemon/wal.rs` is a snapshot WAL; there is no event log, framing, or segment rotation.\n\n**Context**\n- REALTIME_PLAN.md §0.9 (segment naming), §0.10 (LocalFsync), §6.4 and §6.5 (crash consistency)\n- Framing uses crc32c (REALTIME_PLAN.md §9.1)\n**Files:** src/daemon/wal/mod.rs (new), src/daemon/wal/frame.rs (new), src/daemon/wal/segment.rs (new), src/daemon/wal/record.rs (new)","design":"**Design**\n- Define WAL segment header with store_id, store_epoch, namespace, wal_format_version, created_at_ms, segment_id.\n- Define record header with EventId fields, sha256, prev_sha256 (optional), event_time_ms, txn_id, client_request_id, request_sha256 (optional), and record_len.\n- Implement frame encoding with length + crc32c and tail truncation handling.\n- Implement segment rotation by size and age; create files under wal/<namespace>/segment-<created_at_ms>-<segment_id>.wal.\n- Implement LocalFsync semantics: fsync segment after append; fsync directory only on new segment creation.","id":"bd-3m5.9","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 3: Event WAL framing + segment writer","type":"task"}
{"_at":[1769773164288,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Nonces are either enforced at handshake or removed entirely.\n- [ ] No field remains that is never validated.\n- [ ] Tests cover nonce mismatch rejection (if enforced) or updated wire schema (if removed).\n- [ ] `cargo test` passes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769563176541,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nThe replication protocol includes `hello_nonce` and `welcome_nonce`, but they are never validated or correlated to a specific handshake attempt. They add apparent structure without enforcing any invariant. This is \"noise\" and \"lies\" per scatter: the types claim correlation that doesn’t exist.\n\n**Impact**\n- Gives a false sense of replay protection.\n- Adds fields that look load‑bearing but are not, increasing cognitive load.\n\n**Files**\n- `crates/beads-rs/src/daemon/repl/proto.rs` (wire fields)\n- `crates/beads-rs/src/daemon/repl/session.rs` (handshake transitions)\n","design":"**Design (pick one)**\nOption A (make them real):\n- Thread an `expected_hello_nonce` through the Handshaking state.\n- Include `hello_nonce` in `Welcome` (protocol change) or echo it back via a new field so the receiver can validate it.\n- Reject mismatched nonces at the parse boundary.\n\nOption B (remove):\n- Drop `hello_nonce` / `welcome_nonce` from the protocol if we don’t need replay correlation.\n- Simplify session state and tests.\n\nEither way, the type should tell the truth.","id":"bd-5szt","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"HELLO/WELCOME nonces are unused; make them real or remove","type":"chore"}
{"_at":[1769771267789,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] State digest helpers are centralized with explicit representation naming.\n- [ ] Ambiguous helpers are removed or renamed to include representation.\n- [ ] Comparisons between digests of different representations are prevented by types.\n- [ ] Tests cover each digest constructor and verify stable outputs.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769581967979,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n“State hash” concepts are scattered and ambiguous:\n- `StoreChecksums` in `crates/beads-rs/src/git/wire.rs` hashes JSONL blobs.\n- `canonical_state_sha` in `crates/beads-rs/src/model/digest.rs` hashes canonical JSON for `CanonicalState`.\n- Checkpoint `content_hash` hashes a canonical JSON preimage in `crates/beads-rs/src/git/checkpoint/meta.rs`.\n\nThese are different algorithms over different representations, but the naming doesn’t make the distinctions explicit. This is drift risk: readers and future code can easily compare or reuse the wrong digest.\n\n**Files:**\n- `crates/beads-rs/src/git/wire.rs`\n- `crates/beads-rs/src/model/digest.rs`\n- `crates/beads-rs/src/git/checkpoint/meta.rs`\n- `crates/beads-core/src/identity.rs` (ContentHash)","design":"**Design**\nMake state digests explicit by algorithm/representation and centralize helpers.\n\nConcrete plan:\n1) Introduce a `StateDigest` enum in `beads-core` with variants like `JsonlSha256`, `CanonicalJsonSha256`, `CheckpointContentSha256`.\n2) Provide constructors that name the exact input representation, with clear function names (e.g., `digest_state_jsonl`, `digest_state_canon_json`).\n3) Replace ambiguous helpers (`canonical_state_sha`) or rename them to include representation in the name.\n4) Ensure comparisons are only done between compatible digest variants.\n\n**Design Notes**\n- Keep `ContentHash` for generic hashes, but use `StateDigest` when semantics matter.\n- This makes incorrect comparisons a compile-time error.","id":"bd-gue7","labels":{"cc":{"max":{}},"entries":{"consistency":[{"counter":6202662529864946871,"replica":"c7b8bb9a-1a86-f4b5-d2c6-5627597b5543"}],"drift":[{"counter":11219092536443062155,"replica":"6074ca55-a072-bdd8-a4be-46f1fefe911f"}],"types":[{"counter":15908889637573640793,"replica":"7f94bf78-23f1-9bfd-9d79-041712c1fd29"}]}},"priority":2,"status":"closed","title":"Make state hash algorithms explicit (StateDigest)","type":"chore"}
{"_at":[1769586008771,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Post‑handshake messages are rejected if envelope version != negotiated version.\n- [ ] Reader loop API requires an expected version after handshake (compile-time forcing).\n- [ ] Tests cover: mismatched version for EVENTS/ACK/WANT rejected.\n- [ ] `cargo test` passes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769563157376,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`decode_envelope` returns a `ReplEnvelope { version, message }`, but the reader loop ignores `version` for all post‑handshake messages. Only HELLO/WELCOME check `protocol_version` against the envelope. For EVENTS/ACK/WANT/PING/PONG, a peer can send a different envelope version and we still accept it.\n\nThis violates parse‑don’t‑validate and turns the negotiated protocol version into a soft convention rather than an enforced invariant. It will break badly once a v2 exists.\n\n**Impact**\n- Protocol drift: incompatible versions can be accepted silently.\n- Hard-to-debug failures when formats change; errors surface far from the boundary.\n\n**Files**\n- `crates/beads-rs/src/daemon/repl/proto.rs` (decode_envelope)\n- `crates/beads-rs/src/daemon/repl/manager.rs` / `server.rs` (reader loops)\n","design":"**Design (opinionated)**\nEnforce version at the decode boundary using a typed envelope.\n\n1) Add a versioned decode entry point:\n```rust\nfn decode_envelope_with_version(bytes: &[u8], limits: &Limits, expected: u32) -> Result<ReplEnvelope, ProtoDecodeError>\n```\n- Reject if `envelope.version != expected` for any message type.\n\n2) Thread the negotiated protocol version into reader loops.\n- Before handshake: accept any version within local range for HELLO/WELCOME parsing.\n- After handshake: call `decode_envelope_with_version` with the negotiated version.\n\n3) Optional: typestate the envelope itself:\n- `ReplEnvelopeV1` type for v1 messages.\n- Reader returns the versioned envelope so you cannot ignore it.\n\nThis makes protocol version an explicit, enforced invariant.","id":"bd-lcyk","labels":{"cc":{"max":{}},"entries":{}},"notes":[{"at":[1769585373941,0],"author":"darin@darins-Mac-Studio-2.local","content":"Rendering should remain in the command files; avoid moving rendering into shared helpers.","id":"go-comment-bd-lcyk-1"},{"at":[1769586008771,0],"author":"darin@darinsmcstudio2.lan","content":"Rendering should remain in the command files; avoid moving rendering into shared helpers.","id":"legacy-notes"}],"priority":2,"status":"closed","title":"Repl envelope version must be validated against negotiated protocol","type":"bug"}
{"_at":[1769514960846,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `VerifiedRecord` cannot be constructed without canonical bytes bound to the exact event body.\n- [ ] WAL append APIs require canonical event bytes (or a canonical event wrapper).\n- [ ] Existing replay/ingest code updated; no ad‑hoc pairing of body + payload remains.\n- [ ] Tests updated or added to ensure mismatched body/payload cannot compile or fails at conversion boundary.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769494178189,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`VerifiedRecord` is “verified” only relative to a provided `EventBody`, but it doesn’t carry that body or ensure its payload bytes are the canonical encoding of that body. Callers can accidentally pair a header/payload with the wrong decoded body (or a non-canonical body encoding) while still constructing `VerifiedRecord`. This undermines the WAL’s trust boundary and violates the “information holds its shape” principle.\n\nKey references:\n- `crates/beads-rs/src/daemon/wal/record.rs:330` — verification uses `EventBody` passed from outside.\n- `crates/beads-core/src/event.rs:32` — `EventBytes<Canonical>` type exists but is not used in WAL record types.\n\nSeverity: a class of subtle integrity bugs where WAL frames are “verified” without actually binding bytes to semantic content.","design":"**Design**\nMake `VerifiedRecord` carry a canonical event representation that binds body ↔ bytes ↔ hash.\n\nOption A (canonical event wrapper):\n- Introduce `CanonicalEvent { body: EventBody<Validated>, bytes: EventBytes<Canonical>, sha256: Sha256 }`.\n- `VerifiedRecord` stores `CanonicalEvent` (or at least `EventBytes<Canonical>` + `sha256`), eliminating mismatched pairs.\n\nOption B (generic record state):\n- `Record<State>` where `State = Verified<Canonical>` includes `EventBytes<Canonical>` and `EventBody<Validated>`.\n- `verify_with_event_body` replaced by `verify_with_canonical(bytes: EventBytes<Canonical>, body: EventBody<Validated>)`.\n\nMigration:\n- Update WAL write APIs to require `CanonicalEvent` or `EventBytes<Canonical>`.\n- Update replay/ingest to decode bytes into canonical event (already enforced in core decode) and thread that through.\n\nNotes:\n- This should dovetail with the existing P0 bead to add `EventBody<Validated>`.","id":"bd-wni5","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Bind WAL VerifiedRecord to canonical event bytes/body","type":"bug"}
