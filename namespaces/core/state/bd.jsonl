{"_at":[1768531457476,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768508732893,1],"darin@book"],"claim":[[1768508732893,1],"darin@book"],"description":[[1768508732893,1],"darin@book"],"design":[[1768508732893,1],"darin@book"],"estimated_minutes":[[1768508732893,1],"darin@book"],"external_ref":[[1768508732893,1],"darin@book"],"labels":[[1768508732893,1],"darin@book"],"priority":[[1768508732893,1],"darin@book"],"source_repo":[[1768508732893,1],"darin@book"],"title":[[1768508732893,1],"darin@book"],"type":[[1768508732893,1],"darin@book"]},"acceptance_criteria":"- [ ] `src/daemon/ipc/` contains separate `types`, `codec`, and `client` modules.\n- [ ] Existing imports continue to compile via re-exports.\n- [ ] No behavior change; `cargo test` passes.","closed_at":[1768531457476,1],"closed_by":"darin@book","created_at":[1768508732893,1],"created_by":"darin@book","description":"**Problem**\n- `src/daemon/ipc.rs` is ~3k LOC and mixes protocol schema, codecs, socket path logic, and daemon auto-start client logic.\n- This blurs boundaries and makes changes risky.\n\n**Files:**\n- src/daemon/ipc.rs\n- src/daemon/mod.rs\n- src/cli/mod.rs (imports)\n- src/api/mod.rs (only if types move)","design":"- Convert `ipc.rs` into `src/daemon/ipc/` with `mod.rs`.\n- Move request/response types into `ipc/types.rs`.\n- Move encode/decode and error mapping into `ipc/codec.rs`.\n- Move socket path + autostart + send_request/subscribe into `ipc/client.rs`.\n- Re-export the same symbols from `ipc/mod.rs` to keep the public API stable.","id":"bd-0jl3","labels":[],"priority":2,"status":"closed","title":"Split IPC into types/codec/client modules","type":"chore"}
{"_at":[1768200219626,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1768178911548,1],"darin@darinsmacstudio.lan"],"claim":[[1768199758790,1],"darin@darinsmacstudio.lan"],"description":[[1768178911548,1],"darin@darinsmacstudio.lan"],"design":[[1768178911548,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768178911548,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768178911548,1],"darin@darinsmacstudio.lan"],"labels":[[1768178911548,1],"darin@darinsmacstudio.lan"],"priority":[[1768178911548,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768178911548,1],"darin@darinsmacstudio.lan"],"title":[[1768187796247,1],"darin@darinsmacstudio.lan"],"type":[[1768178911548,1],"darin@darinsmacstudio.lan"]},"assignee":"darin@darinsmacstudio.lan","assignee_at":[1768199758790,1],"assignee_expires":1768203358790,"closed_at":[1768200219626,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1768178911548,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nCheckpoint hashes require canonical JSON (sorted keys, no whitespace). serde_json doesn't guarantee key order.\n\n**Context**\n- REALTIME_PLAN.md §13.3 (canonical JSON normative)\n\n**Design**\n- Create src/core/json_canon.rs (or src/git/checkpoint/json_canon.rs)\n- API: fn to_canon_json_bytes<T: Serialize>(v: &T) -> Vec<u8>\n- Requirements:\n  - Keys sorted by UTF-8 byte order ascending, recursively\n  - No insignificant whitespace\n  - No NaN/Infinity floats (reject if encountered)\n  - Deterministic escaping\n- Used by checkpoint export and manifest/meta writers\n\n**Acceptance**\n- [ ] to_canon_json_bytes produces deterministic output\n- [ ] Keys sorted recursively\n- [ ] Tests verify byte-for-byte reproducibility\n- [ ] NaN/Infinity rejected\n\n**Files:** src/core/json_canon.rs (new), src/git/checkpoint/export.rs","id":"bd-3m5.44","labels":[],"priority":2,"status":"closed","title":"Phase 2: Canonical JSON encoder for checkpoints","type":"task"}
{"_at":[1768207345883,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1768177813446,1],"darin@darinsmacstudio.lan"],"claim":[[1768206029753,1],"darin@darinsmacstudio.lan"],"description":[[1768177813446,1],"darin@darinsmacstudio.lan"],"design":[[1768177813446,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768177813446,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768177813446,1],"darin@darinsmacstudio.lan"],"labels":[[1768177813446,1],"darin@darinsmacstudio.lan"],"priority":[[1768177813446,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768177813446,1],"darin@darinsmacstudio.lan"],"title":[[1768177813446,1],"darin@darinsmacstudio.lan"],"type":[[1768177813446,1],"darin@darinsmacstudio.lan"]},"acceptance_criteria":"- [ ] Can append and read back a record frame with crc32c validation.\n- [ ] Segment creation and rotation follow naming and fsync rules.\n- [ ] MAX_WAL_RECORD_BYTES enforced before writing.","assignee":"darin@darinsmacstudio.lan","assignee_at":[1768206029753,1],"assignee_expires":1768209629753,"closed_at":[1768207345883,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1768177813446,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nPhase 3: implement the event WAL segment format and framing. Current `src/daemon/wal.rs` is a snapshot WAL; there is no event log, framing, or segment rotation.\n\n**Context**\n- REALTIME_PLAN.md §0.9 (segment naming), §0.10 (LocalFsync), §6.4 and §6.5 (crash consistency)\n- Framing uses crc32c (REALTIME_PLAN.md §9.1)\n**Files:** src/daemon/wal/mod.rs (new), src/daemon/wal/frame.rs (new), src/daemon/wal/segment.rs (new), src/daemon/wal/record.rs (new)","design":"**Design**\n- Define WAL segment header with store_id, store_epoch, namespace, wal_format_version, created_at_ms, segment_id.\n- Define record header with EventId fields, sha256, prev_sha256 (optional), event_time_ms, txn_id, client_request_id, request_sha256 (optional), and record_len.\n- Implement frame encoding with length + crc32c and tail truncation handling.\n- Implement segment rotation by size and age; create files under wal/<namespace>/segment-<created_at_ms>-<segment_id>.wal.\n- Implement LocalFsync semantics: fsync segment after append; fsync directory only on new segment creation.","id":"bd-3m5.9","labels":[],"priority":2,"status":"closed","title":"Phase 3: Event WAL framing + segment writer","type":"task"}
