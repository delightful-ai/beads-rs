{"_at":[1765785752083,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1765690392995,0],"darin@dusk"],"claim":[[1765785589059,0],"darin@dusk"],"description":[[1765690392995,0],"darin@dusk"],"design":[[1765690392995,0],"darin@dusk"],"estimated_minutes":[[1765690392995,0],"darin@dusk"],"external_ref":[[1765690392995,0],"darin@dusk"],"labels":[[1765690392995,0],"darin@dusk"],"priority":[[1765690392995,0],"darin@dusk"],"source_repo":[[1765690392995,0],"darin@dusk"],"title":[[1765690392995,0],"darin@dusk"],"type":[[1765690392995,0],"darin@dusk"]},"assignee":"darin@dusk","assignee_at":[1765785589059,0],"assignee_expires":1765789189059,"closed_at":[1765785752083,0],"closed_by":"darin@dusk","closed_reason":"Made imported comment NoteIds globally unique by including issue ID in the format: go-comment-{issue_id}-{comment_id}. Added tests to verify uniqueness across issues.","created_at":[1765690392995,0],"created_by":"darin@dusk","description":"## What's Wrong\nGo comment notes are imported with `NoteId::new(c.id.to_string())`. If comment IDs are not globally unique across issues in beads-go exports, notes can collide and overwrite/merge unexpectedly.\n\n## Where\n- src/migrate/go_export.rs:288 (NoteId::new(c.id.to_string()))\n\n## Why It Matters\nData loss / silent merging during migration: two different comments could end up with the same note ID.\n\n## Suggested Fix\n- Make note IDs include the issue ID (and/or created_at) e.g. `go-comment-<issue-id>-<comment-id>`.\n- Add a migration test fixture with repeated comment IDs across different issues to verify uniqueness.\n\n## Acceptance\n- Import never drops/merges distinct comments due to note ID collisions.","id":"bd-3h8","labels":[],"priority":2,"status":"closed","title":"Migration: make imported comment NoteIds globally unique","type":"bug"}
{"_at":[1766124427691,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1766122283056,0],"darin@dusk"],"claim":[[1766124427591,0],"darin@dusk"],"description":[[1766122283056,0],"darin@dusk"],"design":[[1766122283056,0],"darin@dusk"],"estimated_minutes":[[1766122283056,0],"darin@dusk"],"external_ref":[[1766122283056,0],"darin@dusk"],"labels":[[1766122283056,0],"darin@dusk"],"priority":[[1766122283056,0],"darin@dusk"],"source_repo":[[1766122283056,0],"darin@dusk"],"title":[[1766122283056,0],"darin@dusk"],"type":[[1766122283056,0],"darin@dusk"]},"assignee":"darin@dusk","assignee_at":[1766124427591,0],"assignee_expires":1766128027591,"closed_at":[1766124427691,0],"closed_by":"darin@dusk","created_at":[1766122283056,0],"created_by":"darin@dusk","description":"**Problem**\\nSync/load/refresh pathways have overlapping but different logic. Edge cases (diverged refs, remote missing ref, local ahead, dirty during refresh, rewritten history) are not fully covered by tests. This risks subtle data loss or confusing behavior.\\n\\n**Design**\\nAdd a focused sync-state test harness that builds local/remote repos and exercises: missing refs, local-ahead, remote-ahead, diverged, force-push rewrite, fetch failures, dirty during refresh. Assert invariants: no local data loss, backups created, errors surfaced. Consider consolidating merge logic into a single path to reduce divergence.\\n\\n**Acceptance**\\n- [ ] Tests cover diverged/local-ahead/force-push scenarios.\\n- [ ] Failures are explicit; no silent state drops.\\n- [ ] Backups created when local history would be overwritten.\\n- [ ] Tests pass.\\n\\n**Files:** src/git/sync.rs, src/daemon/core.rs, src/daemon/git_worker.rs, tests/critical_path.rs","id":"bd-8gt","labels":[],"priority":1,"status":"closed","title":"Harden git sync state machine edge cases","type":"task"}
{"_at":[1767993540504,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1767985377496,1],"darin@darinsmacstudio.lan"],"claim":[[1767993478968,1],"darin@darinsmacstudio.lan"],"description":[[1767985377496,1],"darin@darinsmacstudio.lan"],"design":[[1767985377496,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1767985377496,1],"darin@darinsmacstudio.lan"],"external_ref":[[1767985377496,1],"darin@darinsmacstudio.lan"],"labels":[[1767985377496,1],"darin@darinsmacstudio.lan"],"priority":[[1767985377496,1],"darin@darinsmacstudio.lan"],"source_repo":[[1767985377496,1],"darin@darinsmacstudio.lan"],"title":[[1767985377496,1],"darin@darinsmacstudio.lan"],"type":[[1767985377496,1],"darin@darinsmacstudio.lan"]},"acceptance_criteria":"- [ ] New model file exists (e.g., beads_stateright_models/examples/read_gating_machine.rs) and compiles\n- [ ] Properties cover correct gating and timeout semantics per REALTIME_PLAN.md ยง16.1\n- [ ] Example runs via cargo run --example read_gating_machine (or equivalent)","assignee":"darin@darinsmacstudio.lan","assignee_at":[1767993478968,1],"assignee_expires":1767997078968,"closed_at":[1767993540504,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1767985377496,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nRead gating semantics (require_min_seen + wait_timeout_ms) are specified in REALTIME_PLAN.md ยง16.1 but not modeled. Without a model, it is easy to return stale reads or mis-handle retryable timeouts.\n\n**Design Notes**\nModel reads against applied watermarks and a bounded wait timer.","design":"**Design**\nCreate a Stateright model for read gating that uses applied watermarks as the truth (Plan ยง16.1). Include read requests with require_min_seen and wait_timeout_ms, and allow nondeterministic apply progress. Model should return: success if applied >= required, wait up to timeout, else return retryable error with current applied watermark.\n\nProperties: no read is returned with applied < require_min_seen; timeout responses are retryable and include the current watermark snapshot.","id":"bd-hjm.11","labels":["modeling","realtime","stateright"],"priority":3,"status":"closed","title":"Stateright: require_min_seen read gating + timeouts","type":"feature"}
