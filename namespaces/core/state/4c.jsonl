{"_at":[1769506489422,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] `StoreState` cannot be constructed without a core namespace (compile‑time enforced).\n- [ ] The `other` map cannot contain `NamespaceId::core()`.\n- [ ] All call sites that need core use explicit `core()` accessors, not `get()`.\n- [ ] Tests verify that non‑core namespace insertion rejects core.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769483948438,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`StoreState` can exist without the core namespace present. The map is just `BTreeMap<NamespaceId, CanonicalState>` with `get` returning `Option`. That means any caller that assumes core exists is relying on convention rather than the type system. The compiler cannot enforce “core namespace is always present”.\n\nKey refs:\n- `crates/beads-core/src/namespaced_state.rs:7` — `StoreState` is a plain map; core can be missing.\n\n**Impact**\nStructural invariant not encoded; subtle bugs when code assumes core exists (especially in daemon, repl, or query paths). This is the canonical namespace of the system; its absence is invalid.","design":"**Design (opinionated)**\nMake core namespace presence structural.\n\n1) Split core from non‑core:\n- `struct StoreState { core: CanonicalState, other: BTreeMap<NamespaceId, CanonicalState> }`.\n- `StoreState::new()` initializes `core` explicitly.\n\n2) Prevent `NamespaceId::core()` from entering the `other` map:\n- Introduce `NonCoreNamespaceId` wrapper returned by `NamespaceId::try_non_core()`.\n- `StoreState::set_namespace_state` should accept `NonCoreNamespaceId` for `other` namespaces and a dedicated `set_core_state` for core.\n\n3) Provide explicit core accessors:\n- `fn core(&self) -> &CanonicalState`\n- `fn core_mut(&mut self) -> &mut CanonicalState`\n\nThis makes “missing core” unrepresentable and pushes mistakes to compile time.","id":"bd-08th","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Encode core namespace presence in StoreState type","type":"bug"}
{"_at":[1768184607087,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1768184592437,0],"created_by":"darin@darinsmcstudio2.lan","description":"Enable uuid v5 support for store-id test derivation and wrap BD_DATA_DIR env var mutations in unsafe blocks to satisfy Rust 2024 safety checks.","id":"bd-1mi","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Fix phase 1 test harness compile errors","type":"chore"}
{"_at":[1770498846454,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Consumer inventory complete\n- [ ] Each dependency classified (shared-core vs daemon-internal)\n- [ ] Extraction blockers identified","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1770498230746,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nDaemon internals are consumed outside CLI, which can block crate extraction.","design":"Audit `model`, `fuzz`, `beads_stateright_models`, and integration fixtures for daemon imports and classify migration strategy.","id":"bd-21eg.3","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Inventory non-CLI daemon coupling (model/fuzz/stateright/tests)","type":"task"}
{"_at":[1770936635512,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Startup recovers from dead-owner store lock without manual filesystem edits.\n- [ ] Live daemon lock is never stolen.\n- [ ] Regression test covers dead PID + stale heartbeat recovery path.\n- [ ] `bd status`/startup logs clearly indicate when lock was reclaimed.","created_at":[1770936635512,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`bd` can fail hard when `.git/refs/heads/beads/store.lock` exists but the owning daemon process is gone (crash/kill/reap). We observed repeated startup failures requiring manual lock deletion.\n\nThis breaks the safety story for local recovery and creates operator footguns under crashy environments.\n\n**Observed behavior**\n- daemon startup reports lock acquisition failure for `refs/heads/beads/store.lock`\n- subsequent CLI commands fail until lock is manually removed","design":"Add first-party stale lock recovery in daemon startup/lock acquisition:\n1. Parse lock metadata (pid/actor/timestamps).\n2. If owner PID is dead (or heartbeat stale beyond threshold), reclaim lock safely.\n3. Persist heartbeat updates while lock is held.\n4. Keep explicit logs/metrics for reclaimed vs denied lock attempts.\n\nAvoid silent unlocks when owner is plausibly alive.","id":"bd-8i8j","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"open","title":"Daemon stale store lock recovery should be automatic and safe","type":"bug"}
{"_at":[1770673649994,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmcstudio2.lan","created_at":[1770673155834,0],"created_by":"darin@darinsmcstudio2.lan","description":"","id":"bd-bobi","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Restore human daemon info rendering in beads-cli print_ok","type":"bug"}
{"_at":[1769768658568,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] A canonical snapshot wire type and codec exist in `beads-core`.\n- [ ] Git store, checkpoint import/export, and WAL snapshot paths use the codec (legacy adapters isolated).\n- [ ] Ordering/uniqueness validation is enforced in one place.\n- [ ] Tests cover roundtrip serialization and invalid snapshot rejection through the codec.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769580722486,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nThere are multiple full-state snapshot formats with separate parsers/serializers:\n- Git store JSONL (`crates/beads-rs/src/git/wire.rs`): state/tombstones/deps/notes + meta.json\n- Checkpoint shards (`crates/beads-rs/src/git/checkpoint/*`): per-namespace shards using `WireBeadFull`\n- WAL legacy snapshots (`crates/beads-rs/src/daemon/wal_legacy_snapshot.rs`): serde snapshot with custom wire adapters\n\nEach format has its own ordering rules, validation logic, and limit checks. This is root scatter: state snapshots are not a single concept, so every correctness change must be repeated.\n\n**Files:**\n- `crates/beads-rs/src/git/wire.rs`\n- `crates/beads-rs/src/git/checkpoint/export.rs`\n- `crates/beads-rs/src/git/checkpoint/import.rs`\n- `crates/beads-rs/src/daemon/wal_legacy_snapshot.rs`\n- `crates/beads-core/src/wire_bead.rs`","design":"**Design**\nDefine a canonical snapshot codec in core and route git/checkpoint/WAL through it.\n\nConcrete plan:\n1) Add `SnapshotWireV1` in `beads-core` that represents a full snapshot (beads, tombstones, deps, notes, label states) with explicit ordering rules.\n2) Provide `SnapshotCodec` helpers for serialize/parse with deterministic ordering + validation (uniqueness, monotonic keys).\n3) Update git store serialization/parsing to use the snapshot codec (thin adapters for legacy layout).\n4) Update checkpoint export/import to map shard files to/from the snapshot codec (or reuse codec per shard).\n5) Replace WAL legacy snapshot serialization with the canonical snapshot codec (keep a legacy reader during migration).\n\n**Design Notes**\n- The goal is one canonical snapshot representation, with adapters for storage layout (git vs checkpoint vs wal).\n- Limit checks should live in the codec layer so all callers share the same policy.","id":"bd-lk0x","labels":{"cc":{"max":{}},"entries":{"scatter":[{"counter":486706750201976337,"replica":"3fa645b0-ac58-dff0-7ff1-e79ce2241d1d"}],"serialization":[{"counter":2885346753812815568,"replica":"420983bc-05b9-4189-739f-7230f436b25c"}],"tech-debt":[{"counter":114108186986265250,"replica":"e801e0a7-3de0-cffc-e6bb-f8bca7a9aaa3"}]}},"priority":2,"status":"closed","title":"Canonical snapshot codec across git/checkpoint/WAL","type":"chore"}
