{"_at":[1769510328182,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] It is impossible to construct `Observer + eligible` at compile time.\n- [ ] WAL decode fails (clear error) if an on-disk row encodes Observer+eligible.\n- [ ] All call sites use the new typed constructor or conversion.\n- [ ] Unit tests cover conversion success/failure and ensure serialization preserves current ordering.\n- [ ] `cargo test` passes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769502708689,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`ReplicaLivenessRow` stores `role: ReplicaRole` and `durability_eligible: bool` independently. This allows illegal states (e.g., `Observer + durability_eligible=true`) to be constructed anywhere (runtime, tests, WAL decode). The compiler cannot prevent this, and a bad row can be persisted and replayed.\n\nThis violates the durability contract: if an ineligible replica is marked eligible, `PeerAckTable` / `DurabilityCoordinator` can count the wrong replicas and report durability that never happened.\n\n**Impact**\n- False durability acknowledgements (safety violation).\n- Hard-to-debug divergence between roster policy and observed liveness.\n\n**Files**\n- `crates/beads-rs/src/daemon/wal/index.rs` (ReplicaLivenessRow definition + sqlite load/save)\n- `crates/beads-rs/src/daemon/wal/memory_index.rs`\n- `crates/beads-rs/src/daemon/repl/runtime.rs` (upsert)\n- `crates/beads-rs/src/daemon/repl/server.rs` / `manager.rs` (role/eligibility derivation)","design":"**Design**\nMake the illegal combinations unrepresentable by type:\n\nOption A (preferred):\n- Introduce a new type that encodes role + durability eligibility together.\n  - Example:\n    - `enum ReplicaDurabilityRole { Anchor { eligible: bool }, Peer { eligible: bool }, Observer }`\n  - Derive `durability_eligible()` from the enum; remove raw bool from public surfaces.\n- Replace `ReplicaLivenessRow { role: ReplicaRole, durability_eligible: bool }` with `ReplicaLivenessRow { role: ReplicaDurabilityRole }`.\n- Provide fallible conversion for decode: `impl TryFrom<(ReplicaRole, bool)> for ReplicaDurabilityRole`.\n  - Reject Observer+eligible at decode time (fail fast and surface corruption).\n\nOption B (acceptable):\n- Keep `ReplicaRole`, but replace bool with a newtype that enforces constraints:\n  - `struct DurabilityEligible(NonObserverRole)` where `NonObserverRole = Anchor | Peer`.\n  - `ReplicaLivenessRow` holds `role: ReplicaRole` and `eligibility: Option<DurabilityEligible>` where `None` implies ineligible and `Some` implies non-observer.\n\nEnsure the type exposes a single canonical encoding/decoding path so ordering and serialization are stable.\n\n**Ordering / invariants preserved**\n- Preserve deterministic ordering of `replica_liveness` rows (still keyed by `replica_id`).\n- Preserve on-disk schema: if stored as role + bool, encode from the new type; decoding remains stable but rejects illegal combos.","id":"bd-i0sq","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Replica liveness eligibility must be encoded in the type","type":"bug"}
{"_at":[1768679267687,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] Model checker uses production code paths or an automated sync mechanism that prevents drift.\n- [ ] Invariants (watermarks monotonicity, no event loss, replay idempotency, durability receipts) are checked against the real implementation.\n- [ ] CI/slow-test target runs the model (bounded) and fails on counterexamples with actionable traces.","closed_reason":"superseded by bd-i43y","created_at":[1768672361080,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nThe stateright model exists but is not validated against production invariants. We have no model-checked coverage for realtime edge cases, which limits confidence in protocol correctness.","design":"**Design**\n- Prefer running Stateright over production code paths: reuse core realtime types/logic directly (via shared modules/feature flags) so the model is not a hand-written fork.\n- If direct reuse is impossible, add an automated sync mechanism (e.g., codegen or compile-time structure tests) that fails on drift between model and production types/state transitions.\n- Invariants should be asserted against the actual implementation of event apply/WAL/replication state, not a simplified model.","id":"bd-lzhq","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Realtime: stateright model coverage","type":"bug"}
{"_at":[1768505186094,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] No string literals are used to represent gap rejection codes.\n- [ ] All gap rejections map to canonical ErrorCode values with details.\n- [ ] Tests cover the mapping for timeout/overflow cases.","closed_reason":"duplicate of bd-al7","created_at":[1768503796003,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nGapBuffer rejects use stringly-typed codes (gap_timeout, gap_buffer_overflow, etc) via IngestDecision::Reject { code: String } in src/daemon/repl/gap_buffer.rs. This bypasses ErrorCode/REALTIME_ERRORS, loses structured details, and makes it easy for codes to drift silently.\n\n**Files:** src/daemon/repl/gap_buffer.rs, src/daemon/repl/session.rs, src/core/error.rs","design":"**Design**\n- Introduce a GapReject/GAP error enum that carries ErrorCode plus typed details (e.g., OverloadedDetails or GapDetectedDetails).\n- Change IngestDecision::Reject to carry this typed error instead of a String.\n- Map the typed error to ErrorPayload in Session (or at the boundary) using canonical ErrorCode values.\n- Add tests asserting the payload codes/details for each rejection reason.","id":"bd-rjn","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Replace GapBuffer string codes with structured errors","type":"chore"}
