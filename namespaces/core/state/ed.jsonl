{"_at":[1768256192277,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768252077046,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nRecord header fields (origin_replica_id, origin_seq, event_time_ms, txn_id, client_request_id) are not validated against decoded EventBody bytes during replay or fsck. Corrupted headers can silently diverge while sha matches payload. REALTIME_PLAN.md 5.2 requires header consistency checks.\n\n**Design**\nDecode EventBody from Record.payload using core::decode_event_body (limits) in replay and fsck; compare fields with RecordHeader. On mismatch:\n- fsck: report corruption (new FsckEvidenceCode) and quarantine/repair per mode.\n- replay: return explicit WalReplayError (non-tail corruption).\nAdd tests with a record whose payload is valid but header is tampered; assert fsck reports mismatch and replay errors.\n\n**Acceptance**\n- [ ] Header/body mismatches are detected in replay and fsck.\n- [ ] Fsck report includes deterministic evidence code.\n- [ ] Tests cover header mismatch path; cargo test passes.\n\n**Files:** src/daemon/wal/replay.rs, src/daemon/wal/fsck.rs, src/daemon/wal/record.rs, tests/phase3_fsck.rs","id":"bd-796","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Validate WAL record header vs EventBody payload","type":"bug"}
{"_at":[1769577417122,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] `BeadSnapshotWireV1` and `BeadPatchWireV1` exist in `beads-core`, and all snapshot/patch JSON encoding uses them.\n- [ ] There is exactly one semantic validator for bead patches, and all mutation/event paths rely on it.\n- [ ] `crates/beads-rs/src/git/wire.rs` no longer defines a competing bead snapshot wire; it adapts to the canonical wire.\n- [ ] Checkpoint import/export uses the canonical snapshot wire for parsing/serialization.\n- [ ] Duplicate validators (ParsedBeadPatch/validate_wire_patch) are removed or reduced to input normalization only.\n- [ ] Unit tests cover roundtrip snapshot serialization and invalid patch rejection through the canonical validator.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769573131220,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nBead state is serialized and validated in multiple parallel shapes:\n- Git store wire in `crates/beads-rs/src/git/wire.rs`\n- Checkpoint/realtime wire in `crates/beads-core/src/wire_bead.rs`\n- Patch validation in `crates/beads-core/src/event.rs` (ValidatedBeadPatch)\n- Patch validation + parsing in `crates/beads-rs/src/daemon/mutation_engine.rs`\n- Surface patch shape in `crates/beads-surface/src/ops.rs`\n\nThe same invariants (workflow/claim coherence, required fields, ordering rules, dedup, etc.) are re-encoded in different representations and checked in different places. This is scatter + drift risk: anyone changing bead semantics has to chase multiple pipelines and keep them in sync.\n\n**Files:**\n- `crates/beads-rs/src/git/wire.rs`\n- `crates/beads-core/src/wire_bead.rs`\n- `crates/beads-core/src/event.rs`\n- `crates/beads-rs/src/daemon/mutation_engine.rs`\n- `crates/beads-surface/src/ops.rs`","design":"**Design**\nCreate one canonical bead snapshot wire and one canonical bead patch wire in `beads-core`, plus a single validator that yields a validated patch type. Then route all serialization and mutation pipelines through those types.\n\nConcrete plan:\n1) Define `BeadSnapshotWireV1` and `BeadPatchWireV1` in `crates/beads-core/src/wire_bead.rs` (or a new `wire_bead_snapshot.rs`), covering all fields currently represented across git/checkpoint/event wires. These types must be the only JSON representation for full bead snapshots and patches.\n2) Move/centralize the patch semantics checks (workflow/claim coherence, created_at/created_by rules, etc.) into a single validator: `ValidatedBeadPatch::try_from(BeadPatchWireV1)` in `beads-core`.\n3) Update git store wire (`crates/beads-rs/src/git/wire.rs`) to serialize/deserialize via `BeadSnapshotWireV1` (eliminate its bespoke `WireBead` parsing where possible). Keep any legacy quirks as translation adapters local to that module.\n4) Update checkpoint import/export and realtime event encoding to use the same `BeadSnapshotWireV1`/`BeadPatchWireV1` types, so snapshots and patches share identical invariants.\n5) Update `beads-surface` and `beads-rs` mutation planning to construct `BeadPatchWireV1` directly, then validate once to get `ValidatedBeadPatch`.\n6) Delete or shrink duplicate validators (ParsedBeadPatch / validate_wire_patch), replacing them with a single \"parse then validate\" path.\n\n**Design Notes**\n- Keep backward-compatible parsing where needed (legacy git store, go schema), but make those adapters explicit and local so invariants do not leak.\n- If the git store wire requires sparse-stamp behavior, model that as a serializer choice on the canonical wire rather than a separate struct.\n- Add conversion helpers in core (e.g., `BeadSnapshotWireV1::from_view`) to keep usage uniform.","id":"bd-8yac","labels":{"cc":{"max":{}},"entries":{"architecture":[{"counter":13194328523806826908,"replica":"1383ed17-d2e0-2916-cd66-6d792c431666"}],"scatter":[{"counter":10558539594876570247,"replica":"1da33846-24fd-a0da-63b0-29024f61cf46"}],"tech-debt":[{"counter":1089507277148352589,"replica":"eac93ce2-ab49-35ae-89d1-f3b29d8cbf61"}]}},"notes":[{"at":[1769575908535,0],"author":"darin@darins-Mac-Studio-2.local","content":"Rendering stays in command files; do not move render logic out during this refactor.","id":"go-comment-bd-8yac-1"},{"at":[1769577417122,0],"author":"darin@darinsmcstudio2.lan","content":"Rendering stays in command files; do not move render logic out during this refactor.","id":"legacy-notes"}],"priority":1,"status":"closed","title":"Unify bead wire formats and patch validation","type":"chore"}
{"_at":[1769546140963,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] `WatermarkRow` cannot be constructed with invalid seq/head combinations.\n- [ ] DB load rejects invalid rows before they reach runtime logic.\n- [ ] All index users operate on typed watermarks (no raw seq/head pairs).\n- [ ] Tests cover row roundâ€‘trip and invalid row rejection.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769501232627,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWAL index `WatermarkRow` stores seqs and head hashes as independent fields (`applied_seq`, `applied_head_sha`, `durable_seq`, `durable_head_sha`). This makes illegal combinations representable (seq>0 with head=None; seq=0 with head=Some). The invariant is only enforced later (or not at all).\n\nKey refs:\n- `crates/beads-rs/src/daemon/wal/index.rs:210` (WatermarkRow)\n- `crates/beads-rs/src/daemon/wal/index.rs:821` (loading rows without invariant checks)\n\n**Impact**\nIndex can hold inconsistent watermarks, which can break replication and durability checks. Compiler cannot enforce the invariant.","design":"**Design (opinionated)**\nRepresent watermarks as typed `Watermark<K>` (or a `WireWatermark { seq, head }`) in the index row.\n\n- Replace the four raw fields with:\n```rust\nstruct WatermarkRow {\n  namespace: NamespaceId,\n  origin: ReplicaId,\n  applied: Watermark<Applied>,\n  durable: Watermark<Durable>,\n}\n```\n- DB decode builds `Watermark<Applied>`/`Watermark<Durable>` via `Watermark::new`, so invalid seq/head combos fail immediately.\n- DB encode decomposes the typed watermark into columns.\n\nThis enforces seq/head correctness at the type boundary.","id":"bd-ri7b","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Encode WAL index watermark invariants","type":"bug"}
{"_at":[1768727115197,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768723112513,0],"created_by":"darin@darinsmcstudio2.lan","description":"Task instructions reference beads_stateright_models/src/realtime_types_sketch.rs but file is missing in repo. Either add the type sketch file or update docs/instructions to point to the correct location.","id":"bd-xert","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Missing realtime_types_sketch.rs referenced in realtime workflow","type":"chore"}
{"_at":[1768622485660,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622485660,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nGo beads supports replies-to dependencies for threading messages/comments. This creates reply chains for inter-agent communication. beads-rs needs this for future messaging features.\n\n**How it works in Go beads**\n- Dependency type: `DepRepliesTo` (in internal/types/types.go)\n- Creates conversation threads\n- ThreadID field groups conversation edges for efficient queries\n- Typically paired with message/comment issue types\n- Non-blocking (doesn't affect ready work)\n\n**Design for Rust**\n1. Add `RepliesTo` variant to `DepKind` enum in src/core/domain.rs\n2. Mark it as non-DAG-enforcing (informational link)\n3. Add optional thread_id field to DepEdge metadata\n   - Groups conversation edges\n   - Enables \"get all replies in thread\" queries\n4. Consider future: reply chain rendering, thread navigation\n\n**Design considerations**\n- ThreadID generation: root message ID? UUID?\n- Should we validate reply targets exist?\n- Threading semantics: linear chain vs tree?\n  * Go: supports both (multiple replies to same message)\n- Display strategy: nest replies in bd show?\n\n**Design questions for human review**\n- Do we need this now or defer until messaging is built?\n  * Pro defer: no users yet, avoid speculative design\n  * Pro now: complete dep type parity with Go\n- Should replies-to enforce message/comment types?\n  * Or allow replying to any bead?\n- Thread query API: part of this bead or separate?\n\n**Files to study**\n- tmp/beads/internal/types/types.go - DepRepliesTo, ThreadID field\n- tmp/beads/cmd/bd/dep.go - how it's used (if at all)\n- Go beads messaging features (if implemented)\n\n**Acceptance**\n- [ ] RepliesTo added to DepKind enum\n- [ ] Optional thread_id metadata field defined\n- [ ] Non-blocking (doesn't affect ready work)\n- [ ] Serde support for thread_id\n- [ ] Cargo fmt, clippy, test pass","id":"bd-ze0x.33","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":6851366315712993401,"replica":"2e66163b-8b72-8892-a8a1-77839b5f1552"}]}},"priority":2,"status":"open","title":"Add replies-to dependency type for conversation threading","type":"feature"}
