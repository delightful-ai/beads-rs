{"_at":[1768453447510,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768448943321,1],"darin@book"],"claim":[[1768451898507,1],"darin@book"],"description":[[1768448943321,1],"darin@book"],"design":[[1768448943321,1],"darin@book"],"estimated_minutes":[[1768448943321,1],"darin@book"],"external_ref":[[1768448943321,1],"darin@book"],"labels":[[1768448943321,1],"darin@book"],"priority":[[1768448943321,1],"darin@book"],"source_repo":[[1768448943321,1],"darin@book"],"title":[[1768448943321,1],"darin@book"],"type":[[1768448943321,1],"darin@book"]},"acceptance_criteria":"- [ ] A contiguous batch (seq 1,2) in a single EVENTS message applies both events and emits no WANT.\n- [ ] Buffered deferred events are eventually forwarded once their prev is known (test covers).\n- [ ] Add regression test in src/daemon/repl/session.rs and/or gap_buffer.rs.\n\n**Files:** src/daemon/repl/session.rs, src/daemon/repl/gap_buffer.rs, src/core/event.rs","assignee":"darin@book","assignee_at":[1768451898507,1],"assignee_expires":1768455498507,"closed_at":[1768453447510,1],"closed_by":"darin@book","created_at":[1768448943321,1],"created_by":"darin@book","description":"**Problem**\nWhen an EVENTS message contains multiple contiguous events for the same (namespace, origin), only the first event is verified as contiguous. Subsequent events are verified with expected_prev=None and become Deferred, then buffered. The gap buffer never promotes deferred events after durable advances, so those events can remain stuck and trigger unnecessary WANTs even though we already received them.\n\n**Evidence**\n- src/daemon/repl/session.rs: handle_events() computes expected_prev via expected_prev_head() using the durable watermark snapshot (not updated per-frame).\n- src/core/event.rs: verify_event_frame() returns VerifiedEventAny::Deferred when expected_prev_head is None for seq>1.\n- src/daemon/repl/gap_buffer.rs: ingest_one() buffers deferred events and advance_durable_batch() does not re-check buffered deferred events.\n\n**Why this hurts**\nA peer that legitimately batches seq N and N+1 in a single EVENTS frame will cause seq N+1 to be buffered and never applied unless it is resent later. This can stall replication and produce spurious WANTs.","design":"**Design**\nOption A (preferred): Track per-(namespace, origin) last-seen head within the current EVENTS batch. Use that to compute expected_prev_head for later frames in the same batch so contiguous batches verify as Contiguous.\n\nOption B: Extend GapBuffer to promote deferred events when durable advances (e.g., add a flush_ready() that re-validates deferred prev against the new durable head). Call it after advance_durable_batch().\n\nWhichever approach, ensure events already in the batch are not re-requested via WANT.","id":"bd-8y9","labels":[],"priority":1,"status":"closed","title":"Replication ingest can stall on contiguous batches","type":"bug"}
{"_at":[1768471459759,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768448973468,1],"darin@book"],"claim":[[1768470798930,1],"darin@book"],"description":[[1768448973468,1],"darin@book"],"design":[[1768448973468,1],"darin@book"],"estimated_minutes":[[1768448973468,1],"darin@book"],"external_ref":[[1768448973468,1],"darin@book"],"labels":[[1768448973468,1],"darin@book"],"priority":[[1768448973468,1],"darin@book"],"source_repo":[[1768448973468,1],"darin@book"],"title":[[1768448973468,1],"darin@book"],"type":[[1768448973468,1],"darin@book"]},"acceptance_criteria":"- [ ] Opening wal.sqlite rejects symlinked files/dirs.\n- [ ] Opening wal/<namespace> rejects symlinked dirs.\n- [ ] Replay/fsck path traversal rejects symlinked wal dirs.\n- [ ] Tests cover rejection paths.\n\n**Files:** src/daemon/wal/index.rs, src/daemon/wal/segment.rs, src/daemon/wal/replay.rs, src/daemon/store_runtime.rs","assignee":"darin@book","assignee_at":[1768470798930,1],"assignee_expires":1768474398930,"closed_at":[1768471459759,1],"closed_by":"darin@book","created_at":[1768448973468,1],"created_by":"darin@book","description":"**Problem**\nFilesystem safety rules in REALTIME_PLAN require rejecting symlinks for wal.sqlite and wal/<namespace> directories. Current implementation only checks meta.json for symlinks; WAL/index paths can be symlinks, allowing writes outside store_dir.\n\n**Evidence**\n- src/daemon/wal/index.rs: SqliteWalIndex::open() creates/opens index/wal.sqlite with no symlink check.\n- src/daemon/wal/segment.rs: SegmentWriter::open() create_dir_all(wal/<namespace>) and create_segment() without rejecting symlinks.\n- src/daemon/wal/replay.rs: list_namespaces/list_segments iterate wal/ without symlink rejection.\n- REALTIME_PLAN ยง15.1 mandates symlink rejection for meta.json, index/wal.sqlite, and wal/<namespace>/.\n\n**Why this hurts**\nSymlinked WAL/index paths defeat store_dir confinement and can lead to writes outside the intended store, violating safety assumptions.","design":"**Design**\n1) Add a small helper (e.g., ensure_no_symlink(path)) and use it before opening wal.sqlite and before using wal/<namespace> paths.\n2) In SqliteWalIndex::open(), reject if wal.sqlite is a symlink (or its parent index dir is a symlink).\n3) In SegmentWriter::open()/create_segment(), reject if wal/<namespace> path is a symlink (or resolve symlink metadata).\n4) In replay_index (list_namespaces/list_segments), reject symlinked wal dirs with a clear error.\n5) Map errors to PathSymlinkRejected in IPC.\n\nAdd tests with tempdir + symlink that confirm rejection.","id":"bd-enq","labels":[],"priority":2,"status":"closed","title":"Symlink rejection missing for WAL/index paths","type":"bug"}
