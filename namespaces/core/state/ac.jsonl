{"_at":[1768489648317,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768488084764,0],"created_by":"darin@darinsmcstudio2.lan","description":"The global --actor flag is validated in cli/mod.rs but never used to set BD_ACTOR or populate MutationMeta.actor_id. Either wire it into daemon startup/env or remove flag.","id":"bd-cv8","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"cli/mod.rs: --actor flag validated but never applied","type":"bug"}
{"_at":[1769569161254,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] After handshake, inbound/outbound reader loops enforce the negotiated `max_frame_bytes`.\n- [ ] A peer sending frames larger than negotiated is rejected with `FrameTooLarge`.\n- [ ] The negotiated limit is produced by the handshake and required by the reader API (compile-time gating).\n- [ ] Tests cover: negotiated limit < local max; oversized frame rejected.\n- [ ] `cargo test` passes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769563141180,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWe construct `FrameReader` with `limits.max_frame_bytes` and never update it after handshake. This means we accept inbound frames larger than the negotiated `peer.max_frame_bytes` (as long as they are below the local max). That violates the handshake contract and makes the negotiated frame limit a lie.\n\nThis is an implicit invariant: code assumes the negotiated limit is enforced, but the type does not encode it and the reader keeps the pre-handshake limit forever.\n\n**Impact**\n- Protocol correctness: peers can send frames larger than agreed without being rejected.\n- Resource safety: negotiated limit is ignored, enabling larger-than-expected frames.\n- Hard-to-see bug because the limit looks enforced elsewhere (`SessionWire::frame_limit`), but only for *sending*.\n\n**Files**\n- `crates/beads-rs/src/daemon/repl/frame.rs` (FrameReader)\n- `crates/beads-rs/src/daemon/repl/manager.rs` (run_reader_loop outbound)\n- `crates/beads-rs/src/daemon/repl/server.rs` (run_reader_loop inbound)\n","design":"**Design (opinionated)**\nMake the negotiated frame limit a type boundary, not a runtime convention.\n\n1) Introduce typestated reader limits:\n```rust\nstruct Unnegotiated;\nstruct Negotiated { max_frame_bytes: usize }\nstruct FrameReader<R, L> { reader: R, limit: L }\n```\n- `FrameReader<R, Unnegotiated>` is only valid before handshake.\n- After handshake, transition to `FrameReader<R, Negotiated>` using the negotiated max.\n\n2) Split reader loop helpers:\n- `run_reader_loop_unnegotiated(reader, ...)` for the initial HELLO.\n- `run_reader_loop_negotiated(reader, negotiated_max, ...)` for steady-state.\n\n3) Alternatively, if typestate feels heavy, add a `FrameLimit` newtype and make `run_reader_loop` require it; only the handshake produces a `FrameLimit` for use.\n\n4) Enforce `min(local_max, peer_max)` as the negotiated limit; reject larger frames with `FrameTooLarge`.\n\nThis removes scatter: the negotiated limit is enforced where frames are read, not assumed.","id":"bd-rzh4","labels":{"cc":{"max":{}},"entries":{}},"notes":[{"at":[1769569095172,0],"author":"darin@darins-Mac-Studio-2.local","content":"Implemented via FrameLimitState (Arc<AtomicUsize>) with NegotiatedFrameLimit newtype; reader loops apply negotiated limit after handshake so FrameReader enforces it per frame.","id":"go-comment-bd-rzh4-1"},{"at":[1769569161254,0],"author":"darin@darinsmcstudio2.lan","content":"Implemented via FrameLimitState (Arc<AtomicUsize>) with NegotiatedFrameLimit newtype; reader loops apply negotiated limit after handshake so FrameReader enforces it per frame.","id":"legacy-notes"}],"priority":1,"status":"closed","title":"Repl FrameReader must enforce negotiated max_frame_bytes","type":"bug"}
