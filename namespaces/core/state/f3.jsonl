{"_at":[1768461133331,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768454392707,1],"darin@book"],"claim":[[1768460332061,1],"darin@book"],"description":[[1768454392707,1],"darin@book"],"design":[[1768454392707,1],"darin@book"],"estimated_minutes":[[1768454392707,1],"darin@book"],"external_ref":[[1768454392707,1],"darin@book"],"labels":[[1768454392707,1],"darin@book"],"priority":[[1768454392707,1],"darin@book"],"source_repo":[[1768454392707,1],"darin@book"],"title":[[1768454392707,1],"darin@book"],"type":[[1768454392707,1],"darin@book"]},"assignee":"darin@book","assignee_at":[1768460332061,1],"assignee_expires":1768463932061,"closed_at":[1768461133331,1],"closed_by":"darin@book","created_at":[1768454392707,1],"created_by":"darin@book","description":"**Problem**\nREALTIME_PLAN §9.3 requires EVENTS batches be constructed round‑robin across eligible (namespace, origin_replica_id) to avoid starvation. Current `handle_want` in `src/daemon/repl/manager.rs` and `server.rs` builds batches by iterating hot‑cache then WAL ranges in map order; there is no round‑robin scheduling.\n\n**Design**\n- Implement a round‑robin iterator over keys `(namespace, origin)` when building EVENTS frames.\n- Preserve per‑origin contiguity (do not interleave out of order within a key).\n- Add tests that show fairness across multiple namespaces/origins under batch size limits.\n\n**Acceptance**\n- [ ] EVENTS batching uses round‑robin across (namespace, origin) when filling a batch.\n- [ ] Per‑origin sequence ordering is preserved.\n- [ ] Tests validate fairness and contiguity.\n\n**Files:** src/daemon/repl/manager.rs, src/daemon/repl/server.rs","id":"bd-3m5.103","labels":[],"priority":2,"status":"closed","title":"Replication EVENTS batching is not round‑robin across (namespace, origin)","type":"bug"}
{"_at":[1766127067042,0],"_by":"darin@book","_v":{"acceptance_criteria":[[1766127044862,0],"darin@book"],"claim":[[1766127044862,0],"darin@book"],"description":[[1766127044862,0],"darin@book"],"design":[[1766127044862,0],"darin@book"],"estimated_minutes":[[1766127044862,0],"darin@book"],"external_ref":[[1766127044862,0],"darin@book"],"labels":[[1766127044862,0],"darin@book"],"priority":[[1766127044862,0],"darin@book"],"source_repo":[[1766127044862,0],"darin@book"],"title":[[1766127044862,0],"darin@book"],"type":[[1766127044862,0],"darin@book"]},"closed_at":[1766127067042,0],"closed_by":"darin@book","closed_reason":"test cleanup","created_at":[1766127044862,0],"created_by":"darin@book","description":"","id":"bd-70v","labels":[],"priority":3,"status":"closed","title":"Test epic for show","type":"epic"}
{"_at":[1765772953094,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1765744931340,0],"darin@book"],"claim":[[1765772510857,0],"darin@dusk"],"description":[[1765744931340,0],"darin@book"],"design":[[1765744931340,0],"darin@book"],"estimated_minutes":[[1765744931340,0],"darin@book"],"external_ref":[[1765744931340,0],"darin@book"],"labels":[[1765744931340,0],"darin@book"],"priority":[[1765744931340,0],"darin@book"],"source_repo":[[1765744931340,0],"darin@book"],"title":[[1765744931340,0],"darin@book"],"type":[[1765744931340,0],"darin@book"]},"assignee":"darin@dusk","assignee_at":[1765772510857,0],"assignee_expires":1765776110857,"closed_at":[1765772953094,0],"closed_by":"darin@dusk","created_at":[1765744931340,0],"created_by":"darin@book","description":"**Problem**\n`src/daemon/scheduler.rs` spawns a new thread on every schedule call, and reschedules do not cancel old sleepers. Under bursty ops, this devolves into \"death by a thousand sleeping threads\".\n\n**Design**\nSingle timer mechanism:\n- Keep a min-heap of `(deadline, remote)`\n- State loop computes next deadline and uses `crossbeam::channel::after(next - now)` (or one dedicated timer thread)\n- When rescheduling, update the heap entry (or push and ignore stale entries by checking current deadline in a map)\n\nThis makes the daemon \"boring\" which is good.\n\n**Acceptance**\n- [ ] At most 1 timer thread (or zero with channel-based approach)\n- [ ] Rapid reschedules dont accumulate sleeping threads\n- [ ] Stress test: 1000 rapid mutations, verify thread count stays bounded\n- [ ] Existing sync behavior preserved (debounce still works)\n\n**Files:** src/daemon/scheduler.rs","id":"bd-w36","labels":[],"priority":0,"status":"closed","title":"Scheduler spawns unbounded threads on reschedule (threadpocalypse)","type":"bug"}
