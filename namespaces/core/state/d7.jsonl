{"_at":[1768524029898,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Replication core logic no longer returns ErrorPayload directly.\n- [ ] Boundary adapters produce ErrorPayload from ReplError.\n- [ ] Tests cover ReplError -> ErrorPayload mapping.","assignee":"darin@book","created_at":[1768503848137,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nReplication internals use ErrorPayload as their primary error type (SessionResult = Result<T, Box<ErrorPayload>> in repl/session.rs, and ReplSessionStore/ingest paths). This pushes boundary formatting into core logic, loses structured error intent, and conflicts with error_design guidance (use domain errors internally, map at boundaries).\n\n**Files:** src/daemon/repl/session.rs, src/daemon/repl/runtime.rs, src/daemon/repl/manager.rs, src/daemon/repl/server.rs","design":"**Design**\n- Introduce a ReplError enum capturing internal error cases with structured fields.\n- Convert ReplError -> ErrorPayload only at the protocol boundary (SessionAction::Close / outbound ERROR frames, IPC responses).\n- Update SessionStore trait and ReplIngestRequest to use ReplError instead of Box<ErrorPayload>.\n- Add conversion tests to ensure payload formatting stays stable.","id":"bd-2oms","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Use typed internal errors in replication (avoid ErrorPayload in core logic)","type":"chore"}
{"_at":[1768183528235,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] NamespaceId validation tests cover valid and invalid inputs.\n- [ ] StoreState can create and return the default core namespace without side effects.\n- [ ] NamespacePolicy defaults match the plan.\n- [ ] No daemon behavior change yet; this is core types only.","assignee":"darin@darinsmacstudio.lan","created_at":[1768177719868,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nThe core state is currently single namespace. Namespace boundaries are implicit (\"core\") and there is no NamespaceId or namespace policy type, which makes cross namespace bugs easy and prevents typestate around per namespace invariants.\n\n**Context**\n- REALTIME_PLAN.md 0.3 (StoreState choice), 0.4 (namespace policy representation), 2.2 (Namespaces)\n- Stateright model: beads_stateright_models/src/realtime_types_sketch.rs (section 3 Namespaces)\n\n**Files:** src/core/namespace.rs (new), src/core/store_state.rs (new) or src/core/state.rs, src/core/mod.rs, src/lib.rs, src/config.rs (policy parsing hook)","design":"**Design**\n- Add NamespaceId newtype with validation [a-z][a-z0-9_]{0,31}, matching the stateright model; include as_str and display.\n- Add NamespacePolicy and CheckpointGroup structs with the fields and defaults from REALTIME_PLAN.md 2.2.\n- Introduce StoreState as BTreeMap<NamespaceId, CanonicalState> with helpers: get, get_mut, ensure_namespace, and a constant default NamespaceId::core().\n- Ensure callers must select a namespace before accessing a CanonicalState (no implicit global operations), so cross namespace operations require explicit opt in.\n- Re-export NamespaceId, NamespacePolicy, CheckpointGroup, StoreState in src/core/mod.rs and src/lib.rs.","id":"bd-3m5.2","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 1: Namespaces + StoreState","type":"task"}
{"_at":[1768375342617,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768178842509,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nExisting users have data in refs/heads/beads/store. Must import into new checkpoint format.\n\n**Context**\n- REALTIME_PLAN.md ยง17.2 (legacy Git ref), ยง17.3 (identity migration)\n\n**Design**\n- On store open: check for refs/heads/beads/store\n- Import into StoreState[\"core\"] namespace using legacy wire format\n- Leave checkpoint export to the scheduler (refs/beads/<store_id>/<group>) in bd-3m5.22\n- Mirror legacy ref for one release if needed\n- Keep legacy wire format reader for migration only\n\n**Acceptance**\n- [ ] Migration imports refs/heads/beads/store into StoreState[\"core\"].\n- [ ] Legacy ref is treated as read-only during migration.\n- [ ] Identity persisted locally (URL changes don't break it).\n- [ ] Tests verify legacy import\n\n**Files:** src/git/sync.rs, src/git/wire.rs, src/daemon/migration.rs, src/git/checkpoint/import.rs","id":"bd-3m5.39","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 6: Legacy Git ref migration import","type":"task"}
{"_at":[1769771803087,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769287943804,0],"created_by":"darin@darinsmcstudio2.lan","description":"","id":"bd-bfbr","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Add replication-ready barrier for tailnet tests","type":"chore"}
{"_at":[1769560639246,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769203763780,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Segment:** crdt/6-apply-collision (bd-3zoj.7)\n**Files:** src/core/apply.rs, src/core/state.rs, tests/integration/core/apply.rs\n**RepoPrompt chat:** crdt-collision-review-B904F2\n\n---\n\n## Summary (what this test change accomplishes)\n\nThis patch updates the integration test `note_collision_is_deterministic` to match the **D4 note collision winner rule** by ensuring the colliding note has the **same `(at, author)`** as the existing one, so the test actually exercises the **`sha256(content)` tie-breaker**. It also removes now-unused imports and fixes ownership by cloning `bead_id` when building the `NoteAppend`.\n\nNet effect: the test now correctly validates the \"content-hash tiebreak\" portion of deterministic note collision handling.\n\n---\n\n## Critical issues / gaps to address\n\n### 1) Integration tests still don't cover most of the collision + totality surface area\nGiven the scope of \"Apply Collision Handling\", the integration suite still lacks coverage for:\n\n- **Bead creation collisions**\n  - Two `BeadUpsert`s with the same `BeadId` but different `created` stamps\n  - Deterministic winner selection + insertion of a **lineage collision tombstone**\n  - Order-independence (`apply(A); apply(B)` vs `apply(B); apply(A)`)\n  - Suppression of subsequent ops for the losing lineage\n\n- **OR-Set dot collisions (labels + deps)**\n  - Same `Dot` used with different values; winner should be deterministic (value lexicographic, then `sha256(dot||value)`)\n  - Order-independence of applying the competing adds\n  - \"stamp updates only on real membership change\" behavior around collisions\n\n- **Orphan totality rules**\n  - `LabelAdd/Remove`, `DepAdd/Remove`, and `NoteAppend` on **missing beads** must not error\n  - Orphans should become visible after later bead creation (queries hide until bead exists)\n\nRight now, the integration file only covers: idempotency, one note collision tiebreak, and LWW ordering.\n\n### 2) Merge-path determinism remains a risk (not tested here)\nEven though this diff only touches tests, it's worth calling out: the merge side must align with apply for D4 to be \"done\".\n\n- `CanonicalState::join` currently **keeps the left bead** on `Bead::join` collision while collecting errors (non-commutative in the presence of collisions).\n- `NoteStore::join` is left-biased for same `(bead_id, note_id)`.\n\nIf collisions can exist in inputs to `join()` (e.g., from older snapshots/checkpoints, manual state construction, or partial replication paths), this violates the \"deterministic everywhere\" goal. There are no integration tests that would catch this divergence.\n\n---\n\n## Minor improvements (quality / robustness)\n\n- In `note_collision_is_deterministic`, consider asserting the intended preconditions explicitly to prevent fixture drift from accidentally changing what the test exercises:\n  - `assert_eq\\!(stored.at, expected_at)` isn't possible via `notes_for()` refs unless you also pull `note.at` and `note.author` from both versions, but you can at least assert the incoming `note.at/author` match the base fixture's values before applying.\n\n- The expected-winner computation could mirror the spec tuple ordering even though this test currently pins `(at, author)` equal. That would make the test self-documenting and resilient if `sample_note()` changes.\n\n---\n\n## What's done particularly well\n\n- **Intentionality:** Switching from a hand-constructed `WireNoteV1` (with different `at/author`) to `sample_note(2, 1)` makes it clear the test is about the **hash tie-break**, not timestamp/author precedence.\n- **Cleanliness:** Removing `WireNoteV1`/`WireStamp` imports and fixing the `bead_id` move with `bead_id.clone()` keeps the test correct and idiomatic.\n\n---\n\n## Actionable next steps\n\n1. **Add integration tests for bead ID collisions**:\n   - Apply two conflicting creations in both orders; assert same winner + lineage tombstone behavior.\n2. **Add integration tests for OR-Set dot collisions** (labels + deps):\n   - Same `Dot`, different value; ensure deterministic resolution + order-independence.\n3. **Add integration tests for orphan ops**:\n   - Apply label/dep/note ops before bead exists; ensure no error and visibility after bead creation.\n4. **Add tests around \"stamp updates only on real membership change\"**:\n   - Add a second dot for the same label/dep value (membership unchanged) and assert stamp/`updated_stamp` doesn't advance.\n5. (If D4 is meant to include merge right now) **Add merge/join collision tests** or update merge to apply the same collision comparators as apply.","id":"bd-ogvs.6","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Segment 6: Apply Collision Handling review","type":"task"}
