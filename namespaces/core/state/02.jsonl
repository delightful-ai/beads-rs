{"_at":[1768687393115,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] `beads-rs` exposes a `model-testing` (or similar) feature with a `src/model/*` harness of production-backed adapters.\n- [ ] `beads_stateright_models` depends on the main crate via path dep and compiles with `feature = model-testing`.\n- [ ] A drift-guard module in the models crate imports all production APIs used by models and fails compilation on signature changes.\n- [ ] Documented command to compile models in CI/slow-tests.","assignee":"darin@book","created_at":[1768680748707,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nStateright models are isolated in `beads_stateright_models` with toy types and custom logic. There is no compile-time guarantee that models stay in sync with production, and no shared harness to reuse production code paths.\n\n**Context**\n- Prod logic to reuse: `src/core/event.rs`, `src/core/watermark.rs`, `src/core/apply.rs`, `src/daemon/repl/gap_buffer.rs`, `src/daemon/repl/peer_acks.rs`, `src/daemon/durability_coordinator.rs`, `src/daemon/wal/*`, `src/test_harness/mod.rs`\n- Stateright actor system + network semantics: `~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/stateright-0.31.0/src/actor.rs`, `src/actor/model.rs`, `src/actor/network.rs`\n\n**Goal**\nCreate a minimal production-backed modeling harness and a drift guard so any prod change breaks model compilation.","design":"**Design**\n1) Add a feature-gated modeling harness in the main crate (e.g. `feature = \"model-testing\"`).\n   - New module `src/model/` that exposes only *pure* adapters used by Stateright models.\n   - APIs should wrap production functions, not re-implement logic.\n   - Example helpers:\n     - `model::event_factory` → build canonical `EventBody` + `EventFrameV1` using `encode_event_body_canonical`.\n     - `model::repl_ingest` → thin wrappers around `verify_event_frame`, `GapBufferByNsOrigin`, `Watermark` helpers.\n     - `model::durability` → wrapper around `PeerAckTable` + `DurabilityCoordinator::poll_replicated`.\n     - `model::state_digest` → hash/summary of `CanonicalState` (if needed for model state hashability).\n2) Update `beads_stateright_models/Cargo.toml` to depend on the main crate via a path dep with `default-features = false` + `features = [\"model-testing\"]`.\n3) Add a compile-time drift guard in `beads_stateright_models` (a small module that imports all production types/functions referenced by models). If any signature changes, models should fail to compile.\n4) Add a CI/slow-tests command to compile the models crate (e.g. `cargo check -p beads_stateright_models`).\n5) Document the no-drift rule in `beads_stateright_models/README.md`.\n\n**Notes**\nKeep the harness tiny and feature-gated so normal builds don’t pull daemon deps.","id":"bd-0863","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Stateright foundation: production harness + drift guard","type":"task"}
{"_at":[1768683234434,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] `repl_core_machine` uses ActorModel and Stateright network semantics (no manual action scheduling).\n- [ ] All ingest decisions call production functions; no copy of gap/contiguity logic remains.\n- [ ] Model properties cover: no-gap ACK, monotonicity, equivocation hard-close, idempotence.\n- [ ] Model runs with at least one lossy/duplicating network setting and one ordered setting.","assignee":"darin@book","created_at":[1768680764190,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`repl_core_machine` is a hand-written state machine that bypasses Stateright’s actor/network semantics and reimplements contiguity/gap/ACK logic. It doesn’t use production code paths.\n\n**Goal**\nCreate a production-backed replication-core model using Stateright’s ActorModel. The actor logic should call real Beads ingest functions and only model nondeterministic delivery via Stateright’s network.","design":"**Design**\n1) Replace `beads_stateright_models/examples/repl_core_machine.rs` with an ActorModel-based model.\n2) Define a `ReplActor` that:\n   - On `on_msg`, decodes a `ReplMessage::Events` (or a simplified `ReplMsg` used in the model) and uses production `verify_event_frame` + `GapBufferByNsOrigin` + `Watermark` updates to ingest.\n   - Uses production `IngestDecision` semantics (buffer, forward, reject).\n   - Tracks applied/durable watermarks via production `Watermark` types.\n3) Use Stateright network semantics instead of custom action scheduling:\n   - `Network::UnorderedDuplicating` for worst-case correctness.\n   - Optional `Network::Ordered` for quick sanity checks.\n4) Use `record_msg_in`/`record_msg_out` to collect message history for invariants.\n5) Keep model state hashable by storing summaries (watermarks, counts, digest of applied event ids).\n\n**References**\n- Stateright ActorModel + network semantics:\n  - `~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/stateright-0.31.0/src/actor.rs`\n  - `~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/stateright-0.31.0/src/actor/model.rs`\n  - `~/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/stateright-0.31.0/src/actor/network.rs`\n- Beads prod ingest logic:\n  - `src/core/event.rs` (`verify_event_frame`)\n  - `src/daemon/repl/gap_buffer.rs` (`GapBufferByNsOrigin`, `IngestDecision`)\n  - `src/core/watermark.rs` (watermark invariants)","id":"bd-cfqx","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Stateright repl core via ActorModel + production ingest","type":"task"}
{"_at":[1768454809145,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Outbound payloads never exceed session.peer().max_frame_bytes.\n- [ ] send_events batches respect the peer frame limit (not just local limits).\n- [ ] Tests cover a peer with smaller max_frame_bytes.\n\n**Files:** src/daemon/repl/session.rs, src/daemon/repl/manager.rs, src/daemon/repl/server.rs","created_at":[1768449027537,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nHandshake negotiates an effective max_frame_bytes, but outbound writers continue using the local limit. This can emit frames larger than the peer accepts.\n\n**Evidence**\n- src/daemon/repl/session.rs: SessionPeer.max_frame_bytes is set to min(local, peer).\n- src/daemon/repl/manager.rs and src/daemon/repl/server.rs: FrameWriter is created once with limits.max_frame_bytes (local) and never updated after handshake.\n- send_payload/send_events do not clamp payload size to session.peer().max_frame_bytes.\n\n**Why this hurts**\nPeers with smaller frame limits will reject frames or disconnect even though we negotiated a smaller effective limit.","design":"**Design**\nOption A: Re-create FrameWriter after handshake with max_frame_bytes = peer.max_frame_bytes, and use it for all subsequent sends.\nOption B: Keep FrameWriter but add a size check in send_payload/send_events that enforces the peer limit (clamp batches accordingly, return FrameTooLarge if exceeded).\n\nEither way, ensure events and error payloads respect the negotiated max.","id":"bd-gkz","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Replication ignores negotiated max_frame_bytes","type":"bug"}
{"_at":[1768176637617,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","closed_reason":"fixed","created_at":[1768173802780,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`session_coordinator_boundary` model reports a counterexample for the property \"pending ingest starts at next expected\" when running `cargo run --example session_coordinator_boundary -- check`. This indicates either the property is too strict for v0.5 semantics (buffered/out-of-order ingest) or the model logic is wrong.\n\n**Design**\nRe-run the model and capture the counterexample path. Decide whether the property should be relaxed (e.g., allow pending ingest to start earlier) or the model should be fixed to align with v0.5 gap buffering/prev deferral rules. Update the property or ingest logic accordingly and rerun the model to confirm no counterexample.\n\n**Acceptance**\n- [ ] Reproduce the counterexample path from the model output.\n- [ ] Decide whether the property or model logic is wrong and update accordingly.\n- [ ] `cargo run --example session_coordinator_boundary -- check` completes with no counterexample for that property.\n\n**Files:** `beads_stateright_models/examples/session_coordinator_boundary.rs`","id":"bd-heh","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"session_coordinator_boundary model hits counterexample for pending ingest property","type":"bug"}
{"_at":[1770590559798,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769815030760,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIntegration tests that spawn daemons (e.g., `test_crash_recovery_replays_wal`, `test_sync_command`) leave orphaned daemon processes when tests fail or are interrupted. These orphans hold sockets/locks, causing subsequent test runs to hang indefinitely.\n\nObserved: Tests hung for 4+ hours locally. Found 3 stale `bd daemon run` processes after killing the test harness.\n\n**Files:**\n- `crates/beads-rs/tests/integration/cli/critical_path.rs`\n- `crates/beads-rs/tests/integration/daemon/crash_recovery.rs`\n- Test fixtures that spawn daemons\n\n**Design**\nOptions:\n1. Add cleanup hooks to test fixtures that kill daemon processes on drop (even on panic)\n2. Use process groups so killing the test process kills children\n3. Add per-test timeouts that forcibly clean up\n\n**Acceptance**\n- [ ] Tests that spawn daemons clean up on success, failure, and panic\n- [ ] No orphaned daemon processes after test run\n- [ ] Local test runs don't hang indefinitely","id":"bd-o7ee","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Integration tests don't kill daemon processes on failure/timeout - causes hangs","type":"bug"}
