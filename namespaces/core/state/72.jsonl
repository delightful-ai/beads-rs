{"_at":[1769401181588,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `cargo check` passes on workspace\n- [ ] All 5 new crates listed in workspace.members\n- [ ] workspace.package.version = \"0.2.0-alpha\"\n- [ ] All crates use version.workspace = true\n- [ ] env!(\"CARGO_PKG_VERSION\") returns same value in all crates","created_at":[1769398685959,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nNeed workspace structure before extracting any crates.\n\n**Changes**\n1. Update `/Cargo.toml` to add workspace members:\n   - crates/beads-macros\n   - crates/beads-core\n   - crates/beads-api\n   - crates/beads-surface\n\n2. Add workspace versioning at `0.2.0-alpha`:\n   ```toml\n   [workspace.package]\n   version = \"0.2.0-alpha\"\n   ```\n\n3. Create stub crates with minimal Cargo.toml and empty lib.rs:\n   - `crates/beads-macros/Cargo.toml` + `src/lib.rs`\n   - `crates/beads-core/Cargo.toml` + `src/lib.rs`\n   - `crates/beads-api/Cargo.toml` + `src/lib.rs`\n   - `crates/beads-surface/Cargo.toml` + `src/lib.rs`\n\n4. Set `version.workspace = true` in ALL crates (including beads-rs)\n\n**Files**\n- /Cargo.toml (workspace)\n- crates/beads-macros/Cargo.toml + src/lib.rs (new)\n- crates/beads-core/Cargo.toml + src/lib.rs (new)\n- crates/beads-api/Cargo.toml + src/lib.rs (new)\n- crates/beads-surface/Cargo.toml + src/lib.rs (new)\n- crates/beads-rs/Cargo.toml (update version)","id":"bd-14fs.1","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 0: Workspace scaffolding and versioning","type":"task"}
{"_at":[1768512153800,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] It is impossible to represent seq>0 with unknown head in the durable/applied watermarks used for contiguity.\n- [ ] Gap buffer/drain paths no longer need PrevUnknown runtime checks for durable head.\n- [ ] Tests cover head-known enforcement and any compatibility behavior.","assignee":"darin@book","created_at":[1768503815996,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWatermark allows HeadStatus::Unknown for seq>0 (core/watermark.rs). Plan §0.12 says head sha must be known for seq>0. Today this invariant is enforced ad hoc (gap_buffer drain returns PrevUnknown), which is brittle and forces runtime checks across the replication path.\n\n**Files:** src/core/watermark.rs, src/daemon/store_runtime.rs, src/daemon/repl/session.rs, src/daemon/repl/gap_buffer.rs, src/daemon/repl/runtime.rs","design":"**Design**\n- Introduce a head-known watermark type (e.g., Watermark<K, HeadKnown>) or split Watermark into Known/Maybe variants.\n- Restrict contiguity-critical APIs (advance_contiguous, gap buffer drain) to require head-known watermarks.\n- Decide how to handle peers that omit head hashes: either reject at protocol boundary or store them in a separate \"unknown head\" map until upgraded.\n- Update load_watermarks to reject/flag seq>0 without head unless in a compatibility mode.","id":"bd-9qv0","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Make head-knownness explicit in watermarks","type":"chore"}
{"_at":[1769542157898,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] All handshake/streaming operations are type‑gated (cannot compile in the wrong phase/role).\n- [ ] `session.peer()`/`negotiated_max_frame_bytes()` are only available after handshake.\n- [ ] The repl loops no longer track `streaming` or `accepted_set` separately; they derive from the session type/state.\n- [ ] It is impossible to send events or hot‑cache frames unless the session is in Streaming.\n- [ ] Tests cover legal transitions and ensure illegal transitions are unrepresentable (compile‑fail or typestate tests).","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769501194082,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nThe replication session state machine is enforced by runtime checks and shadow state outside the session. The compiler cannot prevent illegal transitions or misuse.\n\nSpecific compiler‑blind spots:\n- Session phase/role gating is runtime only (`begin_handshake`, `resend_handshake`, `handle_message`). A wrong call sequence compiles and just returns None/error.\n- Both inbound and outbound loops track `streaming` as a separate bool (and `accepted_set` out‑of‑band). Once set, it never goes false even if the session transitions to Draining/Closed. This allows sending events/hot‑cache in invalid phases without compile‑time or runtime guardrails.\n- Code that depends on negotiated peer info uses `session.peer()` at runtime and falls back to config when missing; this is a smell that the type system doesn’t model “handshake completed” as a state.\n\nKey refs:\n- `crates/beads-rs/src/daemon/repl/session.rs:226` (handshake API), `:251` (message handling)\n- `crates/beads-rs/src/daemon/repl/manager.rs:414` / `:528` (shadow `streaming` + `accepted_set`)\n- `crates/beads-rs/src/daemon/repl/server.rs:484` / `:596` (same issue inbound)\n\n**Impact**\nA single refactor or new feature can accidentally send events before handshake or after draining/close. These bugs will compile and only appear at runtime under load. This is correctness‑critical for repl.","design":"**Design (opinionated)**\nMake the session phase/role a *type boundary* and collapse shadow state into the session type.\n\n1) Introduce typestated session:\n```rust\nstruct Session<R, P> { /* fields */ }\n// R: Inbound | Outbound, P: Connecting | Handshaking | Streaming | Draining | Closed\n```\n- Each phase exposes only valid operations.\n- `begin_handshake(self) -> (Session<Outbound, Handshaking>, SessionAction)`\n- `handle_hello(self, ...) -> Session<Inbound, Streaming>` etc.\n\n2) Encode “peer known” in the type:\n- Only `Session<*, Streaming>` (or `StreamingSession` wrapper) exposes `peer()` and `negotiated_max_frame_bytes()`.\n- Remove fallbacks on config when peer is None; make it impossible to call those methods pre‑handshake.\n\n3) Remove shadow `streaming` + `accepted_set`:\n- The loop should match on the session typestate.\n- `accepted_set` is derived from `StreamingSession`’s peer data, not a separately mutated local variable.\n- Event send/hot‑cache methods accept `&StreamingSession` only.\n\n4) Phase transitions are explicit:\n- `SessionAction` can include a typed next‑state or return `(Session<NewState>, Vec<Action>)` to make transitions explicit and compiler‑checked.\n\nThis turns invalid phase usage into compile‑time errors.","id":"bd-mjpe","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Repl session typestate + streaming gating","type":"bug"}
