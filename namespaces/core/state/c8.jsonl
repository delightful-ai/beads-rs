{"_at":[1769220341326,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Unit/integration test: two bead creations with same id in different orders yield same winner + lineage tombstone.\\n- [ ] Unit test: NoteStore::join resolves collisions deterministically, order-independent.\\n- [ ] Property test: join is commutative for states with collisions.","assignee":"darin@book","created_at":[1769209801424,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\nCanonicalState::join and NoteStore::join are left-biased for collisions, so merges can be non-commutative when collisions exist. This violates the D4 deterministic convergence goal.\\n\\n**Files**: src/core/state.rs, src/core/bead.rs, src/core/apply.rs, tests/integration/core/apply.rs","design":"**Design**\\nImplement collision resolution in join using the same comparator as apply:\\n- Bead collision winner: (created_stamp, content_hash) per CRDT_OVERHAUL.md. Insert lineage tombstone for loser.\\n- Note collision winner: (note.at, note.author, sha256(content)).\\nUpdate NoteStore::join to choose winner deterministically, not left-biased.\\nEnsure join is commutative and idempotent even with collisions in inputs.","id":"bd-qz97.11","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Deterministic merge for bead/note collisions in CanonicalState::join","type":"bug"}
{"_at":[1769578536087,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"Acceptance\n- Parsing files with duplicates or out-of-order entries fails with a specific WireError.\n- Roundtrip tests verify canonical ordering and strict parsing.\n- Existing valid stores continue to parse without changes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769563918176,0],"created_by":"darin@darinsmcstudio2.lan","description":"Problem\n- wire::parse_state_full and friends accept any order and silently overwrite duplicate IDs (state) or duplicate dep keys.\n- That means corrupted or hand-edited store files can silently drop data depending on line order.\n- The canonical ordering invariants (sorted by BeadId / TombstoneKey / DepKey / NoteId) are not enforced at the parse boundary.\n\nImpact\n- Data loss can go unnoticed.\n- Violates parse-don't-validate and the \"ordering is a stability invariant\" we rely on for deterministic diffs.\n","design":"Design\n- Add a canonical JSONL parser for the git store that enforces strictly increasing order and uniqueness per file.\n  - state.jsonl: BeadId strictly increasing, no duplicates.\n  - tombstones.jsonl: BeadId (or TombstoneKey) strictly increasing, no duplicates.\n  - notes.jsonl: (bead_id, note_id) strictly increasing, no duplicates.\n  - deps.jsonl: DepKey entries strictly increasing, no duplicates.\n- Return WireError::InvalidValue with file + line context on violations.\n- Keep serialization order exactly matching these rules so roundtrip is deterministic.\n\nScatter fit\n- Enforce ordering in one parser per file type; eliminate implicit reliance on serialize_* ordering.\n\nFiles\n- crates/beads-rs/src/git/wire.rs\n- crates/beads-rs/src/git/sync.rs (error reporting context)","id":"bd-t835","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"git store JSONL: enforce canonical ordering + uniqueness","type":"bug"}
