{"_at":[1769402699106,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `cargo check -p beads-core` passes (core builds in isolation)\n- [ ] `cargo check -p beads-rs` passes\n- [ ] beads-core has ZERO dependencies on beads-rs modules\n- [ ] `beads_rs::core::BeadId` still resolves\n- [ ] All tests pass","created_at":[1769398695771,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`crates/beads-rs/src/core/**` needs to become standalone `beads-core` crate. Currently core has dependencies on:\n- `crate::error::{Effect, Transience}` (must move into core)\n- Tests in `core/state.rs` call `crate::git::wire::serialize_*` (must move tests out)\n\nNote: enum_str! macro extraction is handled separately in bd-14fs.11.\n\n**Changes**\n\n1. **Move Effect + Transience into beads-core**:\n   - Define `beads_core::Effect` and `beads_core::Transience` (in `core/effect.rs` or `core/error.rs`)\n   - Update `core/error.rs` to use local types instead of `crate::error::{Effect, Transience}`\n   - In beads-rs: `pub use beads_core::{Effect, Transience};`\n   - Update `crates/beads-rs/src/error.rs` to use `beads_core::{Effect, Transience}`\n\n2. **Move directory**: `crates/beads-rs/src/core/**` → `crates/beads-core/src/**`\n   - `crates/beads-core/src/lib.rs` mirrors old `core/mod.rs` structure\n   - Keep `#![forbid(unsafe_code)]`\n\n3. **Update beads-rs to re-export**:\n   - Replace `pub mod core;` with `pub use beads_core as core;`\n   - This preserves `beads_rs::core::BeadId` etc.\n\n4. **Move git-dependent tests out of core**:\n   - `core/state.rs` tests that call `crate::git::wire::serialize_*` → move to `crates/beads-rs/tests/core_state_fingerprint.rs`\n   - Rule: **no beads-core tests depend on daemon/git/IPC modules**\n\n5. **Update Cargo.toml files**:\n   - `beads-core/Cargo.toml`: add `beads-macros` dependency, copy relevant deps from beads-rs\n   - `beads-rs/Cargo.toml`: add `beads-core` dependency\n\n**Files**\n- crates/beads-core/src/** (moved from beads-rs/src/core/**)\n- crates/beads-rs/src/lib.rs (re-export as core)\n- crates/beads-rs/src/error.rs (use beads_core types)\n- crates/beads-rs/tests/core_state_fingerprint.rs (new - moved tests)\n- crates/beads-core/Cargo.toml\n- crates/beads-rs/Cargo.toml","id":"bd-14fs.2","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 1: Extract core into beads-core","type":"task"}
{"_at":[1768448823112,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `RepoState.state` is `StoreState`, not `CanonicalState`.\n- [ ] `apply_event` is only called on the `CanonicalState` for the event’s namespace.\n- [ ] Checkpoint snapshot/export supports non-core namespaces (no hard error for non-core).\n- [ ] Queries and IPC handlers require namespace explicitly or use a single defaulting rule.\n- [ ] Tests cover same BeadId in different namespaces without collision.","closed_reason":"duplicate of bd-3m5.81","created_at":[1768443851032,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nEventBody carries `namespace`, watermarks are namespace-scoped, but daemon state is still a single `CanonicalState`. `apply_event` ignores namespace and `CheckpointSnapshot` rejects any namespace other than core. This makes namespaces a runtime convention instead of a type-level boundary, allows ID collisions across namespaces, and spreads conditional logic across the codebase.\n\n**Signals / Evidence**\n- `RepoState.state` is `CanonicalState` (no namespace) (`src/daemon/repo.rs`).\n- `apply_event(&mut CanonicalState, &EventBody)` ignores `EventBody.namespace` (`src/core/apply.rs`).\n- `checkpoint` snapshot builder rejects non-core namespaces (`src/git/checkpoint/export.rs`).\n- Namespace-aware types exist (`StoreState`, `NamespaceId`) but are not wired through daemon state.\n\n**Why this hurts velocity**\nWe keep adding namespace-aware code (watermarks, policies, repl), but the core state remains global. Every new feature needs bespoke checks, and any future multi-namespace work becomes a large invasive refactor.","design":"**Design**\n1. Promote `RepoState.state` to `StoreState` and make namespace the primary boundary.\n2. Add a thin helper `apply_event_to_namespace(store_state, body)` that routes to `StoreState::ensure_namespace(body.namespace)` and calls existing `apply_event` on the selected `CanonicalState`.\n3. Update mutation + repl ingest paths to use the namespace-scoped state.\n4. Update checkpoint snapshot/builders to accept `StoreState` and remove the core-only restriction.\n5. Audit query paths to require/propagate namespace (most are already in `NormalizedReadConsistency`).\n6. Add cross-namespace isolation tests (same BeadId in different namespaces does not conflict).\n\n**Design Notes**\nKeep `CanonicalState` unchanged; `StoreState` should be the only place that holds per-namespace maps. This keeps CRDT algebra stable while encoding the boundary in types.","id":"bd-de5","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Namespace boundary not encoded in state (StoreState migration)","type":"task"}
{"_at":[1769544463964,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] It is impossible to represent a sealed segment without `final_len` (compile‑time enforced).\n- [ ] DB load rejects invalid rows before creating `SegmentRow`.\n- [ ] Replay/fsck no longer needs to check for sealed+None at runtime.\n- [ ] Tests cover open vs sealed row serialization and invalid DB row rejection.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769501220121,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`SegmentRow` in the WAL index uses `sealed: bool` + `final_len: Option<u64>`. This allows invalid states like `sealed=true` with `final_len=None`, which are only caught at replay/fsck time.\n\nKey refs:\n- `crates/beads-rs/src/daemon/wal/index.rs:198` (SegmentRow)\n- `crates/beads-rs/src/daemon/wal/replay.rs:264` (runtime error when sealed missing final_len)\n\n**Impact**\nIndex invariants are not enforced at compile time; sealed segment metadata can be corrupt without immediate detection.","design":"**Design (opinionated)**\nMake sealed‑segment invariants structural.\n\nOption A (enum row):\n```rust\nenum SegmentRow {\n  Open { /* fields */, last_indexed_offset: u64 },\n  Sealed { /* fields */, final_len: u64 },\n}\n```\n- No `Option` for final_len; sealed implies `final_len` exists.\n- Encode/decode to DB enforces the invariant when loading rows.\n\nOption B (struct + NonZero marker):\n- `final_len: FinalLen` where `FinalLen` is only constructible when sealed, but enum is cleaner.\n\nUpdate replay/index logic to accept typed rows so invalid state cannot compile.","id":"bd-jedr","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Encode WAL segment sealed/final_len invariants","type":"bug"}
