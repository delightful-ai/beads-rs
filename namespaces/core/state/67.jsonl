{"_at":[1768448823112,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768443851032,1],"darin@book"],"claim":[[1768443851032,1],"darin@book"],"description":[[1768443851032,1],"darin@book"],"design":[[1768443851032,1],"darin@book"],"estimated_minutes":[[1768443851032,1],"darin@book"],"external_ref":[[1768443851032,1],"darin@book"],"labels":[[1768443851032,1],"darin@book"],"priority":[[1768443851032,1],"darin@book"],"source_repo":[[1768443851032,1],"darin@book"],"title":[[1768443851032,1],"darin@book"],"type":[[1768443851032,1],"darin@book"]},"acceptance_criteria":"- [ ] `RepoState.state` is `StoreState`, not `CanonicalState`.\n- [ ] `apply_event` is only called on the `CanonicalState` for the eventâ€™s namespace.\n- [ ] Checkpoint snapshot/export supports non-core namespaces (no hard error for non-core).\n- [ ] Queries and IPC handlers require namespace explicitly or use a single defaulting rule.\n- [ ] Tests cover same BeadId in different namespaces without collision.","closed_at":[1768448823112,1],"closed_by":"darin@book","closed_reason":"duplicate of bd-3m5.81","created_at":[1768443851032,1],"created_by":"darin@book","description":"**Problem**\nEventBody carries `namespace`, watermarks are namespace-scoped, but daemon state is still a single `CanonicalState`. `apply_event` ignores namespace and `CheckpointSnapshot` rejects any namespace other than core. This makes namespaces a runtime convention instead of a type-level boundary, allows ID collisions across namespaces, and spreads conditional logic across the codebase.\n\n**Signals / Evidence**\n- `RepoState.state` is `CanonicalState` (no namespace) (`src/daemon/repo.rs`).\n- `apply_event(&mut CanonicalState, &EventBody)` ignores `EventBody.namespace` (`src/core/apply.rs`).\n- `checkpoint` snapshot builder rejects non-core namespaces (`src/git/checkpoint/export.rs`).\n- Namespace-aware types exist (`StoreState`, `NamespaceId`) but are not wired through daemon state.\n\n**Why this hurts velocity**\nWe keep adding namespace-aware code (watermarks, policies, repl), but the core state remains global. Every new feature needs bespoke checks, and any future multi-namespace work becomes a large invasive refactor.","design":"**Design**\n1. Promote `RepoState.state` to `StoreState` and make namespace the primary boundary.\n2. Add a thin helper `apply_event_to_namespace(store_state, body)` that routes to `StoreState::ensure_namespace(body.namespace)` and calls existing `apply_event` on the selected `CanonicalState`.\n3. Update mutation + repl ingest paths to use the namespace-scoped state.\n4. Update checkpoint snapshot/builders to accept `StoreState` and remove the core-only restriction.\n5. Audit query paths to require/propagate namespace (most are already in `NormalizedReadConsistency`).\n6. Add cross-namespace isolation tests (same BeadId in different namespaces does not conflict).\n\n**Design Notes**\nKeep `CanonicalState` unchanged; `StoreState` should be the only place that holds per-namespace maps. This keeps CRDT algebra stable while encoding the boundary in types.","id":"bd-de5","labels":[],"priority":1,"status":"closed","title":"Namespace boundary not encoded in state (StoreState migration)","type":"task"}
