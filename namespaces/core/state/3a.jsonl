{"_at":[1768481051485,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768480671080,0],"created_by":"darin@darinsmcstudio2.lan","description":"","id":"bd-16g","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"src/core/event.rs: nested map decoders allow duplicate keys; spec 3.1 requires rejecting duplicates","type":"chore"}
{"_at":[1768439486541,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768178869098,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nPlan requires fuzz testing for decode paths to find edge cases.\n\n**Context**\n- REALTIME_PLAN.md ยง18 (fuzzing + crash safety)\n\n**Design**\n- cargo-fuzz targets:\n  - WAL frame decode (length/crc/tail truncation)\n  - CBOR EventBody decode with bounds (depth, map entries, array entries)\n  - Replication message decode (HELLO/WELCOME/EVENTS)\n- Use libfuzzer or afl via cargo-fuzz\n- CI runs fuzz for bounded time on each PR (optional)\n\n**Acceptance**\n- [ ] fuzz/fuzz_targets/wal_decode.rs exists\n- [ ] fuzz/fuzz_targets/event_body_decode.rs exists\n- [ ] fuzz/fuzz_targets/repl_message_decode.rs exists\n- [ ] cargo fuzz run <target> works\n\n**Files:** fuzz/fuzz_targets/wal_decode.rs (new), fuzz/fuzz_targets/event_body_decode.rs (new), fuzz/fuzz_targets/repl_message_decode.rs (new), Cargo.toml","id":"bd-3m5.41","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Cross-phase: Fuzz targets for WAL/CBOR/replication decode","type":"task"}
{"_at":[1768529791359,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `BeadPatch.status` is typed, not `Patch<String>`.\n- [ ] Invalid status strings are rejected during IPC parsing with a clear validation error.\n- [ ] Mutation engine no longer matches status strings.","assignee":"darin@book","created_at":[1768503193389,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`src/daemon/ops.rs` defines `BeadPatch.status` as `Patch<String>`. The mutation engine parses strings into `WorkflowStatus` later, so invalid values flow deep into realtime planning and errors are ad-hoc. This keeps workflow invariants out of the type system and duplicates parsing logic.\n\n**Files**\n- src/daemon/ops.rs\n- src/daemon/mutation_engine.rs\n- src/daemon/ipc.rs","design":"Change `BeadPatch.status` to a typed patch (`Patch<WorkflowStatus>` or `Patch<Workflow>`). Provide serde mapping at the IPC boundary so JSON still uses `open|in_progress|closed`. Validate/parse in IPC and keep internal code fully typed. Update mutation engine and canonicalization to use the typed status directly; remove string matching.","id":"bd-nph","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"BeadPatch.status should be typed (WorkflowStatus)","type":"chore"}
{"_at":[1768622470110,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622470110,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nGo beads prevents a specific anti-pattern: children explicitly depending on their parent via blocks/waits-for. This creates a deadlock because:\n- Child can't start (parent is open)\n- Parent can't close (children not done)\n\nThis is an LLM temporal reasoning trap. beads-rs needs this validation.\n\n**How it works in Go beads**\n- Detection in cmd/bd/dep.go lines 152-154 and 343-345\n- Uses `isChildOf()` helper (lines 31-44)\n- Checks hierarchical ID structure: \"bd-abc.1\" is child of \"bd-abc\"\n- Blocks creation with clear error message\n- Error: \"Adding an explicit dependency would create a deadlock\"\n- Pure validation logic - no fix, just reject\n\n**Detection algorithm**\n```go\nfunc isChildOf(childID, parentID string) bool {\n    _, actualParentID, depth := types.ParseHierarchicalID(childID)\n    if depth == 0 {\n        return false // Not hierarchical\n    }\n    if actualParentID == parentID {\n        return true // Immediate parent\n    }\n    return strings.HasPrefix(childID, parentID + \".\")\n}\n```\n\n**Design for Rust**\n1. Add hierarchical ID parsing to BeadId in src/core/identity.rs\n   - Parse \"bd-abc.1.2\" into (base, depth, parent)\n   - Depth 0 = not hierarchical\n2. Add is_child_of() method to BeadId\n3. Add validation in dep add operation (daemon/ops/)\n   - Check if from.is_child_of(to) for blocks/waits-for deps\n   - Return clear error if detected\n4. Add test cases for edge cases:\n   - Immediate child: bd-abc.1 depends on bd-abc\n   - Nested child: bd-abc.1.2 depends on bd-abc\n   - Non-hierarchical: bd-abc depends on bd-xyz (ok)\n\n**Design considerations**\n- Which dep types need this check?\n  * Blocks: yes (creates deadlock)\n  * WaitsFor: yes (creates deadlock)\n  * Parent: no (that's the hierarchy itself)\n  * Others: no (informational)\n- Should we check reverse (parent depending on child)? \n  * That's actually fine - parent blocks until child done\n- Error message clarity for LLMs\n\n**Design questions for human review**\n- Should we detect transitive child relationships?\n  * \"bd-abc.1.2\" is grandchild of \"bd-abc\"\n  * Current Go code handles this via prefix check\n- Should this be a warning or hard error?\n  * Go: hard error (prevents creation)\n  * Seems right - this is always wrong\n\n**Files to study**\n- tmp/beads/cmd/bd/dep.go - isChildOf helper, validation sites\n- tmp/beads/internal/types/types.go - ParseHierarchicalID function\n- src/core/identity.rs - BeadId structure\n\n**Acceptance**\n- [ ] BeadId supports hierarchical parsing\n- [ ] is_child_of() method implemented and tested\n- [ ] Dep add validates child-to-parent for blocks/waits-for\n- [ ] Clear error message returned on violation\n- [ ] Test coverage for immediate and nested children\n- [ ] Cargo fmt, clippy, test pass","id":"bd-ze0x.28","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":17864181886599255929,"replica":"ae55787a-141c-0d47-2a60-cc9b56483175"}]}},"priority":2,"status":"open","title":"Add child-to-parent dependency deadlock detection","type":"feature"}
