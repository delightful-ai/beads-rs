{"_at":[1768364180343,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] ReplicatedFsync(k) completes when k eligible replicas ACK.\n- [ ] Insufficient eligible replicas triggers immediate error.\n- [ ] Durable watermark advances only after local fsync and required ACKs.","assignee":"darin@book","created_at":[1768177908730,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nPhase 5: implement DurabilityCoordinator for LocalFsync and ReplicatedFsync(k). There is no coordinator to track peer ACKs or advance durable watermarks beyond local fsync.\n\n**Context**\n- REALTIME_PLAN.md §10 (durability coordination), §0.12 (applied vs durable watermarks), §2.1.2 (replica roster)\n**Files:** src/daemon/durability_coordinator.rs (new), src/daemon/store_runtime.rs, src/daemon/repl/*","design":"**Design**\n- Track pending txns by txn_id and required durability class.\n- For ReplicatedFsync(k), select eligible replicas (from roster if present) and wait for durable ACKs.\n- On success, return updated receipt with durability_proof and advance durable watermarks.\n- On insufficient eligible replicas, return ERROR(code=\"durability_unavailable\").","id":"bd-3m5.18","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 5: DurabilityCoordinator + peer ACK tracking","type":"task"}
{"_at":[1769481353588,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] All new ctx/payload types compile and are exported.\n- [ ] Request enum refactor keeps JSON wire format stable.\n- [ ] Added IPC tests for Claim default and ExtendClaim required lease.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769480286540,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIPC request shapes are duplicated and flat. We need shared ctx/payload types in beads-surface and a `Request` enum refactor without changing the wire format or defaults.\n\n**Design**\nImplement Phase 1 + Phase 2 of REFACTORING_PLAN.md in `crates/beads-surface` only:\n- Add `ipc/ctx.rs` with RepoCtx/MutationCtx/ReadCtx and constructors.\n- Add `ipc/payload.rs` with payload structs grouped by shape.\n- Move `default_lease_secs()` from `ipc/types.rs` into `ipc/mod.rs` as `pub(crate)`; import it in `payload.rs` for `ClaimPayload`.\n- Refactor `Request` enum variants to `{ ctx, payload }` with `#[serde(flatten)]` and keep all field names/renames/defaults identical.\n- Re-export ctx/payload from `ipc/types.rs` (and module wiring in `ipc/mod.rs`).\n- Update IPC unit tests in `ipc/types.rs` to new shape and add:\n  - Claim default lease (deserialize without lease_secs → 3600).\n  - ExtendClaim requires lease (missing lease_secs → error).\n  - RepoCtx rename (serialized JSON has \"repo\" not \"path\").\n\n**Design Notes**\n- Non‑negotiable behavior: serde defaults/renames must remain identical; Claim vs ExtendClaim defaults must not change.\n- Do not add new `skip_serializing_if` or change `#[serde(default)]` locations.\n\n**Acceptance**\n- [ ] `Request` JSON fields are unchanged for existing ops.\n- [ ] Claim defaults to 3600s when lease_secs is omitted; ExtendClaim still requires lease_secs.\n- [ ] `cargo test -p beads-surface ipc::types` passes.\n\n**Files:**\n- crates/beads-surface/src/ipc/ctx.rs\n- crates/beads-surface/src/ipc/payload.rs\n- crates/beads-surface/src/ipc/types.rs\n- crates/beads-surface/src/ipc/mod.rs","design":"Follow REFACTORING_PLAN.md Phases 1–2 exactly. Keep wire format identical; move default_lease_secs to ipc/mod.rs for shared use.","id":"bd-ebhh.1","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"beads-surface: add ctx/payload modules and refactor Request (wire-compat)","type":"task"}
{"_at":[1769560267801,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769202950304,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Segment:** crdt/5-tests (bd-3zoj.16, bd-3zoj.17, bd-3zoj.18, bd-3wz4)\n**Files:** src/git/wire.rs, src/core/wire_bead.rs, src/daemon/query_model.rs, src/api/issues.rs, CRDT_OVERHAUL.md\n**RepoPrompt chat:** crdt-tests-review-E393FB\n\n---\n\n## Summary (what this segment accomplishes)\n\nThis segment adds/expands test coverage around four CRDT-overhaul invariants:\n\n1. **Wire encode/decode roundtrips (realtime + snapshot wire)**  \n   `src/core/wire_bead.rs` now has unit tests confirming JSON roundtrips for `WireNoteV1`, `WireBeadPatch` (incl. `WirePatch::Clear`), and `TxnDeltaV1` (incl. `WireDotV1` + `WireDvvV1` through op payloads). It also asserts **canonical op ordering** and **duplicate-key rejection**.\n\n2. **Git/checkpoint roundtrips preserving OR-Set metadata + notes**  \n   `src/git/wire.rs` tests now exercise `serialize_*` + `parse_legacy_state` end-to-end and explicitly verify that **OR-Set dots + causal context (DVV)** and **notes** survive a roundtrip.\n\n3. **Deterministic OR-Set serialization**  \n   `src/git/wire.rs` includes a \"same logical state, different insertion order\" test asserting byte-for-byte identical `state.jsonl`, `deps.jsonl`, and `notes.jsonl`.\n\n4. **`updated_at` changes when labels/notes change (no scalar field edit)**  \n   `src/core/state.rs` validates `updated_stamp` includes label/note activity, and both `src/api/issues.rs` and `src/daemon/query_model.rs` add tests showing this propagates correctly to `Issue/IssueSummary.updated_at` and `updated_by`.\n\nOverall this aligns well with **CRDT_OVERHAUL.md**'s locked invariants.\n\n---\n\n## Critical issues (should address)\n\n### 1) Determinism test does not vary label/dep stamps, so it may miss a real convergence bug\nYour determinism test (`serialize_orset_is_deterministic_across_insertion_order`) varies *operation insertion order*, but all label/dep ops share the same `Stamp` (`stamp.clone()` everywhere). That means it **won't catch** an important class of nondeterminism:\n\n- If `label_stamp` / `dep_store.stamp` are updated by **assignment** (last-applied wins) rather than **`max(existing, incoming)`**, then applying the same set of ops in different orders but with *different stamps* can yield different final metadata → different `updated_stamp` / different serialization bytes.\n\nThis matters because **CRDT_OVERHAUL.md's updated_stamp rule** implicitly assumes those stamps are stable CRDT summaries (i.e., merge/order independent).\n\n**Actionable fix (tests):**\n- Modify the insertion-order determinism test to use *different* stamps for the two label adds (and separately dep adds), then apply in opposite orders and assert serialization equality.\n- Same idea for label add vs label remove: different stamps, reversed order.\n\nIf that test fails, it indicates a real CRDT convergence issue in stamp tracking (not just a test issue).\n\n---\n\n## Minor improvements (quality + coverage)\n\n### A) Add a `WireBeadFull` JSON roundtrip test (not just conversion test)\n`wire_bead_full_preserves_stamps` validates `BeadView → WireBeadFull → Bead` conversion and `label_stamp()` behavior, but does **not** assert JSON encode/decode roundtrip for `WireBeadFull` itself.\n\n**Suggestion:**\n- Add `serde_json::to_string(&wire)` then `from_str` and assert equality.\n- Include at least two notes out-of-order to verify the note sorting determinism actually gets exercised (currently only one note).\n\n### B) Add a sparse-`_v` partial coverage test for git wire\nIn `src/git/wire.rs`, current tests hit:\n- `_v` omitted (all fields same as bead stamp), and\n- `_v` containing \"everything\" (when notes force bead-level stamp ahead of all fields).\n\nThey do not clearly hit the \"**only some fields differ**\" case (sparse `_v` correctness).\n\n**Suggestion:**\n- Construct a bead where only `title.stamp` is newer than the rest (no notes), serialize/parse/serialize, and assert byte-for-byte equality.\n- Add a case where `label_stamp == bead_stamp` so `_v.labels` is omitted and must be reconstructed from default `_at/_by`.\n\n### C) Reduce duplication between API and daemon updated_at tests\n`src/api/issues.rs` and `src/daemon/query_model.rs` test modules are essentially identical. That's fine short-term, but it's extra maintenance.\n\n**Suggestion:**\n- Factor shared helpers into a small internal test helper module (even just a `#[cfg(test)] mod test_helpers` in `core`).\n\n### D) If legacy parsing is intended to be supported, add explicit legacy-format tests\n`parse_deps` and `WireLabels` both support legacy shapes, but this segment's tests primarily validate the new OR-Set format.\n\n**Suggestion:**\n- Add a focused unit test that feeds `parse_deps` multiple legacy `WireDep` lines and asserts correct reconstructed state (or explicitly decide legacy isn't required and remove the parser paths).\n\n---\n\n## What's done particularly well\n\n- **End-to-end checksum & roundtrip assertions** in `src/git/wire.rs` are strong; byte-for-byte equality is exactly what you want for the determinism requirement.\n- The OR-Set metadata test (`roundtrip_orset_metadata_preserves_dots_and_context`) correctly asserts both:\n  - membership dots (`dots_for(...)`), and\n  - causal context (`cc()`),\n  which directly matches CRDT_OVERHAUL's \"persist dots + DVV\" invariant.\n- The **`updated_at` propagation tests** validate the full pipeline: `CanonicalState.bead_view → BeadView.updated_stamp → Issue/IssueSummary updated_at`, matching the architecture notes.\n\n---\n\n## Next steps (specific, actionable)\n\n1. **Strengthen determinism tests** by using different stamps for label/dep ops in different application orders (this is the biggest missing coverage).\n2. Add:\n   - `WireBeadFull` JSON roundtrip test (with >1 note to exercise sorting),\n   - git wire sparse `_v` partial-diff test.\n3. Optional cleanup: dedupe API + daemon updated_at tests via a shared helper module.","id":"bd-ogvs.5","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Segment 5: Tests review","type":"task"}
