{"_at":[1765836331910,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1765744958180,0],"darin@book"],"claim":[[1765835964259,0],"darin@dusk"],"description":[[1765745369623,0],"darin@book"],"design":[[1765745333590,0],"darin@book"],"estimated_minutes":[[1765744958180,0],"darin@book"],"external_ref":[[1765744958180,0],"darin@book"],"labels":[[1765744958180,0],"darin@book"],"priority":[[1765744958180,0],"darin@book"],"source_repo":[[1765744958180,0],"darin@book"],"title":[[1765744958180,0],"darin@book"],"type":[[1765744958180,0],"darin@book"]},"assignee":"darin@dusk","assignee_at":[1765835964259,0],"assignee_expires":1765839564259,"closed_at":[1765836331910,0],"closed_by":"darin@dusk","created_at":[1765744958180,0],"created_by":"darin@book","description":"Many queries do repeated full scans of deps (`deps_from`, `compute_blocked_by`, cycle detection, validation). Fine at 200 issues, painful at 20k.\n\n**Files:** src/core/state.rs, src/daemon/query_executor.rs, src/daemon/executor.rs","design":"**In-memory only** — indexes live in `RepoState`, never persisted to deps.jsonl.\n\n**Rebuild on load:** When daemon starts or merges from git, iterate deps once to build:\n```rust\nstruct DepIndexes {\n    out_edges: BTreeMap<BeadId, Vec<(BeadId, DepKind)>>,  // from -> [(to, kind)]\n    in_edges: BTreeMap<BeadId, Vec<(BeadId, DepKind)>>,   // to -> [(from, kind)]\n}\n```\n\n**Incremental update:** In `apply_add_dep` / `apply_remove_dep`, push/remove from both maps.\n\n**Functions to change:**\n- `deps_from()` (state.rs:300) → lookup `out_edges[id]`\n- `deps_to()` (state.rs:309) → lookup `in_edges[id]`  \n- `compute_blocked_by()` (query_executor.rs:707) → iterate `in_edges` filtered by kind\n- `would_create_cycle()` (executor.rs:1073) → BFS uses `out_edges` directly\n\nComplexity drops from O(all deps) to O(neighbors per hop).","id":"bd-g1c","labels":[],"priority":2,"status":"closed","title":"Add derived indexes to avoid full dep scans","type":"feature"}
