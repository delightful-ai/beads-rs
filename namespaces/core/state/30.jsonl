{"_at":[1768483741795,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768444265300,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nREALTIME_PLAN §2.2 lists default policies for core/sys/wf/tmp. StoreRuntime::load_namespace_policies falls back to default_policies() which only inserts core, so sys/wf/tmp are never present unless explicitly configured.\n\nEvidence:\n- src/daemon/store_runtime.rs:335–341 default_policies inserts only NamespaceId::core().\n- src/core/namespace.rs defines sys_default/wf_default/tmp_default but they are unused.\n\n**Acceptance**\n- [ ] When namespaces.toml is missing, populate defaults for core/sys/wf/tmp per plan.\n- [ ] Add tests asserting default policy map includes sys/wf/tmp.","id":"bd-3m5.91","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Default namespaces only include core; sys/wf/tmp defaults unused","type":"bug"}
{"_at":[1766124451834,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@dusk","created_at":[1766116454284,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nMutations can succeed even when WAL writes fail. In `src/daemon/core.rs` `mark_dirty_and_schedule` logs a warning and proceeds, so a crash can lose acknowledged data. There is no rollback of in-memory state when WAL writes fail.\n\n**Design**\nIntroduce a transactional mutation path that applies changes to a cloned `CanonicalState`, writes the WAL entry first, and only commits the new state + dirty flag on success. Add a dedicated OpError (e.g., `WalError`/`DurabilityError`) surfaced via IPC. Ensure WAL sequence only advances on successful write. Add a unit test that forces WAL write failure and verifies no state change + error return.\n\n**Acceptance**\n- [ ] WAL write failures return an error and do not modify repo state\n- [ ] WAL sequence/dirty flags remain unchanged on WAL failure\n- [ ] Successful WAL writes still schedule sync\n- [ ] Tests cover WAL failure path\n- [ ] Tests pass\n\n**Files:** src/daemon/core.rs, src/daemon/executor.rs, src/daemon/ops.rs, src/daemon/wal.rs","id":"bd-ar4","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"WAL write failure must abort mutation + preserve state","type":"bug"}
{"_at":[1769595404044,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] A validated mutation command type exists in `beads-core` with constructors enforcing invariants.\n- [ ] `mutation_engine` only emits validated commands (no raw unvalidated patch ops).\n- [ ] Event generation maps validated commands to wire/event representation without additional validation.\n- [ ] Duplicate validations in daemon/event paths are removed or reduced to normalization.\n- [ ] Tests cover invalid commands rejected at construction and valid commands producing events.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769573201177,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nMutation planning and validation are split across crates:\n- `crates/beads-rs/src/daemon/mutation_engine.rs` constructs mutations and performs partial validation.\n- `crates/beads-core/src/event.rs` performs patch validation when building event bodies.\n\nA reader must cross crates to know whether a mutation is valid. Invariants live \"somewhere else\" and are not encoded as a single validated command type.\n\n**Files:**\n- `crates/beads-rs/src/daemon/mutation_engine.rs`\n- `crates/beads-core/src/event.rs`\n- `crates/beads-core/src/wire_bead.rs`\n- `crates/beads-surface/src/ops.rs`","design":"**Design**\nCreate a validated mutation/command type in `beads-core` and require the daemon to construct only validated commands.\n\nConcrete plan:\n1) Introduce a `ValidatedMutationCommand` (or similar) in `beads-core` representing all mutation operations (create, update, close, add dep, set parent, etc.).\n2) Provide constructors that validate semantic invariants (required fields, workflow/claim rules, dep constraints, etc.).\n3) Update `mutation_engine` to build these validated commands rather than raw wire patches/ops.\n4) Update event generation to accept only validated commands and then mechanically map them to event/wire representations.\n5) Remove duplicate validation in daemon and event paths once the validated command is the sole input.\n\n**Design Notes**\n- This is a type-level boundary: once you have a `ValidatedMutationCommand`, it should be safe to apply.\n- Keep parsing and validation responsibilities clear: surface input -> parsed -> validated command -> apply/encode.","id":"bd-fn5l","labels":{"cc":{"max":{}},"entries":{"scatter":[{"counter":6582769231331402909,"replica":"b1cf9808-1b93-ce99-6aa4-46e20e14e46a"}],"tech-debt":[{"counter":3470888321659076830,"replica":"f0c01634-a84f-3e30-3954-73c868e2671a"}],"validation":[{"counter":6148553881263840510,"replica":"ae693b73-8e87-fe1b-f63a-a0ba4e593150"}]}},"notes":[{"at":[1769594432634,0],"author":"darin@darins-Mac-Studio-2.local","content":"Rendering stays in command files; avoid moving output logic into shared render modules for this work.","id":"go-comment-bd-fn5l-1"},{"at":[1769595404044,0],"author":"darin@darinsmcstudio2.lan","content":"Rendering stays in command files; avoid moving output logic into shared render modules for this work.","id":"legacy-notes"}],"priority":2,"status":"closed","title":"Centralize mutation validation in core","type":"chore"}
{"_at":[1769215079275,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Test: legacy deps JSONL parses into expected DepStore values.\\n- [ ] Test: ordering and determinism preserved after parse -> serialize.","assignee":"darin@book","created_at":[1769209838539,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\nLegacy dep parsing paths exist but are not explicitly tested.\\n\\n**Files**: src/git/wire.rs","design":"**Design**\\nAdd unit tests that feed legacy dep JSONL lines (per-edge) into parse_deps/parse_legacy_state and assert correct DepStore reconstruction and ordering.","id":"bd-qz97.16","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Legacy deps parsing tests (git wire)","type":"task"}
{"_at":[1765775547196,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@dusk","created_at":[1765689969486,0],"created_by":"darin@darinsmcstudio2.lan","description":"## What's Wrong\ncargo fmt prints warnings because rustfmt.toml sets unstable_features=true and group_imports=StdExternalCrate, which require nightly rustfmt.\n\n## Where\n- rustfmt.toml\n\n## Why It Matters\nNoisy output in CI/local workflows (for example, just release-patch runs cargo fmt -- --check). It can also cause formatting drift if contributors have different toolchains.\n\n## Options\n1. Remove unstable settings and rely on stable rustfmt defaults.\n2. Pin nightly rustfmt in dev shell/CI to support the config.\n\n---\nDiscovered while: running cargo fmt during migration slug work.","id":"bd-wte","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"rustfmt.toml uses unstable options on stable","type":"chore"}
{"_at":[1765786547553,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@dusk","closed_reason":"Added with_mutation helper to Daemon, refactored apply_claim to use it. Pattern eliminates the 'check, drop, tick, re-fetch, unwrap' sequence.","created_at":[1765744420750,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nBorrow checker forces this awkward pattern:\n1. Borrow `repo_state` to check something\n2. Need `&mut self` to tick the clock\n3. Drop borrow, re-borrow, and `unwrap()` because \"I proved it exists earlier\"\n\n**Design**\nWrap mutation in a helper that ticks before handing out the borrow:\n```rust\nimpl Daemon {\n    fn with_mutation<R>(\n        &mut self,\n        loaded: &LoadedRemote,  // or repo: &Path + git_tx\n        f: impl FnOnce(&mut RepoState, Stamp) -> Result<R, OpError>,\n    ) -> Result<R, OpError> {\n        let write = self.clock_mut().tick();\n        let stamp = Stamp { at: write, by: self.actor().clone() };\n        let rs = self.repo_state_mut(loaded);\n        f(rs, stamp)\n    }\n}\n```\n\nNow `apply_update`/`apply_close`/`apply_claim` can do \"check + mutate\" in one borrow.\n\n**Design Notes**\n- Depends on `LoadedRemote` existing (bd-xxx) OR can take repo+git_tx and call ensure_repo_loaded internally\n- Consider whether stamp should be passed in or returned for callers that need it after\n- May want variants: `with_mutation` vs `with_mutation_loaded` depending on whether repo already loaded\n\n**Acceptance**\n- [ ] `with_mutation` helper exists in `src/daemon/mod.rs`\n- [ ] At least one executor method uses it (start with simplest case like `apply_claim`)\n- [ ] Pattern eliminates the \"check, drop, tick, re-fetch, unwrap\" sequence\n- [ ] Tests pass\n\n**Files:** src/daemon/mod.rs, src/daemon/executor.rs","id":"bd-xmr","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Add with_mutation helper for borrow-checker friendly mutations","type":"chore"}
