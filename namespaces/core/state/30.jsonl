{"_at":[1768483741795,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768444265300,1],"darin@book"],"claim":[[1768483574286,1],"darin@book"],"description":[[1768444265300,1],"darin@book"],"design":[[1768444265300,1],"darin@book"],"estimated_minutes":[[1768444265300,1],"darin@book"],"external_ref":[[1768444265300,1],"darin@book"],"labels":[[1768444265300,1],"darin@book"],"priority":[[1768444265300,1],"darin@book"],"source_repo":[[1768444265300,1],"darin@book"],"title":[[1768444265300,1],"darin@book"],"type":[[1768444265300,1],"darin@book"]},"assignee":"darin@book","assignee_at":[1768483574286,1],"assignee_expires":1768487174286,"closed_at":[1768483741795,1],"closed_by":"darin@book","created_at":[1768444265300,1],"created_by":"darin@book","description":"**Problem**\nREALTIME_PLAN §2.2 lists default policies for core/sys/wf/tmp. StoreRuntime::load_namespace_policies falls back to default_policies() which only inserts core, so sys/wf/tmp are never present unless explicitly configured.\n\nEvidence:\n- src/daemon/store_runtime.rs:335–341 default_policies inserts only NamespaceId::core().\n- src/core/namespace.rs defines sys_default/wf_default/tmp_default but they are unused.\n\n**Acceptance**\n- [ ] When namespaces.toml is missing, populate defaults for core/sys/wf/tmp per plan.\n- [ ] Add tests asserting default policy map includes sys/wf/tmp.","id":"bd-3m5.91","labels":[],"priority":3,"status":"closed","title":"Default namespaces only include core; sys/wf/tmp defaults unused","type":"bug"}
{"_at":[1766124451834,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1766116454284,0],"darin@dusk"],"claim":[[1766124451776,0],"darin@dusk"],"description":[[1766116454284,0],"darin@dusk"],"design":[[1766116454284,0],"darin@dusk"],"estimated_minutes":[[1766116454284,0],"darin@dusk"],"external_ref":[[1766116454284,0],"darin@dusk"],"labels":[[1766116454284,0],"darin@dusk"],"priority":[[1766116454284,0],"darin@dusk"],"source_repo":[[1766116454284,0],"darin@dusk"],"title":[[1766116454284,0],"darin@dusk"],"type":[[1766116454284,0],"darin@dusk"]},"assignee":"darin@dusk","assignee_at":[1766124451776,0],"assignee_expires":1766128051776,"closed_at":[1766124451834,0],"closed_by":"darin@dusk","created_at":[1766116454284,0],"created_by":"darin@dusk","description":"**Problem**\nMutations can succeed even when WAL writes fail. In `src/daemon/core.rs` `mark_dirty_and_schedule` logs a warning and proceeds, so a crash can lose acknowledged data. There is no rollback of in-memory state when WAL writes fail.\n\n**Design**\nIntroduce a transactional mutation path that applies changes to a cloned `CanonicalState`, writes the WAL entry first, and only commits the new state + dirty flag on success. Add a dedicated OpError (e.g., `WalError`/`DurabilityError`) surfaced via IPC. Ensure WAL sequence only advances on successful write. Add a unit test that forces WAL write failure and verifies no state change + error return.\n\n**Acceptance**\n- [ ] WAL write failures return an error and do not modify repo state\n- [ ] WAL sequence/dirty flags remain unchanged on WAL failure\n- [ ] Successful WAL writes still schedule sync\n- [ ] Tests cover WAL failure path\n- [ ] Tests pass\n\n**Files:** src/daemon/core.rs, src/daemon/executor.rs, src/daemon/ops.rs, src/daemon/wal.rs","id":"bd-ar4","labels":[],"priority":0,"status":"closed","title":"WAL write failure must abort mutation + preserve state","type":"bug"}
{"_at":[1765775547196,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1765689969486,0],"darin@dusk"],"claim":[[1765775497860,0],"darin@dusk"],"description":[[1765690062952,0],"darin@dusk"],"design":[[1765689969486,0],"darin@dusk"],"estimated_minutes":[[1765689969486,0],"darin@dusk"],"external_ref":[[1765689969486,0],"darin@dusk"],"labels":[[1765689969486,0],"darin@dusk"],"priority":[[1765689969486,0],"darin@dusk"],"source_repo":[[1765689969486,0],"darin@dusk"],"title":[[1765689969486,0],"darin@dusk"],"type":[[1765689969486,0],"darin@dusk"]},"assignee":"darin@dusk","assignee_at":[1765775497860,0],"assignee_expires":1765779097860,"closed_at":[1765775547196,0],"closed_by":"darin@dusk","created_at":[1765689969486,0],"created_by":"darin@dusk","description":"## What's Wrong\ncargo fmt prints warnings because rustfmt.toml sets unstable_features=true and group_imports=StdExternalCrate, which require nightly rustfmt.\n\n## Where\n- rustfmt.toml\n\n## Why It Matters\nNoisy output in CI/local workflows (for example, just release-patch runs cargo fmt -- --check). It can also cause formatting drift if contributors have different toolchains.\n\n## Options\n1. Remove unstable settings and rely on stable rustfmt defaults.\n2. Pin nightly rustfmt in dev shell/CI to support the config.\n\n---\nDiscovered while: running cargo fmt during migration slug work.","id":"bd-wte","labels":[],"priority":3,"status":"closed","title":"rustfmt.toml uses unstable options on stable","type":"chore"}
{"_at":[1765786547553,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1765744420750,0],"darin@book"],"claim":[[1765786441273,0],"darin@dusk"],"description":[[1765744420750,0],"darin@book"],"design":[[1765744420750,0],"darin@book"],"estimated_minutes":[[1765744420750,0],"darin@book"],"external_ref":[[1765744420750,0],"darin@book"],"labels":[[1765744420750,0],"darin@book"],"priority":[[1765744420750,0],"darin@book"],"source_repo":[[1765744420750,0],"darin@book"],"title":[[1765744420750,0],"darin@book"],"type":[[1765744420750,0],"darin@book"]},"assignee":"darin@dusk","assignee_at":[1765786441273,0],"assignee_expires":1765790041273,"closed_at":[1765786547553,0],"closed_by":"darin@dusk","closed_reason":"Added with_mutation helper to Daemon, refactored apply_claim to use it. Pattern eliminates the 'check, drop, tick, re-fetch, unwrap' sequence.","created_at":[1765744420750,0],"created_by":"darin@book","description":"**Problem**\nBorrow checker forces this awkward pattern:\n1. Borrow `repo_state` to check something\n2. Need `&mut self` to tick the clock\n3. Drop borrow, re-borrow, and `unwrap()` because \"I proved it exists earlier\"\n\n**Design**\nWrap mutation in a helper that ticks before handing out the borrow:\n```rust\nimpl Daemon {\n    fn with_mutation<R>(\n        &mut self,\n        loaded: &LoadedRemote,  // or repo: &Path + git_tx\n        f: impl FnOnce(&mut RepoState, Stamp) -> Result<R, OpError>,\n    ) -> Result<R, OpError> {\n        let write = self.clock_mut().tick();\n        let stamp = Stamp { at: write, by: self.actor().clone() };\n        let rs = self.repo_state_mut(loaded);\n        f(rs, stamp)\n    }\n}\n```\n\nNow `apply_update`/`apply_close`/`apply_claim` can do \"check + mutate\" in one borrow.\n\n**Design Notes**\n- Depends on `LoadedRemote` existing (bd-xxx) OR can take repo+git_tx and call ensure_repo_loaded internally\n- Consider whether stamp should be passed in or returned for callers that need it after\n- May want variants: `with_mutation` vs `with_mutation_loaded` depending on whether repo already loaded\n\n**Acceptance**\n- [ ] `with_mutation` helper exists in `src/daemon/mod.rs`\n- [ ] At least one executor method uses it (start with simplest case like `apply_claim`)\n- [ ] Pattern eliminates the \"check, drop, tick, re-fetch, unwrap\" sequence\n- [ ] Tests pass\n\n**Files:** src/daemon/mod.rs, src/daemon/executor.rs","id":"bd-xmr","labels":[],"priority":2,"status":"closed","title":"Add with_mutation helper for borrow-checker friendly mutations","type":"chore"}
