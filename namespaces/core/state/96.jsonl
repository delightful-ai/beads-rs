{"_at":[1769560184576,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769201905536,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Segment:** crdt/4-git-wire (bd-3zoj.10)\n**Files:** src/git/wire.rs, src/git/sync.rs, src/core/state.rs, src/core/orset.rs, src/daemon/migration.rs\n**RepoPrompt chat:** git-wire-review-451D06\n\n---\n\n## Summary\n\nThis segment keeps the Git wire format deterministic and roundtrippable while adding/using richer CRDT stores:\n\n- `deps.jsonl` supports an OR-Set encoding (`WireDepStore`) and can still parse legacy per-edge JSONL.\n- `state.jsonl` embeds per-bead OR-Set label metadata and uses the sparse `_v` mechanism for per-field stamps (SPEC §5.2.1).\n- `notes.jsonl` is serialized deterministically and included in `meta.json` checksums (optional on read for legacy commits).\n- The actual diff in this slice is a small readability refactor in `parse_deps` (using an `if ... && let Ok(...)` chain) with no intended semantic change.\n\n## Critical issues (must address)\n\n### 1) Integrity hole: `read_state_at_oid` silently ignores malformed `meta.json`\nIn `src/git/sync.rs`, meta parsing is guarded by an `if let ... && let Ok(meta) = wire::parse_meta(...)` chain. If `meta.json` exists but is corrupted/unparseable, the loader currently:\n- drops `checksums` to `None`, and\n- proceeds to load state without checksum verification.\n\nThis undermines SPEC §5.2 (\"Readers MUST verify these checksums when present\") and makes corruption harder to detect.\n\n**Action:** Treat an existing-but-unparseable `meta.json` as a hard load failure. Concretely, change the loader logic to:\n- if `meta.json` is present → require `parse_meta` succeed (or return error),\n- and if parsed checksums exist → always verify.\n\n### 2) Deterministic dep ordering may be spec-ambiguous because `DepKind` ordering is likely enum-order, not lexical\n`serialize_deps` sorts entries by `DepKey` (`entries.sort_by(|a,b| a.key.cmp(&b.key))`). `DepKey` derives `Ord`, meaning `(from, to, kind)` ordering uses `DepKind`'s `Ord`.\n\nIf `DepKind` is `#[derive(Ord)]` in variant-declaration order (common), that order may not match a lexical `\"blocks\" < \"discovered_from\" < \"parent\" < \"related\"` interpretation of SPEC §5.3's `(from,to,kind)` ascending requirement.\n\n**Action options:**\n- Make `DepKind: Ord` explicitly compare by `as_str()` (recommended for cross-impl determinism).\n- Or, keep `DepKind` as-is but **explicitly codify** in SPEC/design docs that ordering uses enum-variant order, not string order.\n\n### 3) MSRV risk: `if let` chains require a minimum Rust version\nThe diff changes to:\n\n```rust\nif non_empty.len() == 1\n    && let Ok(wire) = serde_json::from_str::<WireDepStore>(non_empty[0])\n{\n    ...\n}\n```\n\nThis relies on \"let chains\" in `if` conditions. Ensure the project's MSRV supports it; otherwise this is a build breaker.\n\n**Action:** Confirm MSRV (Cargo.toml / docs). If MSRV is below the stabilization version, revert to the nested `if` form.\n\n## Minor improvements (quality / robustness)\n\n### A) Normalize OR-Set state on parse (defensive correctness)\nBoth labels and deps rebuild OR-Set state via `OrSet::from_parts(...)`, which does **not** enforce invariants (e.g., pruning dots dominated by `cc`, resolving dot collisions). That's OK for trusted canonical commits, but it's brittle against:\n- corrupted-but-JSON-valid commits (especially if checksums are bypassed as noted above),\n- future format changes, or\n- manually edited repos.\n\n**Suggestion:** Add a `normalize()` step (or construct via `OrSet::join(&OrSet::new(), &set)`) to ensure:\n- dominated dots are pruned,\n- collisions are resolved deterministically.\n\n### B) `verify_store_checksums` should not contain an `expect(...)`\n```rust\nlet actual_notes = actual.notes.expect(\"notes checksum missing\");\n```\n\nIt's safe today because you always compute with `Some(notes_bytes)` in this function, but it's an avoidable panic path.\n\n**Suggestion:** Replace with a normal error if `actual.notes.is_none()` (or compute `actual_notes` directly in the scope where it's needed).\n\n### C) Spec/design drift: `deps.jsonl` OR-Set is a single JSON object line\nThe design doc slice suggests a JSONL shape with a `cc` line and per-edge lines. Current implementation writes a single `WireDepStore` JSON object with an `entries` array. This is still deterministic, but it:\n- makes diffs noisier (any dep change rewrites the whole blob),\n- weakens the literal interpretation of SPEC §5.3's \"deps.jsonl sorted by (from,to,kind)\" (since it's not \"one edge per line\" anymore).\n\n**Suggestion:** If the intent is to keep JSONL nice for diffs, consider switching `deps.jsonl` OR-Set encoding to multi-line canonical form (cc line + per-key lines), while preserving deterministic order.\n\n## What's done particularly well\n\n- Strong determinism posture: BTreeMap/BTreeSet use throughout, explicit sorting for IDs/keys/dots, and newline normalization for JSONL outputs.\n- Backward compatibility: labels can parse legacy arrays, deps can parse legacy edge-per-line JSONL, notes.jsonl is optional on read.\n- Roundtrip and property tests cover core determinism and the important \"OR-Set metadata persists even when membership is empty\" case (add then remove, cc-only state).\n\n## Next steps (actionable)\n\n1. **Make meta parsing strict** in `read_state_at_oid`: fail if `meta.json` exists but can't be parsed; if checksums exist, always verify.\n2. **Define dep ordering canonically**:\n   - either implement `Ord` for `DepKind` by `as_str()`, or\n   - document enum-order as canonical and add a regression test for ordering.\n3. **Confirm MSRV** supports `if let` chains; otherwise revert the refactor.\n4. (Optional but recommended) **Normalize OR-Set on parse** to prevent accepting invalid OR-Set states.\n5. Consider whether `deps.jsonl` should move to **multi-line OR-Set encoding** for better diffs and clearer compliance with SPEC §5.3 ordering language.","id":"bd-ogvs.4","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Segment 4: Git Wire Format review","type":"task"}
