{"_at":[1768289549636,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] All mutation handlers use the events-first pipeline (plan -> WAL append -> apply_event).\n- [ ] Idempotent retry returns prior txn_id/event_ids without writing a new event.\n- [ ] Watermarks advance only after apply_event completes.","assignee":"darin@darinsmacstudio.lan","created_at":[1768177859800,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nPhase 4: integrate the events first mutation pipeline in the daemon. Current `src/daemon/executor.rs` mutates CanonicalState directly and writes snapshot WAL. We need WAL append plus deterministic apply_event and watermark updates.\n\n**Context**\n- REALTIME_PLAN.md §8.3 (apply pipeline) and §6.5 (crash consistency ordering)\n- StoreRuntime integration in §7.1\n**Files:** src/daemon/executor.rs, src/daemon/core.rs, src/daemon/store_runtime.rs, src/daemon/wal/mod.rs, src/daemon/query.rs","design":"**Design**\n- Replace direct mutation calls with: MutationEngine -> EventWal append -> core::apply_event -> update indexes and watermarks -> schedule replication and checkpoint.\n- Enforce idempotency via WAL index lookup before creating a new event when client_request_id is present.\n- Persist HLC state and idempotency mapping in the same WAL append critical section.\n- Ensure responses are returned only after apply and watermark updates complete.","id":"bd-3m5.13","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 4: Daemon events first mutation pipeline","type":"task"}
{"_at":[1768481431340,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768444192878,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nREALTIME_PLAN §0.2 recommends updating store.lock last_heartbeat_ms periodically while holding the lock. StoreLock::update_heartbeat exists but is never called, so lock metadata becomes stale immediately.\n\nEvidence:\n- src/daemon/store_lock.rs defines update_heartbeat, but no call sites (rg update_heartbeat).\n\n**Why this violates plan**\nHeartbeat is the intended staleness signal for operators. Without updates, bd store unlock cannot reliably distinguish live vs stale locks.\n\n**Acceptance**\n- [ ] Add periodic heartbeat updates (e.g., in daemon run loop every ~10s).\n- [ ] Heartbeat failures are logged but do not crash daemon.","id":"bd-3m5.87","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Store lock heartbeat never updated","type":"bug"}
{"_at":[1768622525969,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622525969,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIssues need time estimates for planning. Go beads has `EstimatedMinutes` field but beads-rs doesn't expose it in CLI.\n\n**Design**\nAdd `--estimate` / `-e` flag to `bd create` and `bd update`:\n- Value: integer in minutes (e.g., 60 for 1 hour)\n- Validation: must be non-negative\n- Storage: `estimated_minutes` INTEGER column (already exists in schema from Go beads migration)\n- Display: show in `bd show` and `bd list --pretty` as human-readable duration (e.g., \"1h 30m\")\n\nExamples:\n```bash\nbd create \"Fix auth bug\" --estimate 90           # 1.5 hours\nbd update bd-abc123 --estimate 120               # 2 hours\nbd show bd-abc123  # shows \"Estimate: 2h\"\n```\n\n**Database Schema**:\nAlready exists in types from Go beads:\n```rust\npub struct Bead {\n    // ...\n    pub estimated_minutes: Option<i32>,\n}\n```\n\n**Display Format**:\n- < 60 min: \"30m\"\n- >= 60 min: \"1h 30m\"\n- bd list --pretty: show estimate in muted color after title\n\nReference: `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/types/types.go` line 34\n\n**Design Notes**\n- Use chrono::Duration for time calculations\n- Helper function: `format_duration(minutes: i32) -> String`\n- Optional field - not required for issue creation\n- Show in show/list output only if set (not all issues need estimates)\n\n**Acceptance**\n- [ ] --estimate/-e flag on bd create\n- [ ] --estimate/-e flag on bd update\n- [ ] Validation: non-negative integers only\n- [ ] Storage in estimated_minutes column\n- [ ] Display in bd show (human-readable: \"1h 30m\")\n- [ ] Display in bd list --pretty (muted, after title)\n- [ ] Helper: format_duration(minutes) → \"Xh Ym\"\n\n**Files:**\n- `src/cli/create.rs`\n- `src/cli/update.rs`\n- `src/cli/show.rs`\n- `src/cli/list.rs`\n- `src/cli/time_format.rs` (new - duration formatting)","id":"bd-ze0x.43","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"open","title":"Estimate field for time tracking","type":"feature"}
{"_at":[1768622410584,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622410584,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nGo beads supports `bd duplicate <id> --of <canonical>` to mark an issue as a duplicate and automatically close it. This is essential for large databases with many similar reports. beads-rs needs this.\n\n**How it works in Go beads**\n- Command: `bd duplicate <id> --of <canonical>` (in cmd/bd/duplicate.go)\n- Uses `DepDuplicates` dependency type\n- Automatically closes the duplicate issue\n- Close reason references the canonical issue\n- Stored in dependencies table (per Decision 004: Edge Schema Consolidation)\n\n**Design for Rust**\n1. Add `Duplicates` variant to `DepKind` enum in src/core/domain.rs\n2. Mark it as non-DAG-enforcing (informational link)\n3. Add CLI command: src/cli/commands/duplicate.rs\n   - `bd duplicate <id> --of <canonical>`\n   - Validates canonical issue exists\n   - Rejects self-duplication (id == canonical)\n   - Creates duplicates edge\n   - Closes duplicate issue atomically\n4. Wire through daemon IPC for atomic operation (add dep + close)\n5. Add to CLI command tree\n\n**Design considerations**\n- Atomicity: dependency + closure must be atomic\n- Should we allow closing already-closed duplicates? (Go allows it)\n- Close reason should reference canonical ID\n- Prevent duplicate-of-duplicate chains? (Go doesn't enforce this)\n- What if canonical is itself a duplicate? (follow chain to root?)\n\n**Design questions for human review**\n- Should duplicate edges be unidirectional or bidirectional?\n  * Go: unidirectional (duplicate -> canonical)\n  * Benefit: canonical can list \"all duplicates of me\"\n- Should we auto-cascade when canonical is closed?\n  * Or keep duplicates independent?\n- Display strategy: show \"duplicate of X\" in bd show/list?\n\n**Files to study**\n- tmp/beads/cmd/bd/duplicate.go - Go implementation\n- tmp/beads/internal/types/types.go - DepDuplicates type\n- src/core/bead.rs - bead workflow and closure semantics\n\n**Acceptance**\n- [ ] Duplicates added to DepKind enum\n- [ ] bd duplicate command creates edge and closes issue\n- [ ] Self-duplication rejected\n- [ ] Canonical issue validated to exist\n- [ ] JSON output format matches Go beads\n- [ ] Cargo fmt, clippy, test pass","id":"bd-ze0x.8","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":12022866925484701339,"replica":"bce7a2d2-0dbc-975f-a698-a0887f96ea33"}]}},"priority":2,"status":"open","title":"Add duplicate command for deduplication links","type":"feature"}
