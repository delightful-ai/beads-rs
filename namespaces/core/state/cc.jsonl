{"_at":[1768362718810,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Daemon startup wires replication server + manager and registers channels to the coordinator.\n- [ ] Inbound replication events reach the coordinator through bounded queues and produce ACKs.\n- [ ] Outbound sessions receive events via broadcaster or WAL range fallback.\n- [ ] Overload path rejects replication ingest (no unbounded buffering).","assignee":"darin@book","created_at":[1768177897263,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nThis bead is now the integration glue for replication runtime. Sessions/manager/server are split into separate beads; we need to wire them into the daemon coordinator with bounded channels, correct defaults, and backpressure so replication traffic is serialized safely.\n\n**Context**\n- REALTIME_PLAN.md sections 7.5, 9.1-9.8, 7.2 (store runtime wiring)\n- Split beads: bd-3m5.46 (session), bd-3m5.47 (manager), bd-3m5.48 (server)\n**Files:** src/daemon/repl/mod.rs, src/daemon/core.rs, src/daemon/run.rs\n\n","design":"**Design**\n- Add a repl module root to share wiring/config between session/manager/server.\n- On daemon startup, spawn replication server + manager threads and register bounded channels into the coordinator.\n- Route inbound replication ingest through the coordinator (WAL append + apply) and produce ACKs via session channel.\n- Route outbound fanout from EventBroadcaster (with WAL fallback) and enforce AdmissionController limits at ingress.\n\n","id":"bd-3m5.17","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 5: Replication runtime integration","type":"task"}
{"_at":[1768387640756,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768178867760,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nDaemon must shut down gracefully without losing durable events. Operators need tracing and metrics.\n\n**Context**\n- REALTIME_PLAN.md §16.1 (graceful shutdown, observability requirements)\n\n**Design**\n- On SIGTERM: stop accepting mutations, drain in-flight durability waits (bounded), flush WAL, close segments, exit\n- Every mutation traceable via txn_id and client_request_id\n- Replication sessions log peer identity and namespace authorization\n- Emit counters: wal_append_ok/err, wal_fsync_ok/err, apply_ok/err, repl_events_in/out, checkpoint_export_ok/err\n- Emit gauges: IPC inflight, repl queue depth, per-peer lag\n- Emit histograms: wal_append_duration, wal_fsync_duration, apply_duration, checkpoint_duration\n\n**Acceptance**\n- [ ] SIGTERM triggers graceful drain and flush\n- [ ] Metrics emitted via tracing or metrics crate\n- [ ] Tests verify no event loss on shutdown\n- [ ] Tests verify metric emission\n\n**Files:** src/daemon/core.rs, src/daemon/metrics.rs (new), Cargo.toml (tracing/metrics)","id":"bd-3m5.40","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 4: Graceful shutdown + observability metrics","type":"task"}
{"_at":[1767992854703,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] identity_handshake model is extended or a new cross-lane model added (e.g., beads_stateright_models/examples/identity_epoch_machine.rs)\n- [ ] Properties cover: no cross-store merge, no cross-epoch merge, and consistent rejection across replication/checkpoint/WAL paths (todo.md Model #6)\n- [ ] Model doc comments reference REALTIME_PLAN.md §0.1, §2.1, §9.3, and §9.10\n- [ ] Example runs via cargo run --example identity_epoch_machine (or equivalent)","assignee":"darin@darinsmacstudio.lan","created_at":[1767985331288,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIdentity and epoch mismatch rules must be enforced consistently across replication, checkpoint import, and WAL header validation (REALTIME_PLAN.md §0.1, §2.1, §9.3, §9.10). The current identity_handshake model only covers the replication handshake path.\n\n**Design Notes**\nWe need one model or a paired model set that proves the same guardrails apply in all lanes.","design":"**Design**\nExtend or add a Stateright model that covers store_id and store_epoch gating across: (1) replication HELLO/WELCOME, (2) checkpoint import, and (3) WAL segment header validation. Model mismatches and assert hard-close or reject semantics in all lanes (Plan §9.10 error handling).\n\nReuse or build on beads_stateright_models/examples/identity_handshake.rs, but add explicit actions for checkpoint import and WAL header accept/reject. Ensure the same validation function is referenced in comments to map to the plan.","id":"bd-hjm.6","labels":{"cc":{"max":{}},"entries":{"modeling":[{"counter":7864455774641749864,"replica":"41ccd08a-99d0-74d6-06c2-123150dfbe2d"}],"realtime":[{"counter":16450275880473201191,"replica":"50147b59-cadd-6b3f-0c34-e76f6ff1da1f"}],"stateright":[{"counter":15338259604251052376,"replica":"58a0ee78-75be-6538-1536-172a35fd5954"}]}},"priority":2,"status":"closed","title":"Stateright: store identity + epoch guardrails across lanes","type":"feature"}
{"_at":[1767999215864,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1765744960969,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`git/wire.rs` repeatedly does `String::from_utf8(bytes.to_vec())` for blobs. Avoidable copy.\n\n**Design**\nUse `std::str::from_utf8(bytes)?` and parse from the slice, or stream JSONL via `serde_json::Deserializer`.\n\nNot a moral issue, just free perf + less churn.\n\n**Acceptance**\n- [ ] No unnecessary `.to_vec()` in blob parsing\n- [ ] Benchmark shows improvement (or at least no regression)\n\n**Files:** src/git/wire.rs","id":"bd-oe8","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Wire parsing does extra allocations","type":"chore"}
{"_at":[1765786005799,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@dusk","closed_reason":"Added serde boundary validation via try_from/into for BeadId, ActorId, NoteId, and Priority. Invalid values now fail at deserialization rather than scattered through handlers. Added 6 tests for the new validation behavior.","created_at":[1765744322054,0],"created_by":"darin@darinsmcstudio2.lan","description":"Use `#[serde(try_from, into)]` to validate at deserialization boundary instead of scattered runtime checks.\n\n**Problem:** These types use `#[serde(transparent)]` which accepts any value, then validation happens later in handlers.\n\n**Solution:** Follow the `BranchName` pattern (identity.rs:363-416):\n```rust\n#[serde(try_from = \"String\", into = \"String\")]\npub struct BeadId(String);\n\nimpl TryFrom<String> for BeadId {\n    type Error = CoreError;\n    fn try_from(s: String) -> Result<Self, Self::Error> {\n        Self::parse(&s)\n    }\n}\n\nimpl From<BeadId> for String {\n    fn from(id: BeadId) -> String { id.0 }\n}\n```\n\nApply to: BeadId, ActorId, NoteId, Priority (use `try_from = \"u8\"` for Priority).\n\n**Impact:** Invalid IDs fail at deserialization rather than scattered through handlers. Request types can use `BeadId` directly instead of `String`.\n\n**Files:** src/core/identity.rs, src/core/domain.rs","id":"bd-y8x","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Add serde boundary validation for identity types (BeadId, ActorId, NoteId, Priority)","type":"chore"}
{"_at":[1768813798462,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768774749674,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nCLI logs/errors don’t carry command context, making it hard to correlate failures with user commands or repos.\n\n**Design**\n- Wrap `cli::run` in a `tracing::info_span!(\"cli_command\", command = ..., repo = ...)` in `src/bin/main.rs` or `src/cli/mod.rs`.\n- Extract command name and repo (if present) from `cli::Args`.\n\n**Acceptance**\n- [ ] CLI errors are emitted within a `cli_command` span that includes command + repo fields.\n- [ ] No behavior change for stdout/stderr output.\n\n**Files:** src/bin/main.rs, src/cli/mod.rs","id":"bd-z9oc","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Observability: CLI command span + context","type":"chore"}
{"_at":[1768622514230,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622514230,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n\nGo beads has async coordination gates that block workflow steps until conditions are met. Gate evaluation commands check gate conditions and auto-close resolved gates.\n\nMissing from beads-rs:\n- `bd gate list` - List open gates\n- `bd gate check` - Evaluate gates and close resolved ones\n- `bd gate resolve` - Manually close a gate\n- `bd gate show` - Show gate details\n- Gate type filtering (--type=gh:run, gh:pr, timer, bead)\n- Auto-discovery of GitHub run IDs by workflow name\n\nGate types (from gate.go):\n- human: Requires manual bd close\n- timer: Expires after timeout\n- gh:run: Waits for GitHub Actions workflow\n- gh:pr: Waits for PR merge\n- bead: Waits for cross-rig bead to close\n\n**Design**\n\nImplement gate evaluation commands using the gate bead infrastructure.\n\nCommands:\n\n1. `bd gate list` - List gates\n   - `--all` - Include closed gates\n   - `--limit=N` - Limit results\n   - Filter: type=gate, exclude status=closed (unless --all)\n\n2. `bd gate check` - Evaluate and auto-close gates\n   - `--type=<type>` - Filter by gate type (gh, gh:run, gh:pr, timer, bead, all)\n   - `--dry-run` - Show what would happen without changes\n   - `--escalate` - Escalate failed/expired gates\n   - `--limit=N` - Limit gates to check\n\n3. `bd gate resolve <id>` - Manually close a gate\n   - `--reason=<text>` - Provide close reason\n   - Equivalent to `bd close <id>` but gate-specific\n\n4. `bd gate show <id>` - Show gate details\n   - Display: await_type, await_id, timeout, waiters, status\n   - Validates issue is type=gate\n\nGate evaluation logic (from gate.go checkGHRun, checkGHPR, checkTimer, checkBeadGate):\n\n**gh:run gates:**\n- Query: `gh run view <run-id> --json status,conclusion`\n- Resolved: status=completed AND conclusion=success\n- Escalated: status=completed AND conclusion in (failure, canceled)\n- Auto-discovery: If await_id is workflow name (non-numeric), query most recent run\n\n**gh:pr gates:**\n- Query: `gh pr view <pr-id> --json state,merged`\n- Resolved: state=MERGED\n- Escalated: state=CLOSED AND merged=false\n\n**timer gates:**\n- Resolved: now > created_at + timeout\n- Never escalated (just expire)\n\n**bead gates:**\n- Format: await_id = \"<rig>:<bead-id>\" (e.g., \"gastown:gt-abc123\")\n- Resolved: target bead status=closed\n- Query cross-rig database (routing.ResolveBeadsDirForRig)\n\nAuto-discovery for gh:run (from discoverRunIDByWorkflowName):\n```rust\n// If await_id is workflow name hint (non-numeric):\n// 1. Query: gh run list --workflow=<name> --json=databaseId,status --limit=5\n// 2. Take most recent run (first in list)\n// 3. Update gate's await_id with discovered run ID\n```\n\nImplementation files:\n- `src/cli/gate/list.rs` - List gates command\n- `src/cli/gate/check.rs` - Gate evaluation command\n- `src/cli/gate/resolve.rs` - Manual gate resolution\n- `src/cli/gate/show.rs` - Show gate details\n- `src/daemon/ops.rs` - Gate evaluation operations\n- `src/daemon/gate_eval.rs` - Gate type-specific evaluation logic\n- `src/daemon/github.rs` - GitHub CLI integration (gh run view, gh pr view)\n\n**Design Notes**\n\nGate evaluation requires external tools:\n- `gh` CLI for GitHub gates (gh:run, gh:pr)\n- Cross-rig database access for bead gates\n- Local time for timer gates\n\nError handling:\n- gh CLI not found → skip GitHub gates, warn user\n- gh CLI auth issues → report error but don't crash\n- Cross-rig database not found → warn but continue\n\nDry-run mode (--dry-run):\n- Show what would happen without making changes\n- Format: \"✓ bd-abc: would resolve - workflow 'CI' succeeded\"\n\nEscalation (--escalate):\n- Failed/expired gates can be escalated to create alerts\n- Call `gt escalate` if available (Gas Town integration)\n- Optional feature, not required for core functionality\n\n**Acceptance**\n\n- [ ] `bd gate list` shows open gates with type, await_id, timeout\n- [ ] `bd gate list --all` includes closed gates\n- [ ] `bd gate check` evaluates all open gates\n- [ ] `bd gate check --type=gh:run` filters to GitHub run gates\n- [ ] `bd gate check --dry-run` shows evaluation results without changes\n- [ ] gh:run evaluation queries GitHub Actions and closes on success\n- [ ] gh:pr evaluation queries PRs and closes on merge\n- [ ] timer evaluation checks created_at + timeout\n- [ ] bead evaluation checks cross-rig bead status\n- [ ] Auto-discovery for gh:run with workflow name hint\n- [ ] `bd gate resolve <id>` manually closes a gate\n- [ ] `bd gate show <id>` displays gate details\n- [ ] Tests for gate evaluation logic (mock gh CLI responses)\n- [ ] Integration test for full gate workflow\n\n**Files:**\n- src/cli/gate/list.rs\n- src/cli/gate/check.rs\n- src/cli/gate/resolve.rs\n- src/cli/gate/show.rs\n- src/daemon/ops.rs\n- src/daemon/gate_eval.rs\n- src/daemon/github.rs","id":"bd-ze0x.39","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":15418253163362231119,"replica":"f3ab63b8-25f6-ce1c-02fc-da24d85b383d"}]}},"priority":2,"status":"open","title":"Gate evaluation commands (bd gate check, list, resolve)","type":"feature"}
