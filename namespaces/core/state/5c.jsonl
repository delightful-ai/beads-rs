{"_at":[1768903984173,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] CanonicalState compiles with new stores\n- [ ] Dep indexes update correctly on add/remove\n- [ ] Orphan labels/notes/deps persist without errors\n\n**Invariants to re-verify**\n- [ ] dep_indexes reflect DepStore membership (no stale edges)\n- [ ] Orphan labels/notes/deps persist but are not surfaced for missing beads\n- [ ] Bead no longer stores labels/notes","assignee":"darin@book","created_at":[1768894651197,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nCanonicalState embeds LWW labels, LWW dep edges, and notes in Bead. We need OR-Set stores and orphans.\n\n**Files**\n- src/core/state.rs\n- src/core/collections.rs (if helpers live here)","design":"Add new stores:\n- LabelStore { by_bead: BTreeMap<BeadId, LabelState{set:OrSet<Label>, stamp:Stamp}> }\n- DepStore { set: OrSet<DepKey>, stamp: Stamp }\n- NoteStore { by_bead: BTreeMap<BeadId, BTreeMap<NoteId, Note>> }\nProvide helpers:\n- labels_for(bead_id)\n- apply_label_add/remove\n- apply_dep_add/remove (update dep_indexes)\n- insert_note / notes_for\nEnsure orphans are allowed and stamps update only on membership change.","id":"bd-3zoj.3","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"CanonicalState: LabelStore/DepStore/NoteStore","type":"task"}
{"_at":[1768448823211,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Unknown keys in EventBody are ignored (no `InvalidField` error).\n- [ ] Unknown keys in `hlc_max` are ignored while still requiring `actor_id`, `physical_ms`, `logical`.\n- [ ] Tests cover forward-compat decode for both top-level and `hlc_max`.","closed_reason":"duplicate of bd-3m5.84","created_at":[1768444158887,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`decode_event_body_map` rejects unknown keys with `InvalidField` instead of skipping them. This makes EventBody strictly closed and blocks forward-compatible changes to realtime payloads. The plan explicitly removed unknown-key *byte preservation* but did not require rejecting unknown keys; we should accept and ignore them while preserving raw bytes.\n\n**Signals / Evidence**\n- `decode_event_body_map` returns `InvalidField` on any unknown key (`src/core/event.rs`).\n- `decode_event_hlc_max` similarly errors on unknown keys inside `hlc_max`.\n- `verify_event_frame` relies on `decode_event_body`; rejection becomes `invalid_request` or `non_canonical`, making minor forward-compatible additions fatal.\n\n**Why this hurts velocity**\nAny new field in EventBody becomes a coordinated, lockstep upgrade across all replicas and clients. Thatâ€™s brittle and slows rollout.","design":"**Design**\n- Change `decode_event_body_map` to `dec.skip()` unknown keys instead of error.\n- Do the same for `hlc_max` (ignore unknown keys; still require required fields).\n- Keep existing required-field checks and limits.\n- Add tests: decoding succeeds with an extra unknown key at top-level and inside `hlc_max`, and hash verification still uses the raw bytes.","id":"bd-k67","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"EventBody decode is too strict (unknown keys break forward compat)","type":"bug"}
