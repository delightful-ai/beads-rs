{"_at":[1770500471321,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Surface fsck API exists and is typed\n- [ ] CLI fsck path uses surface API\n- [ ] No daemon WAL internals imported by CLI","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1770498234324,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nCLI store fsck uses daemon WAL internals directly.","design":"Provide surface function for offline fsck with typed options/result backed by `beads-api` admin output structs.","id":"bd-21eg.13","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Add surface offline fsck API returning beads-api output types","type":"feature"}
{"_at":[1768266096090,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Mutation request structs add optional namespace/durability/client_request_id/actor_id with backward-compatible defaults.\n- [ ] Read/query request structs add optional require_min_seen + wait_timeout_ms with consistent defaulting.\n- [ ] CLI flags --namespace, --durability, --client-request-id map to IPC fields.\n- [ ] Defaulting (namespace=core, durability=LocalFsync, actor_id=daemon default) is applied consistently.","assignee":"darin@darinsmacstudio.lan","created_at":[1768178967608,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIPC currently has no namespace, durability class, or client_request_id fields, and defaults are implemented ad hoc in CLI/daemon. This makes retries and read-your-writes semantics ambiguous and invites mismatched defaults across entry points.\n\n**Context**\n- REALTIME_PLAN.md §0.14 (IPC evolution) and §16.1 (request fields and defaults)\n- Stateright model: beads_stateright_models/src/realtime_types_sketch.rs (NamespaceId, DurabilityClass, Seq0/Seq1)\n\n**Files:** src/daemon/ipc.rs, src/api/mod.rs, src/cli/mod.rs, src/cli/commands/*, src/daemon/query.rs","design":"**Design**\n- Extend mutation request structs with optional fields: namespace, durability, client_request_id, actor_id, preserving backward compatibility.\n- Parse namespace into NamespaceId and client_request_id into ClientRequestId early, so validation happens before mutation planning.\n- Centralize defaulting rules in one place (e.g., Request::normalize): namespace defaults to core, durability defaults to LocalFsync, actor_id defaults to daemon actor.\n- Add read/query gating fields require_min_seen and wait_timeout_ms; require_min_seen uses applied watermarks and returns retryable timeout error on miss.\n- Ensure IPC JSON schema stays stable: new fields are optional and omitted in serialization when None.","id":"bd-3m5.51","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 4: IPC namespace + durability + client_request_id fields","type":"task"}
{"_at":[1768824239016,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- expected bool replaced by enum\\n- call sites updated\\n- cargo check, cargo clippy -D warnings, cargo test pass","assignee":"darin@book","created_at":[1768824022644,0],"created_by":"darin@darinsmcstudio2.lan","description":"tests/integration/fixtures/repl_rig.rs wait_for_durability_eligible takes expected: bool. Replace with a typed enum to encode expected eligibility state and update call sites.","id":"bd-ccs1","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Replace repl rig durability expected bool with enum","type":"chore"}
{"_at":[1768799705359,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768777372081,0],"created_by":"darin@darinsmcstudio2.lan","description":"tests/integration/fixtures/repl_rig.rs wait_for_show spawns bd show in a poll loop. Use IpcClient Request::Show with ReadConsistency { require_min_seen, wait_timeout_ms } based on create receipts (min_seen) to block once instead of sleep/poll. Should reduce E2E repl test time + flake risk.","id":"bd-lzsu","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Repl rig wait_for_show uses CLI polling; switch to IPC read gating","type":"chore"}
{"_at":[1769559413844,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1769197304799,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Segment:** crdt/1-foundation (bd-3zoj.1, bd-3zoj.2)\n**Files:** src/core/orset.rs, src/core/store_meta.rs, src/daemon/store/runtime.rs\n**RepoPrompt chat:** or-set-review-369869\n\n---\n\n## Summary\n\nThis segment introduces a foundational **OR-Set (ORSWOT-style)** implementation in `src/core/orset.rs` with:\n\n- `Dot { replica, counter }` and `Dvv { max: Map<ReplicaId, u64> }`\n- `OrSet<V>` storing `entries: Map<V, Set<Dot>>` plus a causal context `cc: Dvv`\n- `apply_add`, `apply_remove`, and a state-based `join`/`merge`\n- deterministic dot-collision resolution (\"higher value wins\", with a hash fallback)\n- unit tests for DVV dominance, `join` commutativity/idempotence, dominance pruning, and collision resolution\n\nContext files indicate the dot-counter plumbing is also in place:\n- `StoreMeta` persists `orset_counter` (`#[serde(default)]`)\n- `StoreRuntime::next_orset_counter()` increments + writes meta and is covered by a persistence test\n\n## Critical issues (must address)\n\n### 1) **Current `Dvv`/`cc` pruning makes removals delete unrelated values (semantic break)**\nThe invariant \"no dots dominated by `cc` after ops\" is enforced via `prune_dominated()`, **but with `Dvv` implemented as only a per-replica max counter, this turns `cc` into an over-approximate tombstone**.\n\nConcretely: any remove that merges a context with `max[r] = c` makes *all dots from replica `r` with counter ≤ c* dominated and therefore pruned — including dots belonging to **other values**.\n\nMinimal failing scenario (this should be a unit test and currently fails with this implementation):\n\n```rust\n#[test]\nfn remove_does_not_remove_other_values_from_same_replica() {\n    let mut set = OrSet::new();\n    let d1 = dot(1, 1);\n    let d2 = dot(1, 2);\n\n    set.apply_add(d1, \"a\".to_string(), Sha256([0; 32]));\n    set.apply_add(d2, \"b\".to_string(), Sha256([0; 32]));\n\n    let mut ctx = Dvv::default();\n    ctx.observe(d2);\n    set.apply_remove(&\"b\".to_string(), &ctx);\n\n    assert\\!(set.contains(&\"a\".to_string())); // should hold, currently pruned\n    assert\\!(\\!set.contains(&\"b\".to_string()));\n}\n```\n\nThis is not an edge case — labels/deps will routinely have multiple values added by the same replica with increasing counters, so \"remove one label wipes earlier labels from the same author\" is catastrophic.\n\n**Design implication:** As written, the CRDT is not an OR-Set for multi-element sets; it behaves more like \"per-replica GC-floor\" for all earlier dots.\n\n#### What to do\nYou likely need to change *either* the representation *or* the merge rule:\n\n- **Option A (recommended if you truly mean ORSWOT):** make `cc` an *observed clock* (version vector) and implement the standard ORSWOT merge rule that filters dots using *the other side's clock and presence/absence*, not \"drop anything dominated by merged cc\". This avoids the \"remove b removes a\" failure because presence of `a`'s dot on the removing replica prevents it from being treated as removed.\n- **Option B (tombstone-style OR-Set):** `cc` must be able to represent **arbitrary sets of removed dots**, not just a per-replica max. That implies a \"dot cloud\" / exception set (true dotted version vectors) or explicit tombstones. A plain max-per-replica vector cannot represent \"removed dot (r,2) but keep dot (r,1) alive\".\n\nRight now, `CRDT_OVERHAUL.md` describes `Dvv` exactly as \"max per replica\" *and* describes pruning by merged cc — those two combined create the bug above. Either the spec needs adjustment, or this code needs to move to the correct ORSWOT rule.\n\n### 2) `OrSet::join` commutative/idempotent tests are insufficient given the above\nThe provided commutative/idempotent test covers only disjoint replicas/values. Because of the pruning issue, you can still satisfy commutativity/idempotence while being semantically wrong.\n\nAdd targeted tests around:\n- two values added by the same replica + remove one value\n- join across replicas where one side's `cc` is advanced by removing one element but the other element must remain\n\n### 3) \"Durable\" dot counter: meta writes aren't crash-safe\n`StoreRuntime::next_orset_counter()` persists by rewriting JSON via `fs::write`. This is:\n- not atomic (crash during write can truncate/corrupt)\n- not fsync'd (power loss can roll back the counter)\n\nGiven the design intent (\"holes OK, reuse not\"), **counter rollback risks dot reuse**, which then triggers dot collisions and data loss by deterministic collision winner.\n\nIf you need \"durable across crashes/power loss\", consider:\n- write-to-temp + `rename` atomic swap\n- directory + file fsync, or store counter in a more crash-resilient store (sqlite / WAL)\n- at minimum: atomic replace to avoid truncated JSON\n\n## Minor improvements\n\n- **Layering / dependency hygiene:** `orset.rs` depends on `super::event::Sha256` only for the `_op_hash` argument, but doesn't use it. For a \"Layer 3\" CRDT primitive, importing from `event` risks future cycles once wire/event code starts depending on OR-Set types. Consider:\n  - remove `_op_hash` until needed, or\n  - accept `[u8; 32]` directly, or a small hash type defined in a lower layer.\n- **Collision hash tie-break is effectively dead code** under correct `Ord/Eq`:\n  - dot collision means different values ⇒ `left.cmp(right) \\!= Equal`, so hash fallback won't run.\n  - If you want the spec's `(value, sha256(dot||value))` literally, it's fine, but acknowledge the hash won't matter unless `Ord` is violated.\n- **Missing accessor(s) needed by design:** the spec's remove planning needs the current dots per value. `entries` is private and there's no `dots_for(value)` / `ctx_for(value)` helper yet. That's likely needed soon.\n\n## What's done well\n\n- Clear module-level docs and a readable API surface (`apply_add`, `apply_remove`, `join`, `merge`).\n- Determinism-friendly data structures (`BTreeMap`/`BTreeSet`).\n- Explicit dot-collision resolution logic exists and is deterministic.\n- Store-side dot counter persistence is implemented with a straightforward test showing persistence to disk.\n\n## Actionable next steps\n\n1. **Resolve the core semantic issue:** decide whether this is ORSWOT (recommended) or tombstone OR-Set, then adjust `Dvv` and `OrSet::join` accordingly.\n2. Add a **unit test that removing one value does not remove other values from the same replica** (the example above).\n3. Add a **join test** that exercises the same scenario across replicas (one side removes one value; the other value must survive join).\n4. Decide whether `orset.rs` should depend on `event::Sha256`; remove or refactor `_op_hash` to avoid layer coupling.\n5. If \"durable counter\" is a hard requirement, harden `write_store_meta` to be atomic/fsync-safe to prevent counter rollback and dot reuse.\n\n---\n\n**UPDATE:** Later segments (crdt/4-git-wire+) add `dots_for()` accessor and tests for add-wins semantics (`orset_add_wins_over_remove_ctx`, `orset_join_preserves_concurrent_add`). The critical issue #1 may already be addressed - needs manual verification.","id":"bd-ogvs.1","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Segment 1: OR-Set Foundation review","type":"task"}
{"_at":[1769583834758,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769495940597,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`ProtocolRange::new(min, max)` does not enforce `min <= max`. This allows constructing invalid ranges that only fail later at negotiation. It’s a typestate gap: the type claims to be a range but permits impossible states.\n\nKey references:\n- `crates/beads-rs/src/daemon/repl/session.rs:44` — `ProtocolRange` + `new`.\n- `crates/beads-rs/src/daemon/repl/session.rs:71` — `SessionConfig::new` constructs ranges.\n\n**Design**\nEncode the invariant in the type.\n\n- Make `ProtocolRange::new` return `Result<Self, ProtocolRangeError>` and validate `min <= max`.\n- Add helpers: `ProtocolRange::exact(v)` and `ProtocolRange::range(min, max)`.\n- Consider `NonZeroU32` for versions if 0 is invalid.\n- Update session config construction and any tests to use the validated constructor.\n\n**Acceptance**\n- [ ] It is impossible to construct a `ProtocolRange` with `min > max`.\n- [ ] All call sites use `ProtocolRange::exact` or validated `new`.\n- [ ] Tests cover invalid ranges (min>max) and valid exact-range negotiation.\n\n**Files**\n- `crates/beads-rs/src/daemon/repl/session.rs`","id":"bd-qrjo","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Enforce protocol range invariants in type","type":"bug"}
{"_at":[1768622459363,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622459363,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n\nGo beads has StatusHooked for tracking work that's actively assigned to an agent's hook. This is part of the GUPP (Gas Unified Polecat Protocol) agent coordination system.\n\nMissing from beads-rs:\n- StatusHooked workflow status\n- hook_bead field on Issue (0..1 cardinality)\n- Hook/unhook commands\n- Display icon and color\n\nHooked vs InProgress:\n- InProgress: Human or agent claimed the work (assignee set)\n- Hooked: Agent has work on its hook (active execution, one at a time)\n\nThis is primarily for Gas Town agent swarms but should be supported in core beads-rs for compatibility.\n\n**Design**\n\nAdd StatusHooked variant to Status enum and hook_bead field to Bead struct.\n\nFields (from types.go):\n- status: StatusHooked\n- hook_bead: string (optional) - Current work on agent's hook (0..1 cardinality)\n\nCommands:\n- `bd hook [id]` - Set status to hooked (for current agent)\n- `bd unhook [id]` - Clear hooked status, restore to in_progress or open\n\nStatusHooked behavior:\n- Shows work is actively being executed by an agent\n- Only one bead can be hooked per agent at a time\n- Agent field tracking which agent has the work\n- Excluded from `bd ready` for other agents\n\nDisplay (from ui/styles.go):\n- Icon: (use same as in_progress or custom)\n- Color: Cyan (#59c2ff) - actively worked by agent\n- Style: `StatusHookedStyle.Render()`\n\nImplementation files:\n- `src/core/workflow.rs` - Add StatusHooked variant\n- `src/core/lww.rs` - Add hook_bead field as Lww<Option<String>>\n- `src/cli/hook.rs` - Hook command (optional, may not be needed for non-agent use)\n- `src/cli/unhook.rs` - Unhook command\n- `src/daemon/ops.rs` - Hook/unhook operations\n- `src/cli/list.rs` - Display hooked status with color\n\n**Design Notes**\n\nThis is primarily a Gas Town feature but lives in core beads. beads-rs should:\n1. Support the status and field for compatibility\n2. Implement basic hook/unhook commands\n3. Not implement full agent swarm logic (that's in Gas Town)\n\nThe hook_bead field creates a bidirectional link:\n- Agent bead → hook_bead: \"current work\"\n- Work bead → status: StatusHooked\n\nStatusHooked is distinct from StatusPinned:\n- Hooked: Temporary, active execution state\n- Pinned: Permanent, context marker\n\nConsider whether hook/unhook commands are needed in beads-rs or if this is just for migration/compatibility. May defer command implementation to later.\n\n**Acceptance**\n\n- [ ] Status enum has StatusHooked variant\n- [ ] Bead struct has hook_bead field (Lww<Option<String>>)\n- [ ] StatusHooked displays with appropriate icon/color\n- [ ] Migration handles StatusHooked from Go beads export\n- [ ] Tests for hooked status serialization\n- [ ] (Optional) `bd hook` and `bd unhook` commands\n\n**Files:**\n- src/core/workflow.rs\n- src/core/lww.rs\n- src/cli/list.rs (display)\n- src/migrate/go_export.rs (migration)","id":"bd-ze0x.23","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":2618760728762356244,"replica":"fd18a198-0db8-df1b-3776-eb192099fe05"}]}},"priority":3,"status":"open","title":"Hooked status for agent work assignment (GUPP)","type":"feature"}
