{"_at":[1769554717107,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] It is impossible to construct `Observer + eligible=true` at compile time.\n- [ ] `ReplicaRoster::from_toml_str` rejects invalid role/eligibility combos with a clear error.\n- [ ] `DurabilityCoordinator::eligible_replicas` uses the typed role/eligibility (no raw bool).\n- [ ] Unit tests cover: valid anchor/peer entries, observer ineligible, observer eligible rejected.\n- [ ] Ordering of `replicas` remains deterministic and unchanged.\n- [ ] `cargo test` passes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769553588622,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`ReplicaEntry` stores `role: ReplicaRole` and `durability_eligible: bool` independently. `ReplicaRoster::validate()` never checks for illegal combinations (e.g. `Observer + durability_eligible=true`). This violates parse-don’t-validate and lets invalid configs enter canonical state.\n\nThe `DurabilityCoordinator::eligible_replicas` path trusts the roster; in `ReplicateMode::P2p` an observer marked eligible is counted toward durability, which can report acks that never happened. This is a safety bug and the compiler cannot help.\n\n**Impact**\n- False durability availability (observer counted toward k) in P2P mode.\n- Bad config persists and is indistinguishable from valid at compile time.\n- Future refactors can silently reintroduce eligibility bugs since there is no typed guardrail.\n\n**Files**\n- `crates/beads-core/src/replica_roster.rs` (ReplicaEntry/ReplicaRoster parse + validate)\n- `crates/beads-rs/src/daemon/durability_coordinator.rs` (eligibility derivation)\n","design":"**Design**\nMake illegal combinations unrepresentable and validate at parse boundary. Keep TOML schema stable.\n\nOption A (preferred):\n1) Introduce a typed entry that encodes role + eligibility: \n   ```\n   enum ReplicaDurabilityRole {\n     Anchor { eligible: bool },\n     Peer { eligible: bool },\n     Observer,\n   }\n   ```\n2) Replace `ReplicaEntry { role, durability_eligible }` with `ReplicaEntry { role: ReplicaDurabilityRole, ... }`.\n3) Create a `ReplicaEntryWire` for serde (role + durability_eligible bool). Implement `TryFrom<ReplicaEntryWire> for ReplicaEntry` that rejects `Observer + eligible=true` (and any future invalid combos).\n4) Update `ReplicaRoster::from_toml_str` to parse `ReplicaEntryWire`, then convert to typed entries; errors surface as `ReplicaRosterError::InvalidRoleEligibility` (new error variant).\n5) Update `DurabilityCoordinator::eligible_replicas` to use `ReplicaDurabilityRole::eligible()` and `role_allows_policy` on the typed role.\n\nOption B (acceptable if we want to keep `ReplicaRole`):\n- Replace bool with `DurabilityEligibility` and make it only constructible for non-observers: `eligibility: Option<DurabilityEligible>` or `NonObserver { role: NonObserverRole, eligibility: DurabilityEligibility }`.\n- Provide explicit constructors `ReplicaEntry::anchor(...)`, `::peer(...)`, `::observer(...)` so call sites cannot fabricate invalid states.\n\n**Parse-don’t-validate**\n- The only public entry point should be typed constructors / `TryFrom` conversion from wire.\n- After parsing, there should be no API that exposes a raw bool.\n\n**Ordering / invariants preserved**\n- Preserve deterministic ordering of `ReplicaRoster.replicas` by current ordering semantics.\n- Keep TOML fields and on-disk/IPC compatibility unchanged (wire struct handles it).","id":"bd-nh0w","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Replica roster must make durability eligibility unrepresentable for observers","type":"bug"}
