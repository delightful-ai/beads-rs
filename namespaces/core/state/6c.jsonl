{"_at":[1770500562231,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Invariant command documented\n- [ ] Command passes locally\n- [ ] Violations fail lint/check flow","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1770498233733,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nAfter cleanup we need a stable invariant, not manual spot checks.","design":"Add a checkable invariant (`rg`/lint gate) that CLI tree contains no direct daemon imports.","id":"bd-21eg.11","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Prove zero daemon imports under CLI tree","type":"task"}
{"_at":[1768182968247,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] New identity types compile and serialize/deserialize (unit tests).\n- [ ] StoreMeta matches plan fields and roundtrips via serde.\n- [ ] StoreIdentity is used where a pair is required (no duplicated store_id/store_epoch fields).\n- [ ] cargo check passes.","created_at":[1768177707912,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nThe realtime lane needs a canonical identity basis; core currently only models ActorId/BeadId/NoteId and still keys correctness by RemoteUrl. Without StoreId/ReplicaId/TxnId/ClientRequestId/StoreEpoch/SegmentId and StoreIdentity, we cannot define stable event identity, receipts, or WAL indexing.\n\n**Context**\n- REALTIME_PLAN.md 0.1 (StoreId as correctness identity), 2.1 (identity types), 15.1 (store meta file)\n- Stateright model: beads_stateright_models/src/realtime_types_sketch.rs (section 1 Identity types, StoreIdentity)\n\n**Files:** src/core/identity.rs, src/core/store_meta.rs (new), src/core/mod.rs, src/lib.rs, Cargo.toml","design":"**Design**\n- Add newtypes: StoreId, StoreEpoch, ReplicaId, TxnId, ClientRequestId, SegmentId using uuid::Uuid and serde.\n- Add StoreIdentity { store_id, store_epoch } as a separate type so the store pair is not duplicated or passed as raw fields.\n- Add StoreMeta in src/core/store_meta.rs with fields from the plan: store_id, store_epoch, replica_id, store_format_version, wal_format_version, checkpoint_format_version, replication_protocol_version, index_schema_version, created_at_ms.\n- Expose constructors and parsing helpers, plus serde roundtrip tests for each newtype and StoreMeta.\n- Re-export new types via src/core/mod.rs and src/lib.rs, and keep ActorId/BeadId/NoteId unchanged.","id":"bd-3m5.1","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 1: Core identity types + StoreMeta","type":"task"}
{"_at":[1768526585846,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] No hardcoded WAL format constants remain in test fixtures.\\n- [ ] Fixtures compile using shared constants.\\n- [ ] cargo test --test integration passes.","assignee":"darin@book","created_at":[1768509347274,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\n- tests/integration/fixtures/wal.rs hardcodes WAL_FORMAT_VERSION, SEGMENT_HEADER_PREFIX_LEN, FRAME_HEADER_LEN.\\n- tests/integration/fixtures/wal_corrupt.rs hardcodes FRAME_CRC_OFFSET/FRAME_HEADER_LEN.\\n- These constants encode the WAL wire format; if production changes, fixtures drift or encode invalid assumptions.\\n\\n**Files**\\n- tests/integration/fixtures/wal.rs\\n- tests/integration/fixtures/wal_corrupt.rs\\n- src/daemon/wal/* (source of truth)","design":"Expose canonical constants (or accessors) from WAL modules (e.g., frame header len/CRC offset, segment header prefix len, current WAL format version) as pub(crate) or pub for tests. Replace the fixture constants with imports. If no single const exists yet, add them where the format is defined and re-export as needed (tie into bd-rfit if versions are centralized).","id":"bd-ae2z","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Fixtures: centralize WAL frame/segment constants","type":"chore"}
{"_at":[1769560077072,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769201020522,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Segment:** crdt/3-wire-ops (bd-3zoj.5, bd-3zoj.6)\n**Files:** src/core/wire_bead.rs, src/core/event.rs, src/daemon/mutation_engine.rs, +10 others\n**RepoPrompt chat:** crdt-wire-ops-0FBA1A\n\n---\n\n## Summary (what this segment accomplishes)\n\nThis segment completes the \"wire ops + validation\" portion of the CRDT overhaul by:\n\n- Introducing explicit OR-Set wire operations for labels/deps (`WireLabelAdd/RemoveV1`, `WireDepAdd/RemoveV1`) based on `(dot, ctx/DVV)`.\n- Making `TxnDeltaV1` canonical + duplicate-safe via `TxnOpKey` and a `BTreeMap` storage strategy, **including dot in the key for add ops** to prevent dedup collisions.\n- Extending CBOR encode/decode in `src/core/event.rs` to support these new ops and the `WireDotV1` / `WireDvvV1` payloads.\n- Adding **D1 semantic validation** that rejects workflow/claim patches that would depend on `Keep`.\n- Updating mutation planning to mint dots for add ops, build DVV contexts for removes, and to emit workflow/claim patches that always satisfy the new D1 rules—plus validating the assembled `EventBody` before encoding.\n\nOverall, the direction and shape match `CRDT_OVERHAUL.md` and the new invariants are mostly enforced consistently across planning, validation, and apply.\n\n---\n\n## Critical issues (must address)\n\n### 1) `encode_wire_tombstone` can emit invalid CBOR in release builds\n**File:** `src/core/event.rs` (`encode_wire_tombstone`)\n\nYou compute `has_lineage` as `at.is_some() || by.is_some()` and add `+2` to the encoded map length, but only emit the fields when **both** are present. If only one is set, you hit a `debug_assert\\!`—which is compiled out in release—so you will emit a map header declaring too many entries.\n\nThat's a correctness bug that can corrupt event bytes / WAL records (and potentially break replication) if a partially-filled tombstone ever reaches encoding.\n\n**Fix suggestion (runtime, not debug-only):**\n- Either compute length based on `(Some, Some)` only:\n  ```rs\n  let has_lineage = tombstone.lineage_created_at.is_some()\n      && tombstone.lineage_created_by.is_some();\n  if tombstone.lineage_created_at.is_some() ^ tombstone.lineage_created_by.is_some() {\n      return Err(EncodeError::InvalidField { ... }); // or similar\n  }\n  ```\n- Or validate the XOR invariant before encoding and error out.\n\nAlso consider adding a semantic validation hook for tombstones (same XOR check) since mutation planning now calls `validate_event_body()` but that currently only validates bead patches.\n\n---\n\n### 2) Test fixture creates D1-invalid workflow patches\n**File:** `tests/integration/fixtures/event_body.rs` (`sample_bead_patch`)\n\nThe fixture sets:\n```rs\npatch.status = Some(WorkflowStatus::Open);\n```\n…but does **not** set `closed_reason` / `closed_on_branch`, leaving them at `Keep`.\n\nWith the new validator:\n```rs\nif patch.status.is_some() && (patch.closed_reason.is_keep() || patch.closed_on_branch.is_keep()) { ... }\n```\nthis fixture is now semantically invalid.\n\nEven if current integration tests only call `apply_event()` (and don't validate), anything that goes through `verify_event_frame` / `validate_event_body` (or new mutation-engine validation) will reject these events. This is a likely \"tests start failing later\" landmine.\n\n**Fix options:**\n- Preferred for D1 coverage: keep `status: Some(Open)` but add:\n  ```rs\n  patch.closed_reason = WirePatch::Clear;\n  patch.closed_on_branch = WirePatch::Clear;\n  ```\n- Or omit `status` entirely in the fixture (leave it `None`) if the intent is \"create-like patch\".\n\n---\n\n### 3) Potential gap: claim semantic validation allows \"unclaimed but expires set\"\n**File:** `src/core/event.rs` (`validate_bead_patch_semantics`)\n\nCurrent claim rule only enforces \"no Keep asymmetry\":\n```rs\nif assignee_keep ^ expires_keep { error }\n```\n\nThis still allows **both-not-Keep** combinations like:\n- `assignee = Clear`, `assignee_expires = Set(...)` (nonsensical)\n- `assignee = Set(...)`, `assignee_expires = Clear` (might be valid if you allow non-expiring claims)\n\nIf `build_claim()` rejects some of these, then malformed-but-decodable events can pass `validate_event_body_semantics()` and later fail during apply.\n\n**Action:** confirm intended Claim domain invariants and either:\n- tighten validation to reject impossible combos (at minimum: `assignee == Clear` implies `expires == Clear`), or\n- ensure `build_claim()` is total and treats any \"weird but explicit\" combination deterministically (no error).\n\nGiven the CRDT goal (\"apply should only fail on malformed encodings/invariant violations\"), it's better to reject at validation with a clear `EventValidationError::InvalidClaimPatch`.\n\n---\n\n## Minor improvements / quality suggestions\n\n### A) Strengthen workflow validation slightly (optional but safer)\nToday you only require \"explicit closure fields if status is touched\". Two additional checks worth considering:\n\n- Reject `closed_reason` / `closed_on_branch` patches when `status` is `None` (they're ignored by apply anyway; catching them early reduces \"silent no-op\" footguns).\n- Optionally enforce that for `status \\!= Closed`, closure patches must be `Clear` (not `Set`) to avoid weird payloads.\n\n### B) Add missing roundtrip + apply coverage for new OR-Set ops\nRight now the provided integration tests focus on notes + LWW fields. Add targeted tests for:\n\n- **CBOR** encode/decode roundtrip including:\n  - multiple `LabelAdd` for same `(bead_id,label)` with different dots (proves `TxnOpKey` dot inclusion matters)\n  - `LabelRemove` and `DepRemove` DVV contexts\n- apply idempotency/commutativity for label/dep ops:\n  - apply same `LabelAdd` twice (dot idempotency)\n  - `Remove(ctx)` then concurrent `Add(dot)` not in ctx (add-wins)\n  - `plan_set_parent` producing remove+add converges and doesn't accidentally remove the new parent dot\n\n### C) Docs drift\n`CRDT_OVERHAUL.md` still describes:\n- `WireDvvV1(Vec<(ReplicaId,u64)>)` but implementation uses a `BTreeMap` and CBOR encodes it as a map.\n- `WireDotV1 { replica_id, ... }` vs encoded key `\"replica\"`.\n\nRecommend updating the doc section so wire format expectations match the actual encoder.\n\n### D) Optional: validate dot origin\nNot required by the current spec, but for robustness: consider validating that `LabelAdd.dot.replica` / `DepAdd.dot.replica` matches `EventBody.origin_replica_id`. Otherwise a buggy/malicious replica could mint dots \"as\" another replica and disrupt DVV monotonic assumptions.\n\n---\n\n## What's done particularly well\n\n- **TxnOpKey includes dot for add ops** (`LabelAdd`, `DepAdd`): this is the correct fix for dedup collisions and aligns with the spec.\n- `TxnDeltaV1` using a `BTreeMap<TxnOpKey, TxnOpV1>` provides:\n  - canonical op ordering,\n  - stable iteration for encoding,\n  - and duplicate detection in one place.\n- CBOR decode paths are careful about:\n  - unique keys (`ensure_unique_key`),\n  - per-txn op limits,\n  - and note size constraints.\n- Mutation engine changes (close/reopen/claim/unclaim/extend_claim + status normalization) are consistent with the D1 validator, and calling `validate_event_body()` before encoding is a strong \"fail fast\" defense against accidental regression.\n\n---\n\n## Next steps (actionable)\n\n1. **Fix `encode_wire_tombstone`** to enforce lineage field pairing at runtime and to keep map length consistent in release builds.\n2. **Update `sample_bead_patch` fixture** to satisfy D1 workflow semantics (explicitly clear closure fields when `status` is set, or omit `status`).\n3. Decide on **claim invariants** and either:\n   - tighten `validate_bead_patch_semantics` to reject impossible explicit claim combos, or\n   - ensure apply is total for all explicit combinations.\n4. Add **CBOR + apply tests** covering label/dep OR-set ops (roundtrip, idempotency, add-wins behavior).\n5. Update `CRDT_OVERHAUL.md` to reflect the final on-wire encoding choices (DVV map vs vec, dot field/key names).","id":"bd-ogvs.3","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Segment 3: Wire Ops + Event Validation review","type":"task"}
{"_at":[1769223018144,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] orset.rs no longer imports event::Sha256.\\n- [ ] Public API remains stable or is migrated cleanly with tests updated.","assignee":"darin@book","created_at":[1769210188242,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\norset.rs depends on event::Sha256 even though it only uses a placeholder op_hash arg. This is a layer violation risk as event depends on OR-Set elsewhere.\\n\\n**Files**: src/core/orset.rs","design":"**Design**\\nRemove the dependency by either: (a) dropping the unused op_hash parameter, (b) accepting raw [u8;32], or (c) defining a lower-layer hash type. Ensure no cyclic dependency is created.","id":"bd-qz97.20","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Cleanup: remove orset.rs dependency on event::Sha256","type":"chore"}
