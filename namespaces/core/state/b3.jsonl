{"_at":[1768722955157,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] Either a retention/GC mechanism is implemented and tested, OR explicit guardrails are added (metrics + warnings + docs) with thresholds configurable.\n- [ ] Admin status exposes WAL size/segment growth signals.\n- [ ] Tests cover the warning/threshold behavior (deterministic, slow-test if needed).","assignee":"darin@book","created_at":[1768672341296,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWAL retention/pruning is deferred, so long-running deployments can grow without bound and we have no guardrails or operator visibility.","design":"**Design**\n- Decide on a minimal retention/GC strategy consistent with REALTIME_PLAN.md; if full pruning remains deferred, add explicit guardrails instead.\n- Guardrails: surface WAL size/segment counts + growth rate in admin status/metrics, emit warnings when thresholds are exceeded, and document the operational limits in REALTIME_PLAN.md.","id":"bd-gxnl","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Realtime: WAL retention/GC guardrails","type":"bug"}
{"_at":[1768815860615,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768815691646,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\napply_daemon_logging_defaults_inner uses bool flags (is_test_env, has_log_file_env) that encode multiple states implicitly; this is a type_design smell and makes invalid combinations possible.\n\n**Design**\nIntroduce a small enum (e.g., LoggingDefaultsMode { TestEnv, LogFileEnv, Default }) derived from environment/context and pass that through apply_daemon_logging_defaults_inner. Remove boolean params and update tests to cover the enum branches.\n\n**Acceptance**\n- [ ] bool flags replaced with enum in src/telemetry.rs\n- [ ] tests updated for the new mode mapping\n- [ ] cargo check, cargo test pass\n\n**Files:** src/telemetry.rs","id":"bd-jgol","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Telemetry logging defaults: replace bool mode with enum","type":"chore"}
{"_at":[1768817008232,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768779104512,0],"created_by":"darin@darinsmcstudio2.lan","description":"Many tests create a fresh git repo via Reinitialized existing Git repository in /Users/darin/Projects/beads-rs-macstudio/.git/ + config. Create a template repo once (per test process) and copy/clone it into temp dirs for each test to avoid repeated init/config overhead. Could use OnceLock + fs copy or git clone --shared.","id":"bd-u3iu","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Speed up git fixtures with a cached template repo","type":"chore"}
{"_at":[1769523799138,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] It is impossible to construct a receipt with outcome/proof mismatch (compile‑time enforced).\n- [ ] Achieved replicated receipts require `acked_by.len() >= k` by construction.\n- [ ] Pending outcomes are only possible for replicated durability (not local fsync).\n- [ ] All receipt construction sites compile using the new constructors; no raw struct literals remain.\n- [ ] Tests cover mismatch rejection and correct merge behavior with the new types.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769496015985,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`DurabilityReceipt` allows internally inconsistent states: `DurabilityOutcome` is independent from `DurabilityProofV1`, so contradictory combinations compile. Examples:\n- `outcome=Achieved { requested: ReplicatedFsync{k}, achieved: ReplicatedFsync{k} }` while `durability_proof.replicated=None`.\n- `outcome=Achieved` with `acked_by.len() < k`.\n- `outcome=Pending { requested: LocalFsync }` (nonsensical: local fsync is immediate).\n\nBecause construction is ad‑hoc in multiple places, the compiler cannot prevent broken receipts. This can mislead clients about durability guarantees and cause incorrect retry behavior.\n\nKey refs:\n- `crates/beads-core/src/durability.rs:137` — receipt structure.\n- `crates/beads-core/src/durability.rs:126` — outcome enum (no tie to proof).\n- `crates/beads-rs/src/daemon/durability_coordinator.rs` — constructs receipts based on convention.\n\n**Impact**\nIncorrect durability reporting and client behavior; high severity for correctness and ops safety.","design":"**Design (opinionated)**\nCouple proof and outcome in the type system so inconsistent receipts are unrepresentable.\n\nOption A (preferred): split receipt by durability class.\n- `enum DurabilityReceipt { Local(LocalReceipt), Replicated(ReplicatedReceipt) }`\n- `struct LocalReceipt { proof: LocalFsyncProof, min_seen: Watermarks<Applied>, ... }`\n- `struct ReplicatedReceipt { proof: ReplicatedProof, outcome: ReplicatedOutcome, ... }`\n- `ReplicatedOutcome` is either `Pending { requested: NonZeroU32 }` or `Achieved { requested, achieved }` and always *requires* `ReplicatedProof`.\n- Enforce `acked_by.len() >= k` at construction for Achieved.\n\nOption B: make `DurabilityOutcome` carry its proof and remove the separate `durability_proof` field entirely.\n\nWhichever variant we pick, construction should be via constructors that validate invariants; all ad‑hoc struct literals should go away.","id":"bd-xbje","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Encode durability receipt/proof invariants in types","type":"bug"}
