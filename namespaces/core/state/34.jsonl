{"_at":[1768246015130,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1768195851371,1],"darin@darinsmacstudio.lan"],"claim":[[1768243274522,1],"darin@darinsmacstudio.lan"],"description":[[1768177837603,1],"darin@darinsmacstudio.lan"],"design":[[1768177837603,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768177837603,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768177837603,1],"darin@darinsmacstudio.lan"],"labels":[[1768177837603,1],"darin@darinsmacstudio.lan"],"priority":[[1768177837603,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768177837603,1],"darin@darinsmacstudio.lan"],"title":[[1768177837603,1],"darin@darinsmacstudio.lan"],"type":[[1768177837603,1],"darin@darinsmacstudio.lan"]},"acceptance_criteria":"- [ ] Rebuild populates events, watermarks, and origin_seq tables from WAL segments.\n- [ ] Tail truncation is handled safely during replay.\n- [ ] Startup can catch up from last_indexed_offset without full scan.","assignee":"darin@darinsmacstudio.lan","assignee_at":[1768243274522,1],"assignee_expires":1768246874522,"closed_at":[1768246015130,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1768177837603,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nPhase 3: implement WAL replay and SQLite index rebuild from WAL segments, including tail truncation rules. Without this, crash recovery, idempotency, and origin_seq allocation are unsafe.\n\n**Context**\n- REALTIME_PLAN.md ยง6.3 (index rebuild and catch up), ยง6.5 (crash consistency), ยง7.3 step 8 (replay)\n**Files:** src/daemon/wal/replay.rs (new), src/daemon/wal/mod.rs, src/daemon/store_runtime.rs","design":"**Design**\n- Implement scan of wal/<namespace>/segment-*.wal in creation order.\n- Validate segment headers (store_id, store_epoch, namespace, wal_format_version) before replay.\n- For each segment, read frames from last_indexed_offset (if present) to EOF and index records.\n- On tail corruption, truncate the segment to the last valid frame boundary and update segments table.\n- Provide full rebuild path when index is missing or schema mismatch.","id":"bd-3m5.11","labels":[],"priority":2,"status":"closed","title":"Phase 3: WAL replay + index rebuild","type":"task"}
{"_at":[1768349116293,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768271778268,1],"darin@darinsmacstudio.lan"],"claim":[[1768348889104,1],"darin@book"],"description":[[1768271778268,1],"darin@darinsmacstudio.lan"],"design":[[1768271778268,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768271778268,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768271778268,1],"darin@darinsmacstudio.lan"],"labels":[[1768271778268,1],"darin@darinsmacstudio.lan"],"priority":[[1768271778268,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768271778268,1],"darin@darinsmacstudio.lan"],"title":[[1768271778268,1],"darin@darinsmacstudio.lan"],"type":[[1768271778268,1],"darin@darinsmacstudio.lan"]},"assignee":"darin@book","assignee_at":[1768348889104,1],"assignee_expires":1768352489104,"closed_at":[1768349116293,1],"closed_by":"darin@book","created_at":[1768271778268,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nretryable flags do not match REALTIME_ERRORS.md: lock_held is marked retryable but should be false; index_corrupt and index_rebuild_required are treated as permanent but should be retryable after rebuild.\n\n**Where**\n- src/daemon/ops.rs: store_runtime_transience (lock_held)\n- src/daemon/ops.rs: wal_index_transience (index_corrupt/index_rebuild_required)\n\n**Design**\n- Update transience mapping to reflect registry retryable semantics.\n- Ensure IPC ErrorPayload.retryable mirrors updated transience values.\n\n**Acceptance**\n- lock_held -> retryable=false\n- index_corrupt/index_rebuild_required -> retryable=true\n\n**Files**\n- src/daemon/ops.rs\n- src/daemon/ipc.rs","id":"bd-3m5.75","labels":[],"priority":1,"status":"closed","title":"Retryable flags: align lock_held and index_* with registry","type":"bug"}
{"_at":[1768536342841,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768508732062,1],"darin@book"],"claim":[[1768508732062,1],"darin@book"],"description":[[1768508732062,1],"darin@book"],"design":[[1768508732062,1],"darin@book"],"estimated_minutes":[[1768508732062,1],"darin@book"],"external_ref":[[1768508732062,1],"darin@book"],"labels":[[1768508732062,1],"darin@book"],"priority":[[1768508732062,1],"darin@book"],"source_repo":[[1768508732062,1],"darin@book"],"title":[[1768508732062,1],"darin@book"],"type":[[1768508732062,1],"darin@book"]},"acceptance_criteria":"- [ ] Store discovery/open/lock logic lives under `src/daemon/store/`.\n- [ ] `src/daemon/core.rs` no longer contains store-id discovery or on-disk open code.\n- [ ] No behavior change: existing tests pass (`cargo test`).\n- [ ] Public exports from `crate::daemon` remain compatible.","closed_at":[1768536342841,1],"closed_by":"darin@book","created_at":[1768508732062,1],"created_by":"darin@book","description":"**Problem**\n- `src/daemon/core.rs` owns store discovery, lock acquisition, namespace policy load, WAL/index open, and `StoreRuntime` wiring.\n- Store lifecycle logic is spread across `src/daemon/core.rs`, `src/daemon/store_runtime.rs`, `src/daemon/store_lock.rs`, `src/daemon/remote.rs`, and `src/paths.rs`.\n- This mixes storage concerns with request routing and makes store open/close hard to test in isolation.\n\n**Files:**\n- src/daemon/core.rs\n- src/daemon/store_runtime.rs\n- src/daemon/store_lock.rs\n- src/daemon/remote.rs\n- src/paths.rs\n- src/daemon/mod.rs","design":"- Introduce `src/daemon/store/` with submodules like `discovery.rs`, `open.rs`, `runtime.rs`, `lock.rs` (names can vary).\n- Move store-id resolution, path caches, and repo binding into a `StoreRegistry` or `StoreManager`.\n- Move `StoreRuntime::open` and related helpers into `store/runtime.rs`.\n- Keep `Daemon` API stable by delegating to the new store module (re-export types where needed).\n- Keep data layout and on-disk formats unchanged.","id":"bd-doms","labels":[],"priority":2,"status":"closed","title":"Refactor daemon store subsystem extraction","type":"chore"}
{"_at":[1768520433456,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768503210143,1],"darin@book"],"claim":[[1768518488223,1],"darin@book"],"description":[[1768503210143,1],"darin@book"],"design":[[1768503210143,1],"darin@book"],"estimated_minutes":[[1768503210143,1],"darin@book"],"external_ref":[[1768503210143,1],"darin@book"],"labels":[[1768503210143,1],"darin@book"],"priority":[[1768503210143,1],"darin@book"],"source_repo":[[1768503210143,1],"darin@book"],"title":[[1768503210143,1],"darin@book"],"type":[[1768503210143,1],"darin@book"]},"acceptance_criteria":"- [ ] Mutation engine accepts typed requests; no parsing of IDs from strings inside planning logic.\n- [ ] Invalid IDs/labels are rejected once, at the conversion boundary.\n- [ ] Tests cover invalid ID parsing paths.","assignee":"darin@book","assignee_at":[1768518488223,1],"assignee_expires":1768522088223,"closed_at":[1768520433456,1],"closed_by":"darin@book","created_at":[1768503210143,1],"created_by":"darin@book","description":"**Problem**\n`MutationRequest` in `src/daemon/mutation_engine.rs` uses `String` for bead ids, dep ids, note ids, and label values. Parsing happens in multiple branches with inconsistent error handling. This is unergonomic and allows invalid ids to flow deep into realtime planning.\n\n**Files**\n- src/daemon/mutation_engine.rs\n- src/daemon/ipc.rs\n- src/daemon/ops.rs","design":"Add a `ParsedMutationRequest` (or similar) that carries typed identifiers (`BeadId`, `NoteId`, `DepKey`, `Label`, `BeadSlug`, etc.). Parse/validate once at IPC boundary (or at the daemon core entrypoint) and pass typed requests into the mutation engine. Keep the external JSON schema unchanged but centralize conversion + error mapping.","id":"bd-haz","labels":[],"priority":2,"status":"closed","title":"MutationRequest: add typed ParsedMutationRequest","type":"chore"}
