{"_at":[1769406581033,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Patch<T>, BeadPatch, OpResult defined in beads-surface\n- [ ] OpError stays in beads-rs daemon\n- [ ] Extension trait pattern used for daemon operations\n- [ ] `cargo check -p beads-surface` passes\n- [ ] `cargo check -p beads-rs` passes","assignee":"darin@book","created_at":[1769398696700,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`daemon/ops.rs` contains both schema types (part of public boundary) and daemon-only operational logic.\n\n**What's in daemon/ops.rs today**:\n- `Patch<T>` - generic patch type (schema)\n- `BeadPatch` - bead mutation schema (schema)\n- `OpResult` - operation result (schema)\n- `OpError` - daemon-only error type (daemon)\n- `validate()`, `apply_to_fields()` - operational logic (daemon)\n\n**Changes**\n\n1. **Create beads-surface/src/ops.rs** with schema types only:\n   ```rust\n   use serde::{Deserialize, Serialize};\n\n   #[derive(Debug, Clone, Serialize, Deserialize)]\n   pub struct Patch<T> { ... }\n\n   impl<T> Patch<T> {\n       pub fn apply(self, current: Option<T>) -> Option<T> { ... }\n   }\n\n   #[derive(Debug, Clone, Serialize, Deserialize)]\n   pub struct BeadPatch { ... }\n\n   impl BeadPatch {\n       pub fn is_empty(&self) -> bool { ... }\n   }\n\n   #[derive(Debug, Clone, Serialize, Deserialize)]\n   pub struct OpResult { ... }\n   ```\n\n2. **Keep daemon-only code in beads-rs/src/daemon/ops.rs**:\n   - `OpError` (daemon error type)\n   - Import schema types: `use beads_surface::ops::{BeadPatch, Patch, OpResult};`\n   - Add extension trait for daemon operations:\n   ```rust\n   pub trait BeadPatchDaemonExt {\n       fn validate_for_daemon(&self) -> Result<(), OpError>;\n       fn apply_to_fields(&self, fields: &mut beads_core::BeadFields, stamp: &beads_core::Stamp)\n           -> Result<(), OpError>;\n   }\n\n   impl BeadPatchDaemonExt for beads_surface::ops::BeadPatch { ... }\n   ```\n\n3. **Update imports** throughout daemon to use:\n   - `beads_surface::ops::{Patch, BeadPatch, OpResult}` for types\n   - Local `ops::OpError` and extension trait for operations\n\n**Files**\n- crates/beads-surface/src/ops.rs (new - schema types)\n- crates/beads-rs/src/daemon/ops.rs (refactored - daemon-only)","id":"bd-14fs.6","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 3C: Extract patch/op-result schemas to beads-surface","type":"task"}
{"_at":[1767918180661,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1767915293605,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nFirst access to a repo blocks the daemon in `Daemon::ensure_repo_loaded` while waiting for `GitOp::Load` to finish. `GitWorker::load` always performs a remote fetch (even in best-effort mode). If SSH auth is misconfigured (no agent / passphrase prompt / stalled handshake), libgit2 fetch can hang. Because `ensure_repo_loaded` waits synchronously, the state thread blocks and IPC requests like `bd status` hang indefinitely. We saw `bd status` time out on this machine before SSH auth was configured.\n\n**Design**\nMake load non-blocking, and treat timeouts as a guardrail rather than the primary fix:\n- Split `GitWorker::load` into a fast local-only load (read local ref, compute state) and a remote refresh path.\n- Change `ensure_repo_loaded` to return local state immediately and, if the repo is stale, enqueue a background `GitOp::Refresh` (or `GitOp::Fetch`) without blocking.\n- Only block on remote fetch when no local ref exists; add a bounded timeout (default ~30s, configurable) and return a clean, actionable error on timeout with diagnostic info (SSH agent/auth hints, remote URL).\n- Surface fetch/auth errors via `fetch_error` and Sync warnings, but keep IPC responsive.\n\n**Design Notes**\nThe primary goal is responsiveness: read-only queries must not block on network or auth. Use best-effort refresh for freshness, but never let it block IPC. Timeout is a secondary safety net for unavoidable fetches. Keep existing CRDT merge semantics intact.\n\n**Acceptance**\n- [ ] `bd status` returns promptly (e.g., <1s) when SSH auth is missing/invalid; no hang.\n- [ ] If local ref exists, initial load is non-blocking and refresh happens in the background.\n- [ ] If no local ref exists, the initial fetch is bounded by a default ~30s timeout and returns a clean, actionable error on timeout with diagnostics.\n- [ ] Fetch/auth failures appear as warnings (`fetch_error`) but do not block IPC responses.\n- [ ] Background refresh still updates cached state once auth/network is available.\n- [ ] Run `codex review --uncommitted` (timeout 10m) and address findings.\n- [ ] Tests pass.\n\n**Files:** `src/daemon/core.rs`, `src/daemon/git_worker.rs`, `src/git/sync.rs`","id":"bd-7zf","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Daemon load blocks on SSH auth, hangs IPC","type":"bug"}
