{"_at":[1768455524887,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] pending_events is bounded by size/bytes or removed entirely.\n- [ ] Overflow behavior is explicit (drop policy + metric/log).\n- [ ] Tests or assertions cover the cap behavior.\n\n**Files:** src/daemon/repl/manager.rs, src/daemon/repl/server.rs","assignee":"darin@book","created_at":[1768448962846,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nBoth inbound and outbound replication loops buffer events before streaming is established, but the pending_events Vec has no size/byte bound. If handshake stalls or a peer stays non-streaming, this can grow without bound and consume memory.\n\n**Evidence**\n- src/daemon/repl/manager.rs: pending_events: Vec<BroadcastEvent> grows while !streaming.\n- src/daemon/repl/server.rs: pending_events: Vec<BroadcastEvent> grows while !streaming.\n\n**Why this hurts**\nA slow or stuck peer can cause unbounded memory growth in the daemon, which is brittle and hard to reason about.","design":"**Design**\nOption A: Replace pending_events with a bounded VecDeque that caps both event count and bytes (use limits.max_event_batch_events / max_event_batch_bytes or broadcaster hot-cache limits). Drop oldest events and record a metric when overflowing.\nOption B: Remove pending_events entirely and rely on hot_cache + WANT after handshake, avoiding buffering while not streaming.\n\nEither way, prevent unbounded growth and keep behavior deterministic.","id":"bd-6lv","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Replication pending_events queue is unbounded","type":"bug"}
{"_at":[1765677592520,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@dusk","created_at":[1765676872178,0],"created_by":"darin@darinsmcstudio2.lan","description":"## What's Wrong\nflake.nix has doCheck=false to avoid test failures during nix build. This means `nix build` won't catch test regressions.\n\n## Where\n- flake.nix:42-43\n\n## Why It Matters\nUsers installing via nix won't get test validation. If tests break, nix users get broken builds.\n\n## Options\n1. Fix whatever causes tests to fail in nix sandbox (likely git/network related)\n2. Add a separate `nix flake check` that runs tests outside the build\n3. Accept the gap and rely on CI (current state)","id":"bd-97w","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Nix flake skips tests (doCheck=false) - CI gap","type":"chore"}
{"_at":[1769484609473,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] All match arms updated to ctx/payload.\n- [ ] RequestContext extraction tests updated and green.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769480318089,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nDaemon request routing (`coord.rs`, `server.rs`) matches on the old Request shape. After refactor, it must destructure `{ ctx, payload }` and pass repo/meta/read correctly.\n\n**Design**\n- Update `daemon/coord.rs` `handle_request` match arms to `{ ctx, payload }` and pass:\n  - `ctx.repo.path` for repo\n  - `ctx.meta` or `ctx.read` for meta/read\n  - payload struct directly to mutation/query handlers\n- Update `daemon/server.rs` RequestContext extraction, read gate request building, and any requestâ€‘type detection to use ctx/payload.\n- Keep RequestContext fields identical (repo, namespace, actor_id, client_request_id, read_consistency tags).\n- Update `daemon/server.rs` tests that construct Request variants.\n\n**Acceptance**\n- [ ] All daemon request routing compiles with ctx/payload Request.\n- [ ] RequestContext tests still validate the same extracted fields.\n- [ ] `cargo test -p beads-rs daemon::server` passes.\n\n**Files:**\n- crates/beads-rs/src/daemon/coord.rs\n- crates/beads-rs/src/daemon/server.rs","design":"Follow Phase 4 in REFACTORING_PLAN.md. Focus on mechanical destructuring and keep behavior stable.","id":"bd-ebhh.4","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Daemon routing: update coord/server to ctx+payload","type":"task"}
{"_at":[1768416234514,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768411803728,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`tests/critical_path.rs` and `tests/migration.rs` share a single runtime/data dir for the entire test process via `test_runtime_dir()` (OnceLock + `/tmp/beads-test-runtime-<pid>`). That means all tests in both modules share the same XDG_RUNTIME_DIR/BD_DATA_DIR and the same daemon socket. There is no cleanup of that directory, and parallel test runs can cross-talk through the shared daemon/state. This undermines realtime phase test isolation and makes failures order-dependent.\n\nEvidence:\n- `tests/critical_path.rs` lines 14-28 define `test_runtime_dir()` with OnceLock and a fixed path.\n- `tests/migration.rs` lines 11-25 define the same pattern and reuse it for BD env.\n\n**Design**\n- Replace `test_runtime_dir()` with a per-test TempDir runtime (owned by the test fixture / TestRepo).\n- Make `TestRepo` carry `runtime_dir: TempDir` and `data_dir: PathBuf`, and update `bd()` to use those paths.\n- Reuse the shared shutdown helper from the daemon teardown bead so each runtime is cleaned up on Drop.\n- Avoid shared globals so tests can run in parallel without state collisions.\n\n**Acceptance**\n- [ ] `tests/critical_path.rs` and `tests/migration.rs` no longer use OnceLock-based runtime dirs.\n- [ ] Each test uses a unique TempDir for XDG_RUNTIME_DIR/BD_DATA_DIR and it is removed on Drop.\n- [ ] Tests can run with `--test-threads=N` without sharing a daemon/socket.\n\n**Files:**\n- tests/critical_path.rs\n- tests/migration.rs\n- tests/fixtures/daemon_runtime.rs (new, shared helper)","id":"bd-j9l","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"tests: critical_path/migration share runtime dir","type":"bug"}
{"_at":[1768622554816,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] canonicalize_path resolves symlinks\n- [ ] canonicalize_path calls realpath on macOS\n- [ ] normalize_path_for_comparison lowercases on macOS/Windows\n- [ ] paths_equal handles case-insensitive FS correctly\n- [ ] Fallback works if realpath unavailable\n- [ ] Works on macOS with mixed-case input\n- [ ] Works on Linux (no-op)\n- [ ] Works on Windows (uses std::fs::canonicalize)\n- [ ] Error messages are helpful\n- [ ] Tests cover symlinks and case variations","created_at":[1768622554816,0],"created_by":"darin@darinsmcstudio2.lan","description":"","design":"Port the macOS path canonicalization from Go beads to beads-rs.\n\n## Problem\n\nmacOS (and Windows) have case-insensitive but case-preserving filesystems. This causes issues with:\n1. **Daemon socket discovery**: `/Users/foo/Desktop` vs `/users/foo/desktop` treated as different workspaces\n2. **Remote URL matching**: Git worktrees with different case don't match\n3. **Path comparisons**: String comparison fails for semantically identical paths\n\n## Go beads solution\n\nUse `realpath(1)` on macOS to resolve paths to their true filesystem case:\n```go\nfunc resolveCanonicalCase(path string) string {\n    if runtime.GOOS == \"darwin\" {\n        cmd := exec.Command(\"realpath\", path)\n        output, err := cmd.Output()\n        if err == nil {\n            return strings.TrimSpace(string(output))\n        }\n    }\n    return \"\"\n}\n```\n\nThis ensures `/Users/foo/Desktop` always resolves to the true case, regardless of how user typed it.\n\n## Implementation approach\n\n**Core path utilities** (`src/core/path.rs`):\n```rust\nuse std::path::{Path, PathBuf};\n\n/// Canonicalize path, resolving symlinks and true case on case-insensitive FS\npub fn canonicalize_path(path: &Path) -> Result<PathBuf> {\n    // 1. Convert to absolute\n    let abs = path.canonicalize()\n        .or_else(|_| std::env::current_dir().map(|cwd| cwd.join(path)))?;\n    \n    // 2. Resolve symlinks\n    let canonical = abs.canonicalize().unwrap_or(abs);\n    \n    // 3. On case-insensitive FS, resolve to true case\n    #[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\n    {\n        if let Ok(resolved) = resolve_true_case(&canonical) {\n            return Ok(resolved);\n        }\n    }\n    \n    Ok(canonical)\n}\n\n#[cfg(target_os = \"macos\")]\nfn resolve_true_case(path: &Path) -> Result<PathBuf> {\n    use std::process::Command;\n    \n    let output = Command::new(\"realpath\")\n        .arg(path)\n        .output()\n        .map_err(|e| Error::PathCanonicalization(e.to_string()))?;\n    \n    if !output.status.success() {\n        return Err(Error::PathCanonicalization(\n            String::from_utf8_lossy(&output.stderr).to_string()\n        ));\n    }\n    \n    let resolved = String::from_utf8_lossy(&output.stdout)\n        .trim()\n        .to_string();\n    \n    Ok(PathBuf::from(resolved))\n}\n\n#[cfg(target_os = \"windows\")]\nfn resolve_true_case(path: &Path) -> Result<PathBuf> {\n    // On Windows, fs::canonicalize already handles case\n    // Just return the input\n    Ok(path.to_path_buf())\n}\n\n#[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\nfn resolve_true_case(path: &Path) -> Result<PathBuf> {\n    Ok(path.to_path_buf())\n}\n\n/// Normalize path for comparison (lowercase on case-insensitive FS)\npub fn normalize_path_for_comparison(path: &Path) -> Result<PathBuf> {\n    let canonical = canonicalize_path(path)?;\n    \n    #[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\n    {\n        // Lowercase for comparison\n        let lowered = canonical.to_str()\n            .ok_or(Error::InvalidUtf8Path)?\n            .to_lowercase();\n        return Ok(PathBuf::from(lowered));\n    }\n    \n    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n    {\n        Ok(canonical)\n    }\n}\n\n/// Compare two paths for equality (handles case-insensitive FS)\npub fn paths_equal(a: &Path, b: &Path) -> Result<bool> {\n    let a_norm = normalize_path_for_comparison(a)?;\n    let b_norm = normalize_path_for_comparison(b)?;\n    Ok(a_norm == b_norm)\n}\n```\n\n**Usage in daemon**:\n```rust\n// Socket discovery\nlet workspace = canonicalize_path(&env::current_dir()?)?;\nlet socket_path = socket_path(&workspace);\n\n// Remote URL matching\nlet canonical_workspace = canonicalize_path(workspace)?;\nif paths_equal(&canonical_workspace, &stored_workspace)? {\n    // Same workspace\n}\n```\n\n**Error type**:\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum Error {\n    #[error(\"Path canonicalization failed: {0}\")]\n    PathCanonicalization(String),\n    \n    #[error(\"Path contains invalid UTF-8\")]\n    InvalidUtf8Path,\n}\n```\n\n## Files to reference\n\nGo implementation:\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/utils/path.go`\n  - `CanonicalizePath()`: Lines 106-130\n  - `resolveCanonicalCase()`: Lines 135-148\n  - `NormalizePathForComparison()`: Lines 158-182\n\nKey insight from GH#880: Git operations string-compare paths exactly, so we must use the true filesystem case.\n\n## Design notes\n\n**Why realpath, not Rust canonicalize**:\n- `std::fs::canonicalize` resolves symlinks but NOT case on macOS\n- `realpath(1)` gives true filesystem case\n- This is essential for daemon socket matching\n\n**Fallback strategy**:\n1. Try realpath (may not exist on all systems)\n2. If realpath fails, use canonicalized path as-is\n3. Never fail just because realpath unavailable\n\n**Comparison vs display**:\n- `canonicalize_path`: For display, preserve true case\n- `normalize_path_for_comparison`: For comparison, lowercase\n- Don't mix them up!\n\n**Performance**:\n- Cache canonicalized paths (spawning realpath is expensive)\n- Only canonicalize once per daemon lifetime\n- Consider memoization for hot paths\n\n**Testing**:\n- Test on macOS with mixed-case paths\n- Test symlink resolution\n- Test on Linux (should be no-op)\n- Test Windows (use built-in canonicalize)\n\n## Questions\n\n1. Should we cache realpath results in daemon?\n2. What if realpath is not installed? (rare but possible)\n3. Should we warn if case differs from input?\n4. Handle network paths / UNC paths on Windows?","id":"bd-ze0x.47","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":6972034271141002286,"replica":"dea337f8-bcb5-4843-7bc8-d8a47f19ea9a"}]}},"priority":2,"status":"open","title":"Implement macOS case-insensitive path canonicalization using realpath","type":"bug"}
