{"_at":[1768896334512,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] StoreMeta serde roundtrip includes orset_counter\n- [ ] StoreRuntime persists counter increments\n- [ ] Counter increments even if WAL append fails (holes ok)\n\n**Invariants to re-verify**\n- [ ] orset_counter never decreases and is never reused across restarts\n- [ ] Counter increments are durable before WAL commit","assignee":"darin@book","created_at":[1768894650986,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nDots must be unique across restarts. We need a persisted per-replica counter.\n\n**Files**\n- src/core/store_meta.rs\n- src/daemon/store/runtime.rs","design":"Add `orset_counter: u64` to StoreMeta, update constructors + serde tests. Add StoreRuntime helper:\n- next_orset_counter() -> u64 (increments, writes store_meta.json)\nEnsure counter persists before WAL commit.","id":"bd-3zoj.2","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Persist OR-Set dot counter in StoreMeta","type":"task"}
{"_at":[1770936635585,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Background refresh no longer emits repeated backup-ref lock warnings under normal operation.\n- [ ] `bd ready`/`bd show` latency remains stable with large backup-ref populations.\n- [ ] Tests cover stale backup lock cleanup and contention behavior.\n- [ ] Retention/compaction policy is documented and validated.","created_at":[1770936635585,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nRepositories with many `refs/beads/backup/*` refs show lock contention and repeated background refresh warnings (including `*.lock` acquisition failures). In a pathological repo with hundreds of backup refs, this materially degrades perceived CLI latency and realtime freshness.\n\nThis appears as repeated warnings during daemon refresh and intermittent slowdown in non-JSON interactive paths.","design":"Harden backup-ref handling for realtime operation:\n1. Prevent read/refresh paths from blocking on backup-ref lock contention.\n2. Add stale lockfile cleanup policy (age/PID-aware) for backup ref locks.\n3. Bound or compact backup refs (retention/pruning) so ref count does not grow unbounded.\n4. Emit structured counters for backup ref scan count, lock contention, and cleanup actions.","id":"bd-4cic","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"open","title":"Backup ref lock contention degrades realtime refresh and latency","type":"bug"}
