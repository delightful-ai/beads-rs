{"_at":[1768198447469,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1768180151534,1],"darin@darinsmacstudio.lan"],"claim":[[1768197293406,1],"darin@darinsmacstudio.lan"],"description":[[1768180151534,1],"darin@darinsmacstudio.lan"],"design":[[1768180151534,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768177760012,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768177760012,1],"darin@darinsmacstudio.lan"],"labels":[[1768177760012,1],"darin@darinsmacstudio.lan"],"priority":[[1768177760012,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768177760012,1],"darin@darinsmacstudio.lan"],"title":[[1768177760012,1],"darin@darinsmacstudio.lan"],"type":[[1768177760012,1],"darin@darinsmacstudio.lan"]},"acceptance_criteria":"- [ ] Canonical encode produces stable bytes and hashes across runs (unit tests).\n- [ ] Decoder rejects indefinite length and out of bounds payloads.\n- [ ] EventBytes typestate is used in frame or WAL APIs to prevent hash preimage ambiguity.","assignee":"darin@darinsmacstudio.lan","assignee_at":[1768197293406,1],"assignee_expires":1768200893406,"closed_at":[1768198447469,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1768177760012,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nRealtime WAL and replication require a canonical EventBody representation whose bytes are the hash preimage. There is no EventBody type or canonical encoding path in core yet, so we cannot guarantee stable hashing or verify remote frames.\n\n**Context**\n- REALTIME_PLAN.md 0.6 (canonical CBOR + hash over EventBody bytes), 2.4 (EventBody fields), 9.4 (EVENTS frame)\n- Stateright model: beads_stateright_models/src/realtime_types_sketch.rs (EventBytes, EventFrameV1, VerifiedEvent)\n\n**Files:** src/core/event.rs (new), src/core/mod.rs, Cargo.toml (minicbor), tests under src/core","design":"**Design**\n- Define EventBody, EventKindV1, and EventId in src/core/event.rs with StoreIdentity and NamespaceId baked in.\n- Add EventBytes<Canonical> and EventBytes<Opaque> wrappers to separate locally authored canonical bytes from opaque remote bytes.\n- Implement canonical CBOR encoder for EventBody using minicbor with definite lengths and sorted map keys for hashed types; reject floats and indefinite lengths.\n- Provide helpers: encode_event_body_canonical -> EventBytes<Canonical>, hash_event_body -> Sha256.\n- Add decode with strict bounds (depth, map entries, byte length) and return EventBytes<Opaque> + EventBody.","id":"bd-3m5.5","labels":[],"priority":2,"status":"closed","title":"Phase 2: EventBody canonical CBOR + hashing","type":"task"}
{"_at":[1768457113410,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768444169778,1],"darin@book"],"claim":[[1768456928501,1],"darin@book"],"description":[[1768444169778,1],"darin@book"],"design":[[1768444169778,1],"darin@book"],"estimated_minutes":[[1768444169778,1],"darin@book"],"external_ref":[[1768444169778,1],"darin@book"],"labels":[[1768444169778,1],"darin@book"],"priority":[[1768444169778,1],"darin@book"],"source_repo":[[1768444169778,1],"darin@book"],"title":[[1768444169778,1],"darin@book"],"type":[[1768444169778,1],"darin@book"]},"acceptance_criteria":"- [ ] Mismatch between `event_time_ms` and `hlc_max.physical_ms` is rejected at decode/verify.\n- [ ] Tests cover mismatch and success cases.","assignee":"darin@book","assignee_at":[1768456928501,1],"assignee_expires":1768460528501,"closed_at":[1768457113410,1],"closed_by":"darin@book","created_at":[1768444169778,1],"created_by":"darin@book","description":"**Problem**\n`event_time_ms` and `hlc_max.physical_ms` can diverge, but we never validate their equality. `apply_event` derives the write stamp from `event_time_ms` + `hlc_max.logical`, so a mismatched `event_time_ms` silently produces a stamp that doesn’t match the event’s stated HLC. This violates the spec invariant that `event_time_ms` equals the physical time used for stamps.\n\n**Signals / Evidence**\n- `apply_event` uses `WriteStamp::new(body.event_time_ms, hlc_max.logical)` (`src/core/apply.rs`).\n- `decode_event_body` only checks that `hlc_max` exists for TxnV1, not that it agrees with `event_time_ms` (`src/core/event.rs`).\n- Mutation planning sets both from the same clock, but remote events could be malformed and still be accepted.\n\n**Why this hurts velocity**\nThis is a silent invariant violation: if we ever need to reason about stamp ordering across replicas or debug clock issues, we can’t trust the stored data. It’s a latent correctness and observability trap.","design":"**Design**\n- Add validation during decode/verify: if `hlc_max` is present, require `hlc_max.physical_ms == event_time_ms`.\n- On mismatch, return a structured `DecodeError::InvalidField` (or a dedicated error) so it maps to `invalid_request`/`corruption` per policy.\n- Add tests for mismatch rejection and match acceptance.","id":"bd-c2r","labels":[],"priority":2,"status":"closed","title":"Enforce HLC invariants: event_time_ms must match hlc_max.physical_ms","type":"bug"}
