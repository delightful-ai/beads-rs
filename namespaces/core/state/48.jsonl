{"_at":[1768184440925,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1768180726141,1],"darin@darinsmacstudio.lan"],"claim":[[1768180726141,1],"darin@darinsmacstudio.lan"],"description":[[1768180726141,1],"darin@darinsmacstudio.lan"],"design":[[1768180726141,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768180726141,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768180726141,1],"darin@darinsmacstudio.lan"],"labels":[[1768180726141,1],"darin@darinsmacstudio.lan"],"priority":[[1768180726141,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768180726141,1],"darin@darinsmacstudio.lan"],"title":[[1768180726141,1],"darin@darinsmacstudio.lan"],"type":[[1768180726141,1],"darin@darinsmacstudio.lan"]},"closed_at":[1768184440925,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1768180726141,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nPhase 1 implementation must be verified before Phase 2 starts.\n\n**Context**\n- REALTIME_PLAN.md §18: store discovery order, identity persistence, store-global lock enforcement\n- Depends on: Phase 1 implementation beads + Phase 1 test infrastructure\n\n**Design**\nDeterministic tests for:\n- Store discovery order: multiple repo paths → same StoreId\n- Identity persistence: create store, close, reopen → same StoreId/ReplicaId\n- Store-global lock enforcement: two processes → second gets error\n- Namespace validation: valid/invalid NamespaceId patterns\n- StoreMeta round-trip: write → read → compare\n\n**Acceptance**\n- [ ] tests/phase1_identity.rs exists\n- [ ] Test: store identity survives daemon restart\n- [ ] Test: lock prevents concurrent access with clear error\n- [ ] Test: namespace regex validation (a-z, 0-9, underscore, length)\n- [ ] cargo test phase1_identity passes\n\n**Files:** tests/phase1_identity.rs (new)","id":"bd-3m5.54","labels":[],"priority":2,"status":"closed","title":"Phase 1 tests: identity persistence + lock enforcement","type":"task"}
{"_at":[1768465491733,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768444366719,1],"darin@book"],"claim":[[1768464156445,1],"darin@book"],"description":[[1768444366719,1],"darin@book"],"design":[[1768444366719,1],"darin@book"],"estimated_minutes":[[1768444366719,1],"darin@book"],"external_ref":[[1768444366719,1],"darin@book"],"labels":[[1768444366719,1],"darin@book"],"priority":[[1768444366719,1],"darin@book"],"source_repo":[[1768444366719,1],"darin@book"],"title":[[1768444366719,1],"darin@book"],"type":[[1768444366719,1],"darin@book"]},"assignee":"darin@book","assignee_at":[1768464156445,1],"assignee_expires":1768467756445,"closed_at":[1768465491733,1],"closed_by":"darin@book","created_at":[1768444366719,1],"created_by":"darin@book","description":"**Problem**\nREALTIME_PLAN §8.4 requires HLC state to be monotonic per ActorId and persisted/restored per actor. Current daemon uses a single global Clock and only restores HLC state for the daemon actor, so custom actor_id requests can regress after restart.\n\nEvidence:\n- src/daemon/clock.rs implements a single Clock without actor partitioning.\n- src/daemon/core.rs:564–570 loads hlc_state only for self.actor.\n- MutationEngine uses Clock::tick for all actors (src/daemon/mutation_engine.rs:200–240).\n\n**Why this violates plan**\nPer-actor monotonicity and persistence are required; using a single clock and only restoring the daemon actor breaks this for alternate actor_id inputs.\n\n**Acceptance**\n- [ ] Maintain per-actor HLC state (e.g., map ActorId -> Clock state) and load from wal_index.hlcs for any actor seen/used.\n- [ ] When actor_id is specified in a request, advance the correct actor clock state.\n- [ ] Tests cover monotonicity across restarts for non-daemon actor_id.","id":"bd-3m5.93","labels":[],"priority":2,"status":"closed","title":"HLC state is global; per-actor persistence not honored","type":"bug"}
{"_at":[1767993609274,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1767988919943,1],"darin@darinsmacstudio.lan"],"claim":[[1767984543055,1],"darin@darinsmacstudio.lan"],"description":[[1767984543055,1],"darin@darinsmacstudio.lan"],"design":[[1767984543055,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1767984543055,1],"darin@darinsmacstudio.lan"],"external_ref":[[1767984543055,1],"darin@darinsmacstudio.lan"],"labels":[[1767984543055,1],"darin@darinsmacstudio.lan"],"priority":[[1767984543055,1],"darin@darinsmacstudio.lan"],"source_repo":[[1767984543055,1],"darin@darinsmacstudio.lan"],"title":[[1767984543055,1],"darin@darinsmacstudio.lan"],"type":[[1767984543055,1],"darin@darinsmacstudio.lan"]},"acceptance_criteria":"- [ ] Epic decomposed into per model beads with dependencies and priorities\n- [ ] Each model in beads_stateright_models/todo.md is implemented or explicitly scoped to non Stateright tests with rationale\n- [ ] Each model asserts the invariants listed in todo.md and references REALTIME_PLAN.md sections\n- [ ] Every model counterexample that maps to a product bug is translated into a deterministic regression test in the main codebase\n- [ ] Documentation exists in beads_stateright_models (README.md or similar) explaining how to run each model and interpret counterexamples","closed_at":[1767993609274,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1767984543055,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nWe need a tracked epic for the Stateright state machine model suite described in REALTIME_PLAN.md and beads_stateright_models/todo.md. Without it, modeling work is ad hoc and the sequence of invariants and model boundaries is not managed.\n\n**Design Notes**\nUse multiple small models at the seams: replication core, durability, idempotency, checkpoint lane, GC floor, identity and epoch guards, resource bounds, crash recovery. Each model should map counterexamples to integration tests.\n\n**Files:** REALTIME_PLAN.md, beads_stateright_models/todo.md, beads_stateright_models/src, beads_stateright_models/examples","design":"**Design**\nBuild a model portfolio, ordered for maximum early signal, matching the todo list:\n1) Realtime replication core: EVENTS, WANT, ACK, gaps, equivocation, monotonic seen map.\n2) Durability semantics: applied vs durable watermarks, ReplicatedFsync(k) coordinator.\n3) Idempotency and receipts: client_request_id mapping, PENDING vs COMMITTED, retry behavior, crash cut points.\n4) Checkpoint lane: snapshot inclusion, included_heads, multi writer retry loop, truthful included watermarks.\n5) GC markers and floors: ignore old events but advance contiguity and ACK.\n6) Store identity and epoch mismatch guards across replication and checkpoint import.\n7) Resource bounds and fairness: bounded buffers, round robin per namespace origin.\n8) WAL crash recovery cut points: no origin_seq reuse, durable means survives crash.\n9) Deterministic encoding and hashing: canonical CBOR and checkpoint hashing via property tests or tiny models.\n\nEach model should live in beads_stateright_models/src or examples, keep state minimal, and reference matching sections in REALTIME_PLAN.md so counterexamples map to implementation changes.","id":"bd-hjm","labels":["modeling","realtime","stateright"],"priority":2,"status":"closed","title":"Stateright state machine modeling for realtime Beads","type":"epic"}
