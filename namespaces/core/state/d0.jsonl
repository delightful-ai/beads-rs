{"_at":[1768727730862,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768610564067,0],"created_by":"darin@darinsmcstudio2.lan","description":"Add slow-tests multi-process replication harness that spawns real bd daemons, configures peers via beads.toml, applies ops, and asserts convergence.","id":"bd-1lfb","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Multi-process replication e2e harness","type":"task"}
{"_at":[1769774119298,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] Legacy snapshot module/type names reflect snapshot semantics (no “WAL” in the public API).\n- [ ] Legacy snapshot versioning is centralized (no ad-hoc `WAL_VERSION`).\n- [ ] Legacy snapshot usage is confined to migration/import paths.\n- [ ] Tests still pass for legacy snapshot loading and roundtrip.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769581955506,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`wal_legacy_snapshot.rs` implements a “WAL” that actually stores full state snapshots, not a write-ahead log of operations.\n\nThis is a lie + noise source:\n- The name implies log-of-ops durability, but the format is snapshot-based.\n- It duplicates snapshot serialization logic and carries its own `WAL_VERSION` separate from store meta versioning.\n\n**Files:**\n- `crates/beads-rs/src/daemon/wal_legacy_snapshot.rs`\n- `crates/beads-core/src/store_meta.rs`\n- `crates/beads-rs/src/daemon/wal/*`","design":"**Design**\nMake the legacy snapshot format explicit and remove the misleading WAL framing.\n\nConcrete plan:\n1) Rename the module and types to `legacy_snapshot` / `LegacySnapshotEntry` to reflect actual semantics.\n2) Move the format version to a dedicated `LegacySnapshotVersion` or into `StoreMetaVersions` to avoid parallel version constants.\n3) Isolate legacy snapshot use to import/migration paths; block new writes when the event WAL is available.\n4) If still needed, route legacy snapshot serialization through the canonical snapshot codec (see `bd-lk0x`).\n\n**Design Notes**\n- The goal is explicit semantics: \"snapshot\" should be visible in the type and API names.\n- This reduces cognitive overhead and prevents accidental misuse as an op-log.","id":"bd-3b8u","labels":{"cc":{"max":{}},"entries":{"lies":[{"counter":4837767757655580815,"replica":"c7001f72-6f55-d137-4b72-12a27938a3e8"}],"noise":[{"counter":12932191716031635316,"replica":"46989f3a-5e02-6910-62f2-12e50b45b2e5"}],"tech-debt":[{"counter":2555881959332814832,"replica":"5509c5d8-f3ed-1284-33b7-5e74feac1db2"}]}},"priority":3,"status":"closed","title":"Make legacy snapshot semantics explicit (rename WAL snapshot)","type":"chore"}
{"_at":[1768253663111,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Head sha is persisted and reloaded alongside applied and durable watermarks.\n- [ ] API rejects advancing a nonzero seq without a head sha.\n- [ ] StoreRuntime exposes head sha lookup per (namespace, origin) for later prev_sha validation.\n- [ ] Head sha updates are tied to watermark advancement (no stale head).","assignee":"darin@darinsmacstudio.lan","created_at":[1768178717301,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nHead sha tracking is required to validate prev_sha continuity and to safely advance watermarks. Today we only have seq values, which allows the system to represent seq>0 without knowing the chain head, making continuity checks ambiguous. This bead scopes the Phase 3 core tracking (no replication session wiring).\n\n**Context**\n- REALTIME_PLAN.md 0.12 (head sha rule) + 2.3 (WatermarkHeadMap)\n- Stateright model: beads_stateright_models/src/realtime_types_sketch.rs (HeadStatus)\n\n**Design**\n- Extend watermarks to carry head hash for each (namespace, origin) pair (HeadStatus: Genesis, Known, Unknown).\n- Require head to be Known whenever seq>0; Unknown is allowed only when a checkpoint does not include heads.\n- Persist head sha in the wal.sqlite watermarks table (applied_head_sha, durable_head_sha) and keep in memory in StoreRuntime.\n- Update head sha on WAL append (durable) and after apply_event (applied) so prev_sha validation can use the latest known head.\n- Provide helper API: advance_contiguous(seq, head) and observe_at_least(seq, head) to enforce invariants in one place.\n- Replication session wiring deferred to Phase 5 (bd-3m5.46).\n\n**Acceptance**\n- [ ] Head sha is persisted and reloaded alongside applied and durable watermarks.\n- [ ] API rejects advancing a nonzero seq without a head sha.\n- [ ] StoreRuntime exposes head sha lookup per (namespace, origin) for later prev_sha validation.\n- [ ] Head sha updates are tied to watermark advancement (no stale head).\n\n**Files:** src/core/watermark.rs, src/daemon/store_runtime.rs, src/daemon/wal/index.rs","design":"**Design**\n- Extend watermarks to carry head hash for each (namespace, origin) pair (HeadStatus: Genesis, Known, Unknown).\n- Require head to be Known whenever seq>0; Unknown is allowed only when a checkpoint does not include heads.\n- Persist head sha in the wal.sqlite watermarks table (applied_head_sha, durable_head_sha) and keep in memory in StoreRuntime.\n- Update head sha on WAL append (durable) and after apply_event (applied) so prev_sha validation can use the latest known head.\n- Provide helper API: advance_contiguous(seq, head) and observe_at_least(seq, head) to enforce invariants in one place.","id":"bd-3m5.27","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 3: WatermarkHeadMap + head sha tracking","type":"task"}
{"_at":[1768800111976,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768777670480,0],"created_by":"darin@darinsmcstudio2.lan","description":"tests/integration/daemon/repl_e2e.rs repl_daemon_stress_wal_rotation_roundtrip hardcodes 40 creates per node. Compute minimum events based on wal_segment_max_bytes and average record size (write one event, inspect segment bytes) so we only generate what’s needed to force rotation.","id":"bd-kqse","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Reduce WAL rotation stress test event count by computing needed writes","type":"chore"}
{"_at":[1769223184476,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] No reachable code path returns ApplyError::{BeadCollision, NoteCollision} OR clear docs justify remaining use.\\n- [ ] Tests updated to match the chosen approach.","assignee":"darin@book","created_at":[1769210188036,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\nApplyError still contains BeadCollision/NoteCollision variants even though collisions are now meant to be deterministic and total. This contradicts the CRDT overhaul goal and leaves dead/error paths.\\n\\n**Files**: src/core/apply.rs, src/core/state.rs","design":"**Design**\\nAudit remaining call sites for BeadCollision/NoteCollision. If collisions are fully handled deterministically, remove the variants and refactor callers to be infallible (or treat as internal invariants). If still needed, document why and align with CRDT_OVERHAUL.md.","id":"bd-qz97.19","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Cleanup: remove/justify ApplyError collision variants","type":"chore"}
{"_at":[1769509260925,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] A loaded-store handle cannot exist without a backing runtime/lane entry (enforced by borrow or token).\n- [ ] Codepaths that currently return Internal due to “missing loaded store” are eliminated.\n- [ ] All loaded-store APIs take the new handle type; no raw `store_id`+`remote` pairs used for access.\n- [ ] Tests cover missing/invalid store errors at load time only.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769483948649,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`LoadedStore` is a marker type that claims a store is loaded, yet the docs state accessors can still return Internal if the invariant is violated. This is exactly the kind of “type that lies” that causes unsafe refactors and hidden runtime failure modes. It violates the principles in `docs/philosophy/type_design.md`.\n\nKey references:\n- `crates/beads-rs/src/daemon/core.rs:54` — `LoadedStore` comment says invariant can still be violated.\n\nSeverity: This is the primary gateway to daemon state. Any misuse can lead to internal errors despite “proof” types, making correctness non-local and brittle.","design":"**Design**\nMake “loaded store” a real proof by tying it to actual entries in the daemon state via borrowing or a typestate.\n\nOption A (borrowed handle):\n- `struct LoadedStore<'a> { store_id: StoreId, remote: RemoteUrl, runtime: &'a mut StoreRuntime, lane: &'a mut GitLaneState }`.\n- Only constructed by `Daemon::ensure_repo_loaded*` by looking up entries and borrowing them.\n- Callers that need a loaded store take `LoadedStore<'_>`; they can’t exist without the backing map entry.\n\nOption B (index token + invariants):\n- `LoadedStore` holds an internal key tied to a `StoreCaches` entry that cannot be fabricated.\n- Accessors use the key to retrieve references without `Option` or Internal errors.\n\nMigration:\n- Update `ensure_repo_loaded`/`ensure_repo_loaded_strict`/`ensure_repo_fresh` to return the borrowed handle.\n- Collapse “internal if invariant violated” branches since they become impossible.\n- Add tests for failure modes (ensure errors only occur during loading, not post-hoc access).","id":"bd-tzkw","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Make LoadedStore a real proof via borrowed handle/typestate","type":"bug"}
