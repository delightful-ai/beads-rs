{"_at":[1768456162983,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768444170914,1],"darin@book"],"claim":[[1768455548150,1],"darin@book"],"description":[[1768444170914,1],"darin@book"],"design":[[1768444170914,1],"darin@book"],"estimated_minutes":[[1768444170914,1],"darin@book"],"external_ref":[[1768444170914,1],"darin@book"],"labels":[[1768444170914,1],"darin@book"],"priority":[[1768444170914,1],"darin@book"],"source_repo":[[1768444170914,1],"darin@book"],"title":[[1768444170914,1],"darin@book"],"type":[[1768444170914,1],"darin@book"]},"assignee":"darin@book","assignee_at":[1768455548150,1],"assignee_expires":1768459148150,"closed_at":[1768456162983,1],"closed_by":"darin@book","created_at":[1768444170914,1],"created_by":"darin@book","description":"**Problem**\nREALTIME_PLAN §0.6/§3.4 says nodes can store/forward raw EventBody bytes without re-encoding and should be forward compatible. Current decode_event_body_map / decode_hlc_max hard-fail on any unknown key, which means a newer sender adding a field causes older nodes to reject the event entirely (even though hash is over raw bytes).\n\nEvidence:\n- src/core/event.rs:478–510 decode_event_body_map returns InvalidField for unknown key.\n- src/core/event.rs:1618–1644 decode_hlc_max returns InvalidField for unknown key.\n\n**Why this violates plan**\nForward compatibility is required in v0.5: receivers should accept unknown keys (after hash verification) and still persist raw bytes, even if they can’t interpret new fields.\n\n**Acceptance**\n- [ ] Unknown keys in EventBody/HlcMax are skipped (while enforcing size/depth limits).\n- [ ] Events with extra fields still verify sha256 and are persisted/replicated.\n- [ ] Tests cover decoding EventBody with an extra field without failure.","id":"bd-3m5.84","labels":[],"priority":2,"status":"closed","title":"EventBody decode rejects unknown keys; breaks forward-compat storage/forwarding","type":"bug"}
{"_at":[1766129877018,1],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1766116456666,0],"darin@dusk"],"claim":[[1766116456666,0],"darin@dusk"],"description":[[1766116456666,0],"darin@dusk"],"design":[[1766116456666,0],"darin@dusk"],"estimated_minutes":[[1766116456666,0],"darin@dusk"],"external_ref":[[1766116456666,0],"darin@dusk"],"labels":[[1766116456666,0],"darin@dusk"],"priority":[[1766116456666,0],"darin@dusk"],"source_repo":[[1766116456666,0],"darin@dusk"],"title":[[1766116456666,0],"darin@dusk"],"type":[[1766116456666,0],"darin@dusk"]},"closed_at":[1766129877018,1],"closed_by":"darin@dusk","created_at":[1766116456666,0],"created_by":"darin@dusk","description":"**Problem**\nState sharing keys by normalized remote URL, but normalization is currently minimal (trim slash + parse). ssh/https variants (e.g., `git@github.com:org/repo` vs `https://github.com/org/repo`) can create split state.\n\n**Design**\nCanonicalize host + path across ssh/https/file URLs. Consider using `git2::Remote::url()` parsing or a dedicated normalizer with test cases.\n\n**Acceptance**\n- [ ] ssh/https URLs normalize to same key\n- [ ] Test coverage for common URL variants\n\n**Files:** src/daemon/remote.rs","id":"bd-x1z","labels":[],"priority":2,"status":"closed","title":"Remote URL normalization should canonicalize ssh/https variants","type":"chore"}
