{"_at":[1769559883438,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769198665337,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Segment:** crdt/2-state-model (bd-3zoj.3, bd-3zoj.4)\n**Files:** src/core/state.rs, src/core/bead.rs, src/core/dep.rs, +30 others\n**RepoPrompt chat:** state-model-review-187BB8\n\n---\n\n## Summary\n\nThis patch is test-only: it adds `updated_stamp_includes_labels_and_notes` in `src/core/state.rs` to assert that `CanonicalState::updated_stamp_for()` incorporates:\n\n- the per-bead `LabelState.stamp` (after `apply_label_add`), and\n- the latest note's `(at, author)` (after inserting a `Note` into `NoteStore`),\n\nwhich matches the `CRDT_OVERHAUL.md` updated-stamp rule after labels/notes were moved out of `Bead`.\n\n## Critical issues (invariant risks to address)\n\n### 1) `LabelState.stamp` updates are not monotonic and can regress\nIn `CanonicalState::{apply_label_add, apply_label_remove}`:\n\n```rs\nif !change.is_empty() {\n    state.stamp = Some(stamp);\n}\n```\n\nProblems:\n- **No max()**: if an older event is applied later (totally plausible in distributed ingest), `stamp` can move backwards, making `updated_stamp` potentially regress and violating the intent that `updated_stamp` reflect the max across content sources.\n- **Change detection is membership-only**: `OrSetChange` is computed from membership sets only; OR-Set *internal* state can change (new dot, cc merge) without changing the visible membership set, and `stamp` won't update. If the stamp is meant to be \"last label CRDT activity\" (as `CRDT_OVERHAUL.md` suggests: \"update store stamp when OR-Set state changes\"), this is currently under-counting.\n\nWhy this matters to your stated invariants:\n- If label operations are applied out of order, `updated_stamp` may no longer be `>=` the true maximum label-related stamp that should participate in resurrection.\n\n**Suggested fix**\n- Update `LabelState.stamp` with `max(existing, stamp)` (you already have `set_label_stamp()` that does exactly this; `apply_label_*` should use it).\n- If the intended semantic is \"OR-Set state changed\" (not just membership changed), you'll likely need to extend `OrSet::{apply_add, apply_remove}` (or the returned change type) to indicate **internal mutation** as well as membership diff.\n\n### 2) Legacy dep→OR-Set bridge likely breaks \"delete then re-add\" for the same dep\nIn `CanonicalState::insert_dep` (legacy wire path), active membership uses:\n\n```rs\nlet dot = Self::legacy_dot_for_dep(&merged.created, &key);\nself.dep_store.set.apply_add(dot, key.clone(), ...)\n```\n\nBut `merged.created` is intentionally the **earliest created** stamp (stable provenance), not the \"latest active\" stamp. With OR-Set semantics, that means:\n\n- Add at `t1` ⇒ dot derived from `t1`\n- Delete at `t2` ⇒ remove observes dot(t1) and records it in cc\n- Re-add at `t3` (restore) ⇒ **tries dot(t1) again**, but cc dominates it ⇒ add is ignored ⇒ dep never comes back in `dep_store`/`dep_indexes`\n\nThis violates the \"dep_indexes reflect DepStore membership and behave correctly\" expectation in practice, and will make deps non-restorable under the current legacy apply path.\n\n**Suggested fix**\n- For \"active\" membership, derive the dot from the **active-life stamp** (`merged.life.stamp`) rather than `merged.created`, and make the same adjustment in `rebuild_dep_indexes()` (it currently derives from `edge.created`).\n- Add a regression test that covers the *real* problematic sequence: **active → deleted → active** (not just deleted→active).\n\n### 3) Current invariant checks don't actually validate `dep_indexes` against `DepStore`\nYour proptest `assert_invariants()` checks `dep_indexes` against the legacy `deps` map:\n\n```rs\nfor (key, edge) in state.deps.iter() { ... }\n```\n\n…but `dep_indexes` is explicitly derived from `dep_store` (and rebuilt from `dep_store.values()` after join). If `deps` and `dep_store` ever diverge, this invariant won't catch it.\n\n**Suggested fix**\n- Add an invariant check that:\n  - every `DepKey` in `dep_store.values()` exists in both indexes, and\n  - every edge present in indexes corresponds to a `DepKey` present in `dep_store`.\n\n## Minor improvements\n\n- The new test is good and targeted, but you could make it slightly stronger by asserting full stamp equality after the label add (not just `wall_ms`), e.g. `assert_eq!(updated, label_stamp)`.\n- Consider adding tests for:\n  - **orphan hiding**: add labels/notes/deps for a missing bead and assert `labels_for/notes_for/deps_from` don't surface them, while the internal stores retain them (`labels_for_any`, `NoteStore`, `dep_store`).\n  - **resurrection via labels/notes**: tombstone newer than fields but older than label/note activity should resurrect.\n  - **content_hash determinism**: same hash regardless of label/note insertion order and stable across join.\n- `compute_content_hash()` appears deterministic, but it likely omits at least `estimated_minutes` (and possibly other fields you intend to be part of OCC). Confirm intent and add a \"hash changes when field changes\" test if OCC depends on it.\n\n## What's done well\n\n- The added test directly encodes the `CRDT_OVERHAUL.md` updated-stamp rule and will prevent regressions as labels/notes continue moving out of `Bead`.\n- The state model separation is clean: `CanonicalState` as the owner of stores + `BeadView` for derived metadata, and deterministic ordering (BTree*, explicit sorts) for stable hashing/output.\n\n## Next steps\n\n1. Fix `LabelState.stamp` maintenance to be monotonic (`max`) and aligned with the intended \"OR-Set state changed\" semantics.\n2. Fix legacy dep dot derivation (`insert_dep` / `rebuild_dep_indexes`) to support delete→re-add.\n3. Extend invariant/test coverage to validate `dep_indexes` against **`dep_store`**, and add the missing dep restore regression test.\n4. Add deterministic/content-hash regression tests (including field coverage) if `ContentHash` is relied on for OCC.","id":"bd-ogvs.2","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Segment 2: State Model review","type":"task"}
