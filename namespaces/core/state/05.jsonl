{"_at":[1768258334065,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1768257837230,1],"darin@darinsmacstudio.lan"],"claim":[[1768257842939,1],"darin@darinsmacstudio.lan"],"description":[[1768257837230,1],"darin@darinsmacstudio.lan"],"design":[[1768257837230,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768257837230,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768257837230,1],"darin@darinsmacstudio.lan"],"labels":[[1768257837230,1],"darin@darinsmacstudio.lan"],"priority":[[1768257837230,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768257837230,1],"darin@darinsmacstudio.lan"],"title":[[1768257837230,1],"darin@darinsmacstudio.lan"],"type":[[1768257837230,1],"darin@darinsmacstudio.lan"]},"acceptance_criteria":"- [ ] All integration-test helpers and raw commands set BD_DATA_DIR per runtime\n- [ ] daemon_lifecycle and critical_path tests no longer fail due to store lock conflicts\n- [ ] cargo test passes (or targeted suites) after the change","assignee":"darin@darinsmacstudio.lan","assignee_at":[1768257842939,1],"assignee_expires":1768261442939,"closed_at":[1768258334065,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1768257837230,1],"created_by":"darin@darinsmacstudio.lan","description":"Integration tests that spawn `bd` set runtime/WAL dirs but not BD_DATA_DIR. The daemon then uses the default store path and can collide with a developer daemon or other test daemons, causing lock_held failures.","design":"Derive a temp data dir from each test runtime dir (e.g., runtime_dir/data) and set BD_DATA_DIR on every integration-test `bd` command (helpers + direct invocations). Ensure the directory exists before spawning commands.","id":"bd-6eh","labels":[],"priority":2,"status":"closed","title":"Integration tests isolate BD_DATA_DIR per runtime","type":"bug"}
{"_at":[1768534712583,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768508733307,1],"darin@book"],"claim":[[1768533174343,1],"darin@book"],"description":[[1768508733307,1],"darin@book"],"design":[[1768508733307,1],"darin@book"],"estimated_minutes":[[1768508733307,1],"darin@book"],"external_ref":[[1768508733307,1],"darin@book"],"labels":[[1768508733307,1],"darin@book"],"priority":[[1768508733307,1],"darin@book"],"source_repo":[[1768508733307,1],"darin@book"],"title":[[1768508733307,1],"darin@book"],"type":[[1768508733307,1],"darin@book"]},"acceptance_criteria":"- [ ] Protocol vs legacy codes are clearly separated in code and docs.\n- [ ] Existing serialized strings remain accepted and produced.\n- [ ] Tests cover parsing/serialization for both sets.","assignee":"darin@book","assignee_at":[1768533174343,1],"assignee_expires":1768536774343,"closed_at":[1768534712583,1],"closed_by":"darin@book","created_at":[1768508733307,1],"created_by":"darin@book","description":"**Problem**\n- `core::ErrorCode` mixes realtime protocol codes with legacy CLI/IPC codes, obscuring stability boundaries.\n- It is unclear which codes are normative vs compatibility only.\n\n**Files:**\n- src/core/error.rs\n- REALTIME_ERRORS.md\n- CLI_SPEC.md (if needed)\n- src/daemon/ipc.rs (mapping)","design":"- Introduce `ProtocolErrorCode` (realtime/replication/IPC stable) and `LegacyErrorCode`.\n- Wrap them in `ErrorCode` or introduce `ErrorCode::Protocol/Legacy`.\n- Preserve current string values for compatibility; parsing should accept legacy names.\n- Update docs to state which codes are protocol-stable vs legacy.","id":"bd-m3ta","labels":[],"priority":2,"status":"closed","title":"Separate protocol error codes from legacy CLI codes","type":"chore"}
{"_at":[1767997555263,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1765744424170,0],"darin@book"],"claim":[[1767997551828,1],"darin@darinsmacstudio.lan"],"description":[[1765744424170,0],"darin@book"],"design":[[1765744424170,0],"darin@book"],"estimated_minutes":[[1765744424170,0],"darin@book"],"external_ref":[[1765744424170,0],"darin@book"],"labels":[[1765744424170,0],"darin@book"],"priority":[[1765744424170,0],"darin@book"],"source_repo":[[1765744424170,0],"darin@book"],"title":[[1765744424170,0],"darin@book"],"type":[[1765744424170,0],"darin@book"]},"assignee":"darin@darinsmacstudio.lan","assignee_at":[1767997551828,1],"assignee_expires":1768001151828,"closed_at":[1767997555263,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1765744424170,0],"created_by":"darin@book","description":"**Problem**\n`DepKey` is stored both as the map key AND inside `DepEdge.key`:\n```rust\ndeps: BTreeMap<DepKey, DepEdge>\n\npub struct DepEdge {\n    pub key: DepKey,      // <-- duplicates the map key\n    pub created: Stamp,\n    pub life: Lww<DepLife>,\n}\n```\n\nThis duplication means:\n1. Wasted memory\n2. Possible key/value mismatch bugs (though unlikely)\n\n**Design**\nRemove `key` from `DepEdge`:\n```rust\npub struct DepEdge {\n    pub created: Stamp,\n    pub life: Lww<DepLife>,\n}\n```\n\nCallers that need the key get it from the map iteration:\n```rust\nfor (key, edge) in &state.deps {\n    // key is available here\n}\n```\n\n**Design Notes**\n- Wire format needs to handle this - on serialization, include key; on deserialization, reconstruct\n- `DepEdge::new` and `DepEdge::join` signatures change (no longer take/return key)\n- Check all usages of `edge.key` and ensure key is available from context\n\n**Acceptance**\n- [ ] `DepEdge` no longer contains `key` field\n- [ ] Wire format correctly serializes/deserializes (key comes from map, not struct)\n- [ ] All `edge.key` usages updated to use key from iteration context\n- [ ] `DepEdge::new`/`join` updated\n- [ ] Tests pass\n\n**Files:** src/core/dep.rs, src/git/wire.rs, src/daemon/executor.rs","id":"bd-mgf","labels":[],"priority":3,"status":"closed","title":"Remove duplicate key from DepEdge","type":"chore"}
