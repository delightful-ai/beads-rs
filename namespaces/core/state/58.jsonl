{"_at":[1768483765241,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768373551255,0],"created_by":"darin@darinsmcstudio2.lan","description":"build_snapshot currently errors on non-core namespaces because StoreRuntime only has CanonicalState. Extend snapshot capture once StoreState is plumbed so checkpoint groups can include multiple namespaces.","id":"bd-0ya","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Checkpoint snapshot builder rejects non-core namespaces","type":"chore"}
{"_at":[1768460325161,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768444134874,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nREALTIME_PLAN §0.3/§2.7 require StoreState (namespaced CanonicalState) + namespace-aware access. Current implementation remains single-namespace: RepoState holds CanonicalState, and IPC normalization rejects any namespace other than core. This means namespaces.toml policies are loaded but never used, and non-core namespaces cannot be created or queried.\n\nEvidence:\n- src/daemon/core.rs:1865 normalize_namespace() returns NamespaceUnknown for any non-core.\n- src/daemon/repo.rs: RepoState.state is CanonicalState (not StoreState).\n- src/daemon/executor.rs and src/daemon/query_executor.rs apply/query against repo_state.state directly.\n\n**Why this violates plan**\nREALTIME_PLAN mandates StoreState = map<NamespaceId, CanonicalState> and a defaulting rule (namespace=core) rather than hard-rejecting non-core. This is a core architectural requirement.\n\n**Acceptance**\n- [ ] Replace RepoState.state with StoreState; thread namespace selection through executor, query, replication ingest, checkpoint export/import.\n- [ ] normalize_namespace validates against store.policies (namespaces.toml) and allows non-core namespaces when configured.\n- [ ] Defaulting rule remains: missing namespace -> core.\n- [ ] Unit tests cover non-core namespace mutation + query + replication paths.","id":"bd-3m5.81","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Namespaces still hard-coded to core; StoreState not wired","type":"bug"}
{"_at":[1769598978711,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Decoding a namespace list always yields canonical (sorted + deduped) order.\n- [ ] Handshake replay accepts the same set regardless of wire ordering.\n- [ ] Internal storage uses the canonical type (no raw Vec in session peer).\n- [ ] Encoding always emits canonical order.\n- [ ] Tests cover: same set different order, duplicates on wire, empty list.\n- [ ] `cargo test` passes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769562833894,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nReplication wire decoding returns raw `Vec<NamespaceId>` for `requested_namespaces`, `offered_namespaces`, and `accepted_namespaces`. Order is preserved from the wire, not canonicalized. Later we compare vectors for equality (e.g. WELCOME replay), which can reject a peer that sends the same set in a different order.\n\nThis is a parse-don’t-validate violation (we should normalize at the boundary), and a classic scatter bug: correctness depends on every caller remembering to sort/dedup.\n\n**Impact**\n- False handshake failures due to ordering differences.\n- Hidden coupling to wire ordering; brittle and hard to reason about.\n\n**Files**\n- `crates/beads-rs/src/daemon/repl/proto.rs` (decode_namespace_list)\n- `crates/beads-rs/src/daemon/repl/session.rs` (HELLO/WELCOME replay comparison)\n","design":"**Design (opinionated)**\nMake namespace lists a canonical type, and only expose canonicalized lists internally.\n\n1) Introduce a `NamespaceSet` newtype:\n```rust\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct NamespaceSet(Vec<NamespaceId>);\nimpl NamespaceSet {\n  pub fn from_wire(mut v: Vec<NamespaceId>) -> Self { v.sort(); v.dedup(); Self(v) }\n  pub fn as_slice(&self) -> &[NamespaceId] { &self.0 }\n}\n```\n(Or use `BTreeSet` internally if you want set semantics and ordering for free.)\n\n2) `decode_namespace_list` should return `NamespaceSet` (or at least canonicalize before returning).\n3) `SessionPeer` should store `NamespaceSet` (or a canonical `NamespaceList` type) so comparisons are order-insensitive.\n4) `encode_namespace_list` should always emit canonical order from the set type.\n\nThis removes ordering‑sensitive comparisons and keeps the invariant local.","id":"bd-ufv1","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Repl namespace lists must be canonicalized at parse boundary","type":"bug"}
