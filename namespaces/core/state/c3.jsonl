{"_at":[1768477619127,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768454384480,1],"darin@book"],"claim":[[1768475388977,1],"darin@book"],"description":[[1768454384480,1],"darin@book"],"design":[[1768454384480,1],"darin@book"],"estimated_minutes":[[1768454384480,1],"darin@book"],"external_ref":[[1768454384480,1],"darin@book"],"labels":[[1768454384480,1],"darin@book"],"priority":[[1768454384480,1],"darin@book"],"source_repo":[[1768454384480,1],"darin@book"],"title":[[1768454384480,1],"darin@book"],"type":[[1768454384480,1],"darin@book"]},"assignee":"darin@book","assignee_at":[1768475388977,1],"assignee_expires":1768478988977,"closed_at":[1768477619127,1],"closed_by":"darin@book","created_at":[1768454384480,1],"created_by":"darin@book","description":"**Problem**\nREALTIME_PLAN §13.2/§13.4 call for incremental checkpoint export: track dirty shards per namespace and reuse previous checkpoint blobs for unchanged shards. Current `build_snapshot` in `src/git/checkpoint/export.rs` sets `dirty_shards = all shards`, and `GitWorker::publish_checkpoint` always calls `export_checkpoint(previous=None)`, so every checkpoint is a full re‑export with no reuse.\n\n**Design**\n- Track dirty shard IDs in `StoreRuntime` using `ApplyOutcome` (beads/tombstones/deps) and pass them into `CheckpointSnapshot` instead of defaulting to all.\n- Retain the last export per group (or load from cache) and pass `previous: Some(&export)` to `export_checkpoint` so unchanged shard files are reused.\n- Ensure dirty shards are cleared only after successful publish.\n\n**Acceptance**\n- [ ] Dirty shards are tracked per namespace and carried into checkpoint snapshots.\n- [ ] `export_checkpoint` reuses previous files for clean shards.\n- [ ] Checkpoint export tests cover dirty‑only updates and reuse behavior.\n\n**Files:** src/daemon/store_runtime.rs, src/daemon/core.rs, src/daemon/checkpoint_scheduler.rs, src/daemon/git_worker.rs, src/git/checkpoint/export.rs","id":"bd-3m5.102","labels":[],"priority":2,"status":"closed","title":"Checkpoint export always full; dirty shard tracking + previous reuse missing","type":"bug"}
{"_at":[1768401598789,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768271787357,1],"darin@darinsmacstudio.lan"],"claim":[[1768401069291,1],"darin@book"],"description":[[1768271787357,1],"darin@darinsmacstudio.lan"],"design":[[1768271787357,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768271787357,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768271787357,1],"darin@darinsmacstudio.lan"],"labels":[[1768271787357,1],"darin@darinsmacstudio.lan"],"priority":[[1768271787357,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768271787357,1],"darin@darinsmacstudio.lan"],"title":[[1768271787357,1],"darin@darinsmacstudio.lan"],"type":[[1768271787357,1],"darin@darinsmacstudio.lan"]},"assignee":"darin@book","assignee_at":[1768401069291,1],"assignee_expires":1768404669291,"closed_at":[1768401598789,1],"closed_by":"darin@book","created_at":[1768271787357,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nREALTIME_ERRORS.md defines overloaded, rate_limited, and maintenance_mode, but OpError has no variants and IPC cannot emit these codes. Limits exist but no visible error signaling.\n\n**Where**\n- src/core/error.rs: ErrorCode::{Overloaded,RateLimited,MaintenanceMode}\n- src/daemon/ops.rs: OpError missing variants\n- src/core/limits.rs: admission/backpressure limits\n\n**Design**\n- Add OpError variants and IPC mappings for overloaded/rate_limited/maintenance_mode with retry_after_ms when available.\n- Hook AdmissionController/maintenance mode checks to return these errors on request admission.\n\n**Acceptance**\n- Overload and maintenance mode conditions emit the corresponding realtime error codes.\n- retry_after_ms is set when known.\n\n**Files**\n- src/daemon/ops.rs\n- src/daemon/ipc.rs\n- src/daemon/* admission path (as implemented in bd-3m5.29)","id":"bd-3m5.76","labels":[],"priority":2,"status":"closed","title":"Admission/backpressure: emit overloaded/rate_limited/maintenance_mode","type":"task"}
