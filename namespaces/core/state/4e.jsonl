{"_at":[1768257024330,1],"_by":"darin@darinsmacstudio.lan","_v":{"acceptance_criteria":[[1768252084827,1],"darin@darinsmacstudio.lan"],"claim":[[1768252084827,1],"darin@darinsmacstudio.lan"],"description":[[1768252147638,1],"darin@darinsmacstudio.lan"],"design":[[1768252084827,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768252084827,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768252084827,1],"darin@darinsmacstudio.lan"],"labels":[[1768252084827,1],"darin@darinsmacstudio.lan"],"priority":[[1768252084827,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768252084827,1],"darin@darinsmacstudio.lan"],"title":[[1768252084827,1],"darin@darinsmacstudio.lan"],"type":[[1768252084827,1],"darin@darinsmacstudio.lan"]},"closed_at":[1768257024330,1],"closed_by":"darin@darinsmacstudio.lan","created_at":[1768252084827,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nwal.sqlite segment rows are always sealed=false and final_len=None; replay does not enforce sealed segment file_len == final_len. REALTIME_PLAN.md 5.2 requires sealed segment invariants and fail-fast on mismatch.\n\n**Design**\nWhen rotating segments, mark the previous segment sealed with final_len (bytes_written). Persist sealed/final_len in wal.sqlite segments table. On startup/replay, if a sealed segment exists and file_len != final_len, return WalReplayError and surface operator action. Add fsck check to flag sealed length mismatch.\n\n**Acceptance**\n- [ ] Segment rotation updates wal.sqlite segments with sealed=true and final_len.\n- [ ] Replay errors on sealed segment length mismatch.\n- [ ] Fsck reports sealed length mismatch.\n- [ ] Tests cover sealed invariant enforcement; cargo test passes.\n\n**Files:** src/daemon/wal/segment.rs, src/daemon/wal/index.rs, src/daemon/wal/replay.rs, src/daemon/wal/fsck.rs, tests/phase3_index.rs","id":"bd-a7k","labels":[],"priority":2,"status":"closed","title":"Track sealed WAL segments + final_len invariant","type":"task"}
{"_at":[1768541599399,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768509356085,1],"darin@book"],"claim":[[1768541285091,1],"darin@book"],"description":[[1768509356085,1],"darin@book"],"design":[[1768509356085,1],"darin@book"],"estimated_minutes":[[1768509356085,1],"darin@book"],"external_ref":[[1768509356085,1],"darin@book"],"labels":[[1768509356085,1],"darin@book"],"priority":[[1768509356085,1],"darin@book"],"source_repo":[[1768509356085,1],"darin@book"],"title":[[1768509356085,1],"darin@book"],"type":[[1768509356085,1],"darin@book"]},"acceptance_criteria":"- [ ] Only fixtures::identity owns StoreId/ReplicaId/StoreIdentity/StoreMeta builders.\\n- [ ] repl_frames/repl_peer/wal fixtures call shared helpers.\\n- [ ] cargo test --test integration passes.","assignee":"darin@book","assignee_at":[1768541285091,1],"assignee_expires":1768544885091,"closed_at":[1768541599399,1],"closed_by":"darin@book","created_at":[1768509356085,1],"created_by":"darin@book","description":"**Problem**\\n- tests/integration/fixtures/identity.rs defines store_id/store_identity/replica_id helpers.\\n- tests/integration/fixtures/repl_frames.rs and repl_peer.rs redefine store_identity.\\n- tests/integration/fixtures/wal.rs builds its own StoreId/ReplicaId/StoreMeta inline.\\nThis duplication can drift (epoch/version mismatches) and makes fixtures inconsistent.\\n\\n**Files**\\n- tests/integration/fixtures/identity.rs\\n- tests/integration/fixtures/repl_frames.rs\\n- tests/integration/fixtures/repl_peer.rs\\n- tests/integration/fixtures/wal.rs","design":"Add any missing helpers to fixtures::identity (store_identity/store_meta with caller-provided seed/epoch), then replace local duplicates with imports. Once bd-rfit lands, have store_meta default to current version constants so fixtures track real formats.","id":"bd-gc3e","labels":[],"priority":3,"status":"closed","title":"Fixtures: consolidate identity builders","type":"chore"}
{"_at":[1768521661577,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768503805795,1],"darin@book"],"claim":[[1768520450532,1],"darin@book"],"description":[[1768503805795,1],"darin@book"],"design":[[1768503805795,1],"darin@book"],"estimated_minutes":[[1768503805795,1],"darin@book"],"external_ref":[[1768503805795,1],"darin@book"],"labels":[[1768503805795,1],"darin@book"],"priority":[[1768503805795,1],"darin@book"],"source_repo":[[1768503805795,1],"darin@book"],"title":[[1768503805795,1],"darin@book"],"type":[[1768503805795,1],"darin@book"]},"acceptance_criteria":"- [ ] Hash/prev mismatch errors surface ErrorCode::HashMismatch / ErrorCode::PrevShaMismatch with details.\n- [ ] WAL/index range errors surface ErrorCode::WalCorrupt / ErrorCode::IndexCorrupt with details.\n- [ ] Tests cover each mapping and no regressions in IPC/replication payloads.","assignee":"darin@book","assignee_at":[1768520450532,1],"assignee_expires":1768524050532,"closed_at":[1768521661577,1],"closed_by":"darin@book","created_at":[1768503805795,1],"created_by":"darin@book","description":"**Problem**\nSeveral realtime error paths return ErrorCode::Corruption even when more specific codes exist (HashMismatch, PrevShaMismatch, WalCorrupt, IndexCorrupt). Examples: repl/session.rs event_frame_error_payload (hash/prev mismatches), repl/runtime.rs WalRangeError mapping (index/wal), server.rs stream_event_response_from_parts. This erodes the caller's decision surface and conflicts with REALTIME_ERRORS.md.\n\n**Files:** src/daemon/repl/session.rs, src/daemon/repl/runtime.rs, src/daemon/server.rs, src/daemon/ops.rs, src/core/error.rs","design":"**Design**\n- Replace generic Corruption usage with the specific ErrorCode variants and attach the matching *Details structs (HashMismatchDetails, PrevShaMismatchDetails, WalCorruptDetails, IndexCorruptDetails).\n- Audit other realtime error mappings for similar overbroad Corruption usage.\n- Add/adjust tests to assert the precise ErrorCode and details for each path.","id":"bd-ix9","labels":[],"priority":2,"status":"closed","title":"Align realtime error codes with specific Hash/Prev/WAL/Index variants","type":"bug"}
{"_at":[1765834663234,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1765744963972,0],"darin@book"],"claim":[[1765834270947,0],"darin@dusk"],"description":[[1765744963972,0],"darin@book"],"design":[[1765744963972,0],"darin@book"],"estimated_minutes":[[1765744963972,0],"darin@book"],"external_ref":[[1765744963972,0],"darin@book"],"labels":[[1765744963972,0],"darin@book"],"priority":[[1765744963972,0],"darin@book"],"source_repo":[[1765744963972,0],"darin@book"],"title":[[1765744963972,0],"darin@book"],"type":[[1765744963972,0],"darin@book"]},"assignee":"darin@dusk","assignee_at":[1765834270947,0],"assignee_expires":1765837870947,"closed_at":[1765834663234,0],"closed_by":"darin@dusk","created_at":[1765744963972,0],"created_by":"darin@book","description":"**Problem**\n`apply_add_dep` rejects ANY cycle regardless of dep kind. But \"related\" edges being acyclic is unnecessarily strict - related beads can absolutely reference each other cyclically.\n\n**Design**\n- `Related` and `DiscoveredFrom`: allow cycles (these are informational links)\n- `Blocks` and `Parent`: enforce DAG (these have ordering semantics)\n\n**Design Notes**\nOpen question: what about `DependsOn`? Could argue either way:\n- DAG: \"cant start A until B done\" implies ordering\n- Allow cycles: maybe you want mutual dependencies that resolve together?\n\nSuggest: enforce DAG for `DependsOn` initially (safer), can relax later.\n\n**Acceptance**\n- [ ] `bd dep add A B --kind=related` succeeds even if B->A exists\n- [ ] `bd dep add A B --kind=blocks` still rejects cycles\n- [ ] Tests for both cases\n\n**Files:** src/daemon/executor.rs (apply_add_dep), src/core/dep.rs","id":"bd-nry","labels":[],"priority":2,"status":"closed","title":"Allow cycles for Related deps, keep DAG enforcement for Blocks","type":"feature"}
