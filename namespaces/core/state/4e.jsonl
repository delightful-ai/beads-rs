{"_at":[1768257024330,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768252084827,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nwal.sqlite segment rows are always sealed=false and final_len=None; replay does not enforce sealed segment file_len == final_len. REALTIME_PLAN.md 5.2 requires sealed segment invariants and fail-fast on mismatch.\n\n**Design**\nWhen rotating segments, mark the previous segment sealed with final_len (bytes_written). Persist sealed/final_len in wal.sqlite segments table. On startup/replay, if a sealed segment exists and file_len != final_len, return WalReplayError and surface operator action. Add fsck check to flag sealed length mismatch.\n\n**Acceptance**\n- [ ] Segment rotation updates wal.sqlite segments with sealed=true and final_len.\n- [ ] Replay errors on sealed segment length mismatch.\n- [ ] Fsck reports sealed length mismatch.\n- [ ] Tests cover sealed invariant enforcement; cargo test passes.\n\n**Files:** src/daemon/wal/segment.rs, src/daemon/wal/index.rs, src/daemon/wal/replay.rs, src/daemon/wal/fsck.rs, tests/phase3_index.rs","id":"bd-a7k","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Track sealed WAL segments + final_len invariant","type":"task"}
{"_at":[1769484620472,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] All test fixtures updated to new Request shape.\n- [ ] Mutation fixtures updated to payload parse fns.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769480327211,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIntegration fixtures, test harness, and e2e tests construct Request/MutationRequest using the old flat shape. They must be updated to the new ctx/payload shape to keep coverage and ensure wire format stability.\n\n**Design**\n- Update `crates/beads-rs/src/test_harness/mod.rs` to build `Request::Create { ctx, payload }`.\n- Sweep `crates/beads-rs/tests/` for `Request::` and update all constructors to use ctx/payload.\n- Update `crates/beads-rs/tests/integration/fixtures/mutation.rs` to use payload structs and new parse fns (no MutationRequest).\n- Keep all JSON assertions and test semantics identical.\n\n**Acceptance**\n- [ ] `cargo test -p beads-rs --tests` passes.\n- [ ] No coverage gaps introduced (fixtures still exercise all ops and subscription paths).\n\n**Files:**\n- crates/beads-rs/src/test_harness/mod.rs\n- crates/beads-rs/tests/e2e.rs\n- crates/beads-rs/tests/integration/**","design":"Use a grep sweep for `Request::` and `MutationRequest::` in tests. Update each occurrence mechanically to ctx/payload; preserve all asserted JSON strings and expected results.","id":"bd-ebhh.5","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Tests/fixtures: update Request builders to ctx+payload","type":"task"}
{"_at":[1768541599399,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Only fixtures::identity owns StoreId/ReplicaId/StoreIdentity/StoreMeta builders.\\n- [ ] repl_frames/repl_peer/wal fixtures call shared helpers.\\n- [ ] cargo test --test integration passes.","assignee":"darin@book","created_at":[1768509356085,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\n- tests/integration/fixtures/identity.rs defines store_id/store_identity/replica_id helpers.\\n- tests/integration/fixtures/repl_frames.rs and repl_peer.rs redefine store_identity.\\n- tests/integration/fixtures/wal.rs builds its own StoreId/ReplicaId/StoreMeta inline.\\nThis duplication can drift (epoch/version mismatches) and makes fixtures inconsistent.\\n\\n**Files**\\n- tests/integration/fixtures/identity.rs\\n- tests/integration/fixtures/repl_frames.rs\\n- tests/integration/fixtures/repl_peer.rs\\n- tests/integration/fixtures/wal.rs","design":"Add any missing helpers to fixtures::identity (store_identity/store_meta with caller-provided seed/epoch), then replace local duplicates with imports. Once bd-rfit lands, have store_meta default to current version constants so fixtures track real formats.","id":"bd-gc3e","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Fixtures: consolidate identity builders","type":"chore"}
{"_at":[1768521661577,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Hash/prev mismatch errors surface ErrorCode::HashMismatch / ErrorCode::PrevShaMismatch with details.\n- [ ] WAL/index range errors surface ErrorCode::WalCorrupt / ErrorCode::IndexCorrupt with details.\n- [ ] Tests cover each mapping and no regressions in IPC/replication payloads.","assignee":"darin@book","created_at":[1768503805795,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nSeveral realtime error paths return ErrorCode::Corruption even when more specific codes exist (HashMismatch, PrevShaMismatch, WalCorrupt, IndexCorrupt). Examples: repl/session.rs event_frame_error_payload (hash/prev mismatches), repl/runtime.rs WalRangeError mapping (index/wal), server.rs stream_event_response_from_parts. This erodes the caller's decision surface and conflicts with REALTIME_ERRORS.md.\n\n**Files:** src/daemon/repl/session.rs, src/daemon/repl/runtime.rs, src/daemon/server.rs, src/daemon/ops.rs, src/core/error.rs","design":"**Design**\n- Replace generic Corruption usage with the specific ErrorCode variants and attach the matching *Details structs (HashMismatchDetails, PrevShaMismatchDetails, WalCorruptDetails, IndexCorruptDetails).\n- Audit other realtime error mappings for similar overbroad Corruption usage.\n- Add/adjust tests to assert the precise ErrorCode and details for each path.","id":"bd-ix9","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Align realtime error codes with specific Hash/Prev/WAL/Index variants","type":"bug"}
{"_at":[1765834663234,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@dusk","created_at":[1765744963972,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`apply_add_dep` rejects ANY cycle regardless of dep kind. But \"related\" edges being acyclic is unnecessarily strict - related beads can absolutely reference each other cyclically.\n\n**Design**\n- `Related` and `DiscoveredFrom`: allow cycles (these are informational links)\n- `Blocks` and `Parent`: enforce DAG (these have ordering semantics)\n\n**Design Notes**\nOpen question: what about `DependsOn`? Could argue either way:\n- DAG: \"cant start A until B done\" implies ordering\n- Allow cycles: maybe you want mutual dependencies that resolve together?\n\nSuggest: enforce DAG for `DependsOn` initially (safer), can relax later.\n\n**Acceptance**\n- [ ] `bd dep add A B --kind=related` succeeds even if B->A exists\n- [ ] `bd dep add A B --kind=blocks` still rejects cycles\n- [ ] Tests for both cases\n\n**Files:** src/daemon/executor.rs (apply_add_dep), src/core/dep.rs","id":"bd-nry","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Allow cycles for Related deps, keep DAG enforcement for Blocks","type":"feature"}
