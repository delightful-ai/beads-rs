{"_at":[1768197280720,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] serde roundtrip tests for new wire types.\n- [ ] TxnDeltaV1 rejects duplicate op keys and preserves canonical ordering.\n- [ ] Conversions to and from core domain types are covered for at least one bead and note case.","assignee":"darin@darinsmacstudio.lan","created_at":[1768177746679,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nRealtime events need a canonical delta representation that is not tied to the legacy git wire format. Today only src/git/wire.rs exists, so the realtime lane has no typed delta basis for EventBody and no canonical op ordering.\n\n**Context**\n- REALTIME_PLAN.md 0.7 (delta schema choice) and 2.4 (TxnDeltaV1 fields)\n- Stateright model: beads_stateright_models/src/realtime_types_sketch.rs (WireBeadPatch, NotesPatch, TxnOpKey, TxnDeltaV1)\n\n**Files:** src/core/wire_bead.rs (new), src/core/mod.rs, src/git/wire.rs (reference only)","design":"**Design**\n- Define core wire structs: WireBeadPatch, WireNoteV1, NotesPatch (Omitted vs AtLeast), NoteAppendV1, and TxnOpV1.\n- Define TxnOpKey and represent TxnDeltaV1 as a canonical map keyed by TxnOpKey to enforce unique ops and stable ordering for hashing and encoding.\n- Keep field names compatible with legacy wire to ease conversion, but keep types in core to avoid coupling realtime to git.\n- Provide conversions between domain types (Bead, Note, Tombstone, DepEdge) and wire structs when lossless.\n- Document notes rule: patches omit notes by default; if present they mean set union only (no truncation).","id":"bd-3m5.4","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 2: Core wire delta types","type":"task"}
{"_at":[1768908044309,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] TxnDeltaV1 roundtrips with new ops\n- [ ] Legacy dep ops removed\n- [ ] TxnOpKey includes dot for add ops\n\n**Invariants to re-verify**\n- [ ] TxnOpKey uniqueness preserved for multiple dots on same value\n- [ ] No labels/notes on WireBeadPatch; no dep upsert/delete ops","assignee":"darin@book","created_at":[1768894651610,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWireBeadPatch carries labels and NotesPatch; deps are LWW ops. We need explicit OR-Set ops.\n\n**Files**\n- src/core/wire_bead.rs","design":"Remove:\n- WireBeadPatch.labels\n- NotesPatch from patch\n- WireDepV1/WireDepDeleteV1\nAdd:\n- WireDotV1, WireDvvV1\n- WireLabelAddV1/RemoveV1\n- WireDepAddV1/RemoveV1\nUpdate TxnOpV1 and TxnOpKey (include dot in add keys).","id":"bd-3zoj.5","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Wire ops: Label/Dep add/remove + dot/dvv; remove labels/notes from patch","type":"task"}
{"_at":[1765774451912,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@dusk","created_at":[1765690392394,0],"created_by":"darin@darinsmcstudio2.lan","description":"## What's Wrong\n`Request::Init` ignores errors from `ensure_repo_loaded` (TODO in code). Also `SyncWait` behavior is duplicated: `Daemon::handle_request` returns Synced immediately, but `run_state_loop` has special-case barrier logic.\n\n## Where\n- src/daemon/core.rs:585 (TODO: ignores ensure_repo_loaded errors after init)\n- src/daemon/core.rs:559 (SyncWait returns immediately)\n- src/daemon/server.rs:45 (SyncWait handled as a barrier before calling daemon)\n\n## Why It Matters\nInit can report success even if repo state isn't loadable, leading to confusing follow-on failures. Duplicated SyncWait logic makes correctness brittle and creates drift.\n\n## Suggested Fix\n- Make Init return an error (or include warning details) if `ensure_repo_loaded` fails.\n- Consolidate SyncWait into one place (prefer state loop barrier) and remove/clarify the other path.\n\n## Acceptance\n- `bd init` fails (or returns structured warning) when it cannot load the repo state.\n- `SyncWait` has a single source of truth (no duplicate paths).","id":"bd-5wc","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Daemon init should not ignore ensure_repo_loaded errors; dedupe SyncWait","type":"chore"}
{"_at":[1768541691221,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] git commands used in RealtimeFixture fail fast with clear error messages.\\n- [ ] No silent ignore of non-zero exit status.","assignee":"darin@book","created_at":[1768509364469,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\n- tests/integration/fixtures/realtime.rs runs git commands via Command::output() but ignores exit status.\\n- If git fails (missing binary, permission), tests fail later with confusing errors.\\n\\n**Files**\\n- tests/integration/fixtures/realtime.rs","design":"Create a small helper (e.g., run_git(args, cwd) -> Result<()>) that checks status.success(), includes stderr/stdout in error, and is used for init/config/remote commands. Consider returning Result from init_git_repo and wiring RealtimeFixture::new to propagate the error (or panic with context).","id":"bd-ja8c","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Fixtures: validate git init in RealtimeFixture","type":"chore"}
{"_at":[1768622428755,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622428755,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nbeads-rs lacks the Convoy issue type - a cross-project tracking primitive with reactive completion. Convoys track multiple issues (potentially across repos) and automatically close when all tracked items complete. This enables coordinated multi-project work.\n\n**What Convoys Do (from Go beads)**\nConvoy is a lightweight tracking container that uses the 'tracks' dependency relation (non-blocking). When any tracked issue closes, convoy checks if all tracked items are complete and auto-closes if so. This is reactive completion - no polling needed.\n\nUse cases:\n- Track related work across multiple repos\n- Group cross-cutting concerns (security audit, docs update, etc.)\n- Coordinate releases (track all pre-release tasks)\n- Monitor distributed swarm work\n\n**Go Implementation**\nType definition in internal/types/types.go:\n- IssueType = TypeConvoy (line 493)\n- Uses standard Issue fields (no custom fields)\n- Relies on 'tracks' dependency relation (DependencyType)\n\nDependency tracking (internal/types/types.go line 713):\n- DepTracks: convoy.issue_id tracks target.depends_on_id\n- Non-blocking (doesn't affect ready work calculation)\n- Direction: convoy â†’ tracked issue\n\nReactive completion (internal/storage/sqlite/transaction.go lines 583-650):\nWhen any issue closes, query for convoys tracking it:\n```sql\nSELECT i.id FROM issues i\nJOIN dependencies d ON d.issue_id = i.id AND d.type = 'tracks'\nJOIN labels l ON i.id = l.issue_id AND l.label = 'gt:convoy'\nWHERE d.depends_on_id = ? AND i.status != 'closed'\n```\nFor each convoy, check if ALL tracked items are closed. If yes, auto-close convoy.\n\nNote: Uses 'gt:convoy' label instead of issue_type for Gas Town separation.\n\n**Design for Rust**\nData model (src/core/):\nNo special fields needed - convoys are regular beads with:\n- Standard Issue fields\n- 'tracks' dependencies to tracked items\n- Reactive completion logic in close handler\n\nReactive completion (src/daemon/ or src/core/):\nWhen closing any bead:\n1. Find all convoys that track this bead (traverse 'tracks' edges incoming)\n2. For each convoy, check if all tracked items are closed\n3. If yes, auto-close convoy with reason \"All tracked items complete\"\n\nCLI (src/cli/):\n- bd create --type convoy \"Track release work\"\n- bd dep add <convoy-id> <tracked-id> --type tracks\n- bd dep list <convoy-id> -t tracks (show what convoy tracks)\n- bd list --type convoy (filter convoys)\n\n**Design Notes**\n- Convoy is more about behavior (reactive close) than structure\n- 'tracks' relation must be non-blocking (doesn't affect bd ready)\n- Multi-repo tracking needs cross-repo dependency support\n- Auto-close should include metadata (which issues triggered completion)\n- Consider: Should convoy completion cascade to parent convoys?\n\n**Acceptance**\n- [ ] Convoy type constant defined\n- [ ] 'tracks' dependency type added to DependencyType enum\n- [ ] DepTracks marked as non-blocking (doesn't affect ready work)\n- [ ] Bead close handler checks for tracking convoys\n- [ ] Convoy auto-closes when all tracked items are closed\n- [ ] bd create --type convoy works\n- [ ] bd dep add supports --type tracks\n- [ ] bd dep list shows tracks relationships\n- [ ] Tests for convoy reactive completion\n- [ ] Tests for convoy with cross-repo tracked items (if multi-repo supported)\n- [ ] Migration from Go beads preserves convoy type and tracks relations\n\n**Files to study in Go beads:**\n- tmp/beads/internal/types/types.go (line 493: TypeConvoy, line 713: DepTracks)\n- tmp/beads/internal/storage/sqlite/transaction.go (lines 583-650: reactive completion)\n- tmp/beads/cmd/bd/types.go (line 26: convoy description)","id":"bd-ze0x.13","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":3082487056783492846,"replica":"2e3c15ae-5540-814d-4aad-3e9edd25f2d5"}]}},"priority":2,"status":"open","title":"Add Convoy issue type support","type":"feature"}
{"_at":[1768622395742,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622395742,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nGo beads supports `bd relate <id1> <id2>` and `bd unrelate <id1> <id2>` for creating bidirectional \\\"see also\\\" links between issues. This enables knowledge graph connections without blocking or hierarchy. beads-rs needs the same capability.\n\n**How it works in Go beads**\n- Commands: `bd relate` and `bd unrelate` (in cmd/bd/relate.go)\n- Creates bidirectional relates-to links using the dependency API\n- Uses `DepRelatesTo` dependency type (stored in dependencies table)\n- Both issues reference each other (id1 -> id2 and id2 -> id1)\n- Non-blocking relationship (doesn't affect ready work calculation)\n\n**Design for Rust**\n1. Add `RelatesTo` variant to `DepKind` enum in src/core/domain.rs\n2. Mark it as non-DAG-enforcing (like Related and DiscoveredFrom)\n3. Add CLI commands: src/cli/commands/relate.rs\n   - `bd relate <id1> <id2>` - creates both edges atomically\n   - `bd unrelate <id1> <id2>` - removes both edges atomically\n4. Wire through daemon IPC in src/daemon/ for atomic bidirectional operations\n5. Add to CLI command tree in src/cli/mod.rs\n\n**Design considerations**\n- Bidirectional atomicity: both edges created/removed in same operation\n- Prevent self-relations (id1 == id2)\n- Handle partial failures gracefully\n- JSON output shows both IDs and relation status\n\n**Files to study**\n- tmp/beads/cmd/bd/relate.go - Go implementation reference\n- tmp/beads/internal/types/types.go - DepRelatesTo type definition\n- src/core/domain.rs - where DepKind lives\n- src/cli/commands/dep.rs - similar command pattern\n\n**Acceptance**\n- [ ] RelatesTo added to DepKind enum\n- [ ] bd relate command creates bidirectional links\n- [ ] bd unrelate command removes bidirectional links\n- [ ] Self-relations rejected with clear error\n- [ ] JSON output format matches Go beads\n- [ ] Cargo fmt, clippy, test all pass","id":"bd-ze0x.2","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":10654888833020258604,"replica":"230b2c64-03b7-e293-f144-a90b8cb3e774"}]}},"priority":2,"status":"open","title":"Add relate/unrelate CLI commands for bidirectional graph links","type":"feature"}
