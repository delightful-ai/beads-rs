{"_at":[1768480026633,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768454419019,1],"darin@book"],"claim":[[1768478743001,1],"darin@book"],"description":[[1768454419019,1],"darin@book"],"design":[[1768454419019,1],"darin@book"],"estimated_minutes":[[1768454419019,1],"darin@book"],"external_ref":[[1768454419019,1],"darin@book"],"labels":[[1768454419019,1],"darin@book"],"priority":[[1768454419019,1],"darin@book"],"source_repo":[[1768454419019,1],"darin@book"],"title":[[1768454419019,1],"darin@book"],"type":[[1768454419019,1],"darin@book"]},"assignee":"darin@book","assignee_at":[1768478743001,1],"assignee_expires":1768482343001,"closed_at":[1768480026633,1],"closed_by":"darin@book","created_at":[1768454419019,1],"created_by":"darin@book","description":"**Problem**\nREALTIME_PLAN ยง13.3 calls for `roster_hash` in checkpoint meta and warnings on mismatch. `StoreRuntime::checkpoint_snapshot` always sets `roster_hash = None`, and there is no roster hash computation anywhere. This loses the audit trail for durability eligibility changes.\n\n**Design**\n- Compute roster hash from validated `replicas.toml` (canonical JSON) when present.\n- Include it in `CheckpointSnapshot` + meta; surface mismatch warnings on import.\n\n**Acceptance**\n- [ ] roster_hash is present when a replica roster exists.\n- [ ] Checkpoint import compares roster_hash and emits a warning on mismatch.\n- [ ] Tests cover hash stability + mismatch warning.\n\n**Files:** src/daemon/store_runtime.rs, src/git/checkpoint/meta.rs, src/git/checkpoint/import.rs","id":"bd-3m5.106","labels":[],"priority":3,"status":"closed","title":"Checkpoint meta never includes roster_hash","type":"bug"}
{"_at":[1768525369990,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768512755367,1],"darin@book"],"claim":[[1768524840002,1],"darin@book"],"description":[[1768512755367,1],"darin@book"],"design":[[1768512755367,1],"darin@book"],"estimated_minutes":[[1768512755367,1],"darin@book"],"external_ref":[[1768512755367,1],"darin@book"],"labels":[[1768512755367,1],"darin@book"],"priority":[[1768512755367,1],"darin@book"],"source_repo":[[1768512755367,1],"darin@book"],"title":[[1768512755367,1],"darin@book"],"type":[[1768512755367,1],"darin@book"]},"acceptance_criteria":"- [ ] subscribe_gates_on_require_min_seen passes reliably.\n- [ ] Subscribe stream failure modes return a structured error (not just disconnect) when possible.\n- [ ] Test setup avoids daemon lifecycle races if needed.","assignee":"darin@book","assignee_at":[1768524840002,1],"assignee_expires":1768528440002,"closed_at":[1768525369990,1],"closed_by":"darin@book","created_at":[1768512755367,1],"created_by":"darin@book","description":"**Problem**\nsubscribe_gates_on_require_min_seen fails in tests/integration/daemon/subscribe.rs:104 with Ipc(Disconnected) during the normal integration run (cargo test --test integration). This indicates the subscription stream closes unexpectedly during require_min_seen gating. The same test passed in a subsequent slow-tests run, suggesting a race or lifecycle issue rather than a deterministic assertion failure.\n\n**Repro**\n- cargo test --test integration (failed on 2026-01-15)\n\n**Files**\n- tests/integration/daemon/subscribe.rs\n- src/daemon/ipc/* (subscribe stream), src/daemon/core.rs (subscribe handling), broadcaster/gating logic","design":"Investigate why the IPC subscription stream closes during require_min_seen gating. Add structured logging around subscribe open/close paths and daemon lifecycle. Verify the daemon is started and the subscribe request is not racing daemon startup or shutdown. If the stream closes due to a specific error (gate timeout, overload, unexpected payload), surface that explicitly instead of a bare disconnect. Stabilize the test by ensuring the daemon is ready before subscribing or by retrying transient disconnects if the daemon is still live.","id":"bd-mrbx","labels":[],"priority":2,"status":"closed","title":"Integration test failure: subscribe require_min_seen disconnects","type":"bug"}
