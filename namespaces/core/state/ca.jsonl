{"_at":[1768209947141,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Database initializes with expected tables and indices.\n- [ ] WalIndexWriter and WalIndexReader trait methods are implemented.\n- [ ] Schema version is stored and validated on open.","assignee":"darin@darinsmacstudio.lan","created_at":[1768177825649,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nPhase 3: add WAL SQLite index with schema and reader and writer traits. There is no SQLite index today; WAL is a snapshot file. The realtime plan requires a rebuildable index for event lookup, idempotency, and watermarks.\n\n**Context**\n- REALTIME_PLAN.md ยง0.11 (schema decisions) and ยง6.2 (table layout)\n- SQLite PRAGMA choices in ยง6.4\n**Files:** src/daemon/wal/index.rs (new), src/daemon/wal/mod.rs, Cargo.toml (rusqlite)","design":"**Design**\n- Implement schema for events, watermarks, client_requests, origin_seq, segments, meta (per plan).\n- Add WalIndexWriter and WalIndexReader traits with methods from REALTIME_PLAN.md ยง6.1.\n- Use UUIDs as 16 byte BLOBs. Store event_ids as CBOR encoded Vec<EventId> in client_requests.\n- Configure SQLite with PRAGMA: journal_mode=WAL, synchronous=NORMAL (configurable), foreign_keys=ON, busy_timeout.\n- Add schema version in meta table and enforce upgrade rules.","id":"bd-3m5.10","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 3: SQLite WAL index + WalIndex traits","type":"task"}
{"_at":[1770936635642,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Existing checkpoints import without repeated `WireLabelStateV1` decode warnings.\n- [ ] Label state parity is preserved after import (no silent drop/regression).\n- [ ] Version compatibility tests cover old and new encodings.\n- [ ] Logs include actionable error context when an unknown future wire version is encountered.","created_at":[1770936635642,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nDaemon checkpoint import repeatedly logs decode failures for label state (`invalid length 0, expected struct WireLabelStateV1 with 2 elements`). This indicates wire-compat mismatch or invalid fallback handling in checkpoint decode.\n\nRisk: noisy logs, extra recovery work, and possible state omission if decode fallback is incomplete.","design":"Make checkpoint decoding robust and explicitly versioned:\n1. Audit wire schema/version negotiation for label state.\n2. Add backwards-compatible decode path(s) for historical payload shapes.\n3. Fail soft with typed diagnostics and targeted fallback instead of repeated generic warnings.\n4. Add roundtrip and fixture tests across old/new checkpoint payloads.","id":"bd-ppd1","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"open","title":"Checkpoint label decode incompatibility spams warnings and risks state gaps","type":"bug"}
