{"_at":[1768187523392,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] ErrorCode covers every entry in REALTIME_ERRORS.md and is the sole mapping to code strings.\n- [ ] ErrorPayload serializes to both JSON (IPC) and CBOR (replication) with optional fields omitted when empty.\n- [ ] Tests verify retryable and receipt fields are preserved and unknown codes do not break decoding.","assignee":"darin@darinsmacstudio.lan","created_at":[1768178713781,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWe need a single, truthful error vocabulary shared by IPC and replication. Today error mapping is scattered (OpError/CoreError/IpcError) and ErrorPayload in src/daemon/ipc.rs lacks retryable/receipt fields. That creates multiple representations of the same failure and forces clients to interpret strings ad hoc.\n\n**Context**\n- REALTIME_PLAN.md §0.14 (error payload standardization) and §9.10 (replication error handling)\n- REALTIME_ERRORS.md (canonical error code registry)\n- Current error plumbing: src/core/error.rs, src/error.rs, src/daemon/ipc.rs, src/daemon/repl/proto.rs (new)\n\n**Files:** src/core/error.rs (new or expanded), src/error.rs, src/daemon/ipc.rs, src/api/mod.rs, src/daemon/repl/proto.rs, REALTIME_ERRORS.md","design":"**Design**\n- Introduce ErrorCode enum with stable string mappings for every code in REALTIME_ERRORS.md; make it the single source of truth for code strings.\n- Define ErrorPayload { code, message, retryable, retry_after_ms?, details?, receipt? } in core and re-use it in IPC JSON and replication CBOR.\n- Provide From conversions from CoreError/OpError/IpcError/SyncError into ErrorPayload with consistent retryable/effect semantics.\n- Enforce that unknown codes are tolerated by clients; only retry when retryable=true.\n- Keep ErrorPayload schema version stable; add fields only as optional to preserve compatibility.","id":"bd-3m5.25","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Phase 1: Core error types + ErrorPayload","type":"task"}
{"_at":[1768456911759,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768444178286,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nREALTIME_PLAN §3.1 requires rejecting non-canonical integer encodings in EventBody. Current decode uses minicbor::Decoder u64/u32 directly and never checks for non-minimal integer encodings, so overlong integer encodings are accepted.\n\nEvidence:\n- src/core/event.rs:1650–1667 decode_u32 uses dec.u64 with no canonicality check.\n- No canonical integer validation exists in decode_map_len/decode_array_len/decode_u32.\n\n**Why this violates plan**\nCanonical CBOR is a correctness primitive for hashed payloads. Accepting non-canonical integers undermines deterministic validation requirements.\n\n**Acceptance**\n- [ ] Implement strict integer decoding that rejects non-minimal encodings (and tags).\n- [ ] Apply to all integer fields in EventBody/TxnDelta/HlcMax.\n- [ ] Add tests that reject overlong integer encodings.","id":"bd-3m5.85","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"CBOR decode does not reject non-canonical integer encodings","type":"bug"}
{"_at":[1769219167693,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Unit test: encoding a tombstone with lineage=None produces correct map length.\\n- [ ] Unit test: decoding a tombstone with only one lineage field returns a validation error.\\n- [ ] Roundtrip test: tombstone with lineage Some(at,by) encodes and decodes identically.\\n- [ ] Regression test: validate_event_body rejects tombstone with partial lineage before encoding.","assignee":"darin@book","created_at":[1769209799557,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\nencode_wire_tombstone can emit invalid CBOR if exactly one lineage field is set; debug_assert is skipped in release. This risks corrupt WAL/replication frames.\\n\\n**Files**: src/core/event.rs, src/core/wire_bead.rs, src/git/checkpoint/*","design":"**Design**\\nMake tombstone lineage pairing a typestate invariant. Replace the two Option fields with a single Option<LineageStamp> (struct containing at+by). Encode only when lineage is Some. Add runtime validation that rejects partial lineage in decode or construction paths.\\n\\nAlso add a semantic validator hook for tombstones so invalid lineage can never reach encoding.\\n\\nUpdate wire conversion helpers (checkpoint import/export) to use the new lineage representation.","id":"bd-qz97.2","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Tombstone lineage pairing: make invalid lineage state unrepresentable","type":"bug"}
{"_at":[1769761162486,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] Canonical set types exist in `beads-core` and enforce ordering/dedup at construction.\n- [ ] All current normalizer helpers are removed or reduced to thin adapters to the new types.\n- [ ] Checkpoint export, repl session, and mutation engine use canonical sets instead of raw vectors.\n- [ ] Tests cover ordering/dedup stability and JSON roundtrip for at least two set types.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769573989704,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nUnordered collections are represented as raw `Vec`/`String` in multiple layers, and each call site re-sorts/dedups to get canonical order.\n\nExamples:\n- `normalize_namespaces` in `crates/beads-rs/src/git/checkpoint/export.rs`\n- `normalize_namespaces` in `crates/beads-rs/src/daemon/repl/session.rs`\n- `canonical_deps` in `crates/beads-rs/src/daemon/mutation_engine.rs`\n- `DepSpec::parse_list` returns raw `Vec<DepSpec>` in `crates/beads-core/src/dep.rs`\n\nThis is scatter + drift: the \"same\" collection can have different ordering/dup semantics depending on which normalizer you remembered to call.\n\n**Files:**\n- `crates/beads-core/src/dep.rs`\n- `crates/beads-rs/src/git/checkpoint/export.rs`\n- `crates/beads-rs/src/daemon/repl/session.rs`\n- `crates/beads-rs/src/daemon/mutation_engine.rs`\n- `crates/beads-core/src/collections.rs` (if adding set types)","design":"**Design**\nIntroduce canonical set types for frequently normalized collections and use them across boundaries.\n\nConcrete plan:\n1) Add canonical set wrappers in `beads-core`:\n   - `NamespaceSet`\n   - `DepSpecSet`\n   - `LabelSet` (if not already modeled)\n2) Construction performs sort + dedup and enforces any domain constraints.\n3) Provide stable iteration order and `Serialize`/`Deserialize` as arrays.\n4) Replace ad-hoc normalizers (`normalize_namespaces`, `canonical_deps`, etc.) with these types.\n5) Update APIs to accept/return the canonical set types, not raw vectors.\n\n**Design Notes**\n- For performance, the set can store a `Vec` plus a flag that it is already canonical.\n- Provide `from_vec_unchecked` only for trusted internal uses (tests/fixtures).","id":"bd-x5vl","labels":{"cc":{"max":{}},"entries":{"consistency":[{"counter":17898955235301714852,"replica":"da0c1333-f460-e74a-5b00-d977fa78e30c"}],"scatter":[{"counter":4859875972913792609,"replica":"8073d7b3-f7d3-5b03-e5cc-4864714584cc"}],"types":[{"counter":11664029674433400982,"replica":"70b255b2-30eb-fac0-7c5b-36191fb6964f"}]}},"priority":2,"status":"closed","title":"Canonical set types for unordered collections","type":"chore"}
{"_at":[1768622624996,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622624996,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nbeads-rs has hardcoded issue types (bug, feature, task, epic, chore). Users cannot define project-specific types (experiment, spike, incident, etc.). This limits expressiveness and forces users to shoehorn domain concepts into generic types.\n\n**What Custom Types Enable (from Go beads)**\nCustom types allow projects to define their own vocabulary:\n- Research projects: experiment, hypothesis, analysis\n- SRE: incident, postmortem, oncall\n- Design: mockup, prototype, usability-test\n- Any domain-specific concept\n\nConfiguration:\n```toml\n[types]\ncustom = [\"experiment\", \"spike\", \"incident\", \"postmortem\"]\n```\n\nValidation:\n- Built-in types: Always valid (catch typos)\n- Custom types: Valid per project (trust local config)\n- Federation: Trust child repo's custom types (don't re-validate)\n\n**Go Implementation**\nType validation (internal/types/types.go):\n```go\n// IsValid checks built-in types only\nfunc (t IssueType) IsValid() bool {\n    switch t { case TypeBug, TypeFeature, ... }\n}\n\n// IsValidWithCustom checks built-in + custom\nfunc (t IssueType) IsValidWithCustom(customTypes []string) bool {\n    if t.IsValid() { return true }\n    for _, custom := range customTypes {\n        if string(t) == custom { return true }\n    }\n    return false\n}\n```\n\nConfig integration (internal/configfile/config.go):\n```go\ntype Config struct {\n    Types struct {\n        Custom []string `toml:\"custom\"`\n    } `toml:\"types\"`\n}\n```\n\nCLI usage:\n- bd config set types.custom \"exp,spike,incident\"\n- bd create --type experiment \"Test hypothesis\"\n- bd list --type experiment\n\nFederation trust model (lines 367-391):\nWhen importing from child repo:\n- Built-in types: Validate (catch typos like \"tsak\")\n- Custom types: Trust (child already validated)\nThis implements \"trust the chain below you\" from HOP.\n\n**Design for Rust**\nData model (src/core/):\n```rust\npub enum IssueTypeVariant {\n    Bug, Feature, Task, Epic, Chore,\n    Gate, Agent, Role, Rig, Convoy, Event, Slot,\n    Message, MergeRequest, Molecule,\n    Custom(String),  // Project-specific types\n}\n\nimpl IssueTypeVariant {\n    pub fn is_builtin(&self) -> bool;\n    pub fn validate(&self, custom_types: &[String]) -> bool;\n}\n```\n\nConfig (src/config/):\n```toml\n[types]\ncustom = [\"experiment\", \"spike\"]\n```\n\nParse in Config struct:\n```rust\npub struct Config {\n    pub types: TypesConfig,\n}\n\npub struct TypesConfig {\n    pub custom: Vec<String>,\n}\n```\n\nValidation:\n```rust\nimpl Bead {\n    pub fn validate(&self, config: &Config) -> Result<(), Error> {\n        self.issue_type.validate(&config.types.custom)?;\n        // ...\n    }\n}\n```\n\nCLI (src/cli/):\n- bd config set types.custom \"exp,spike\"\n- bd config get types.custom\n- bd create --type <custom-type>\n- bd list --type <custom-type>\n\n**Design Notes**\n- Custom types are strings, not validated at compile time\n- Type aliases (feat → feature) still useful for custom types\n- Federation: Import trusts source repo's custom types\n- Consider: Type hierarchy/inheritance (spike extends experiment)\n- Consider: Type-specific field requirements (validate by type)\n- Consider: Type namespacing (rig:experiment vs hq:experiment)\n- Consider: Type discovery (bd types list --all shows built-in + custom)\n\n**Acceptance**\n- [ ] IssueTypeVariant enum with Custom(String) variant\n- [ ] Config.types.custom field\n- [ ] bd config set/get types.custom works\n- [ ] Validation allows built-in + custom types\n- [ ] Validation rejects unknown types\n- [ ] bd create --type <custom> works\n- [ ] bd list --type <custom> filters correctly\n- [ ] bd types command shows built-in + custom\n- [ ] Federation import trusts custom types from source\n- [ ] Tests for custom type validation\n- [ ] Tests for config persistence\n- [ ] Migration from Go beads preserves custom types in config\n\n**Files to study in Go beads:**\n- tmp/beads/internal/types/types.go (lines 518-529: IsValidWithCustom)\n- tmp/beads/internal/types/types.go (lines 367-391: federation trust model)\n- tmp/beads/internal/configfile/config.go (custom types config)\n- tmp/beads/cmd/bd/create.go (type validation with custom)","id":"bd-ze0x.53","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":2750684509595509687,"replica":"c6072481-5e92-c56a-c3b8-14693550c64e"}]}},"priority":2,"status":"open","title":"Add custom types system support","type":"feature"}
{"_at":[1769597866832,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"Acceptance\n- Update requests with title/description set to empty/whitespace are rejected with OpError::ValidationFailed.\n- Types prevent constructing a patch with empty required fields after parsing.\n- Tests cover update rejection and valid trimmed updates.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769565897011,0],"created_by":"darin@darinsmcstudio2.lan","description":"Problem\n- ParsedBeadPatch::parse only blocks Patch::Clear for title/description but allows Patch::Set(\"\") or whitespace.\n- Creates invalid state: required fields present but empty.\n- Create path enforces non-empty; update does not.\n\nImpact\n- Invariant drift between create/update; data quality issues and UI regressions.\n- Not encoded in types (string vs non-empty string).\n","design":"Design\n- Introduce NonEmptyString (or reuse existing type) for required fields at the parse boundary.\n- Normalize (trim) and reject empty values during ParsedBeadPatch::parse.\n- Make CanonicalBeadPatch carry validated non-empty strings for title/description patches, so downstream code never sees invalid values.\n\nScatter fit\n- Single validation point in parse; no downstream checks.\n\nFiles\n- crates/beads-rs/src/daemon/mutation_engine.rs\n- crates/beads-surface/src/ops.rs (if adding NonEmptyString)\n- crates/beads-core/src/event.rs (if validating patch types)","id":"bd-znle","labels":{"cc":{"max":{}},"entries":{}},"notes":[{"at":[1769597741143,0],"author":"darin@darins-Mac-Studio-2.local","content":"Rendering should stay in the command files themselves (no central render move).","id":"go-comment-bd-znle-1"},{"at":[1769597866832,0],"author":"darin@darinsmcstudio2.lan","content":"Rendering should stay in the command files themselves (no central render move).","id":"legacy-notes"}],"priority":1,"status":"closed","title":"mutation: required fields must be non-empty on update","type":"bug"}
{"_at":[1768428574356,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768387630958,0],"created_by":"darin@darinsmcstudio2.lan","description":"Full cargo test failed: test_update_bead saw type task after update. Running the test alone and critical_path with --test-threads=1 passes. Likely shared runtime dir/daemon across parallel tests.","id":"bd-zwn","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"critical_path test_update_bead flaky in parallel runs","type":"bug"}
