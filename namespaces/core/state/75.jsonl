{"_at":[1768404782046,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768180782214,1],"darin@darinsmacstudio.lan"],"claim":[[1768404016133,1],"darin@book"],"description":[[1768180782214,1],"darin@darinsmacstudio.lan"],"design":[[1768180782214,1],"darin@darinsmacstudio.lan"],"estimated_minutes":[[1768180782214,1],"darin@darinsmacstudio.lan"],"external_ref":[[1768180782214,1],"darin@darinsmacstudio.lan"],"labels":[[1768180782214,1],"darin@darinsmacstudio.lan"],"priority":[[1768180782214,1],"darin@darinsmacstudio.lan"],"source_repo":[[1768180782214,1],"darin@darinsmacstudio.lan"],"title":[[1768180782214,1],"darin@darinsmacstudio.lan"],"type":[[1768180782214,1],"darin@darinsmacstudio.lan"]},"assignee":"darin@book","assignee_at":[1768404016133,1],"assignee_expires":1768407616133,"closed_at":[1768404782046,1],"closed_by":"darin@book","created_at":[1768180782214,1],"created_by":"darin@darinsmacstudio.lan","description":"**Problem**\nPhase 4 implementation must be verified before Phase 5 starts.\n\n**Context**\n- REALTIME_PLAN.md §18: origin_seq allocation, idempotency mapping/receipts\n- Depends on: Phase 4 implementation + Phase 4 test infrastructure\n\n**Design**\nDeterministic tests for:\n- Idempotency: same client_request_id → same txn_id + event_ids on retry\n- Request hash mismatch: same client_request_id, different request → ERROR\n- Receipt min_seen: advances monotonically with watermarks\n- Receipt after restart: txn_id/event_ids preserved, durability_proof may differ\n- No duplicate origin_seq: crash + restart → next seq is max+1\n\n**Acceptance**\n- [ ] tests/phase4_idempotency.rs: idempotency mapping tests\n- [ ] tests/phase4_receipts.rs: receipt semantics tests\n- [ ] Test: request_sha256 mismatch returns error code\n- [ ] Test: receipt survives daemon restart\n- [ ] cargo test phase4_ passes\n\n**Files:** tests/phase4_idempotency.rs (new), tests/phase4_receipts.rs (new)","id":"bd-3m5.60","labels":[],"priority":2,"status":"closed","title":"Phase 4 tests: idempotency mapping + receipts","type":"task"}
{"_at":[1765786356990,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1765744417943,0],"darin@book"],"claim":[[1765786078983,0],"darin@dusk"],"description":[[1765744417943,0],"darin@book"],"design":[[1765744417943,0],"darin@book"],"estimated_minutes":[[1765744417943,0],"darin@book"],"external_ref":[[1765744417943,0],"darin@book"],"labels":[[1765744417943,0],"darin@book"],"priority":[[1765744417943,0],"darin@book"],"source_repo":[[1765744417943,0],"darin@book"],"title":[[1765744417943,0],"darin@book"],"type":[[1765744417943,0],"darin@book"]},"assignee":"darin@dusk","assignee_at":[1765786078983,0],"assignee_expires":1765789678983,"closed_at":[1765786356990,0],"closed_by":"darin@dusk","closed_reason":"Added LoadedRemote proof type. ensure_repo_loaded/fresh return LoadedRemote, repo_state/repo_state_mut take &LoadedRemote and are infallible. All .unwrap() calls on repo_state lookups removed.","created_at":[1765744417943,0],"created_by":"darin@book","description":"**Problem**\nAfter `ensure_repo_loaded()`, we \"know\" the repo exists, but the type does not prove it:\n```rust\nlet remote = self.ensure_repo_loaded(repo, git_tx)?;\n// ... later ...\nlet repo_state = self.repo_state_mut(&remote).unwrap(); // \"I know it is there\"\n```\n\n**Design**\nCreate a proof type that can only be constructed by loading:\n```rust\n/// Proof that a repo is loaded. Only created by Daemon::ensure_repo_loaded.\npub struct LoadedRemote(RemoteUrl);\n\nimpl LoadedRemote {\n    pub fn remote(&self) -> &RemoteUrl { &self.0 }\n}\n\nimpl Daemon {\n    pub fn ensure_repo_loaded(&mut self, repo: &Path, git_tx: &Sender<GitOp>) \n        -> Result<LoadedRemote, OpError> \n    {\n        let remote = self.resolve_remote(repo)?;\n        // ... loading logic ...\n        Ok(LoadedRemote(remote))\n    }\n\n    /// Infallible because LoadedRemote proves existence\n    pub fn repo_state(&self, proof: &LoadedRemote) -> &RepoState {\n        self.repos.get(proof.remote())\n            .expect(\"LoadedRemote guarantees repo exists\")\n    }\n\n    pub fn repo_state_mut(&mut self, proof: &LoadedRemote) -> &mut RepoState {\n        self.repos.get_mut(proof.remote())\n            .expect(\"LoadedRemote guarantees repo exists\")\n    }\n}\n```\n\nThe `expect` is now documentation of a proven invariant, not a latent bug.\n\n**Acceptance**\n- [ ] `LoadedRemote` type exists in `src/daemon/mod.rs` or `src/daemon/state.rs`\n- [ ] `ensure_repo_loaded` returns `LoadedRemote`\n- [ ] `repo_state`/`repo_state_mut` take `&LoadedRemote` parameter\n- [ ] All `.unwrap()` calls on repo_state lookups in executor/query code are removed\n- [ ] Tests pass\n\n**Files:** src/daemon/mod.rs, src/daemon/executor.rs, src/daemon/query_executor.rs","id":"bd-roy","labels":[],"priority":2,"status":"closed","title":"Add LoadedRemote proof type to eliminate repo_state unwraps","type":"chore"}
