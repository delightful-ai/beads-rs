{"_at":[1765832381187,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1765744933723,0],"darin@book"],"claim":[[1765831880118,0],"darin@dusk"],"description":[[1765744933723,0],"darin@book"],"design":[[1765744933723,0],"darin@book"],"estimated_minutes":[[1765744933723,0],"darin@book"],"external_ref":[[1765744933723,0],"darin@book"],"labels":[[1765744933723,0],"darin@book"],"priority":[[1765744933723,0],"darin@book"],"source_repo":[[1765744933723,0],"darin@book"],"title":[[1765744933723,0],"darin@book"],"type":[[1765744933723,0],"darin@book"]},"assignee":"darin@dusk","assignee_at":[1765831880118,0],"assignee_expires":1765835480118,"closed_at":[1765832381187,0],"closed_by":"darin@dusk","created_at":[1765744933723,0],"created_by":"darin@book","description":"**Problem**\n`ensure_repo_fresh()` does a blocking `GitOp::Load` roundtrip on the state thread. Any slow fetch = every client request pauses. OK-ish for small repos, but a design footgun.\n\n**Design**\nMake refresh async:\n- If repo is clean and refresh TTL hit, kick off background load\n- Serve current cached state meanwhile\n- Apply refreshed state when it arrives (maybe invalidate caches)\n- Optionally: let queries request `fresh=true` when they really need it\n\n**Acceptance**\n- [ ] Slow git fetch doesnt block unrelated client requests\n- [ ] Stale reads are bounded (TTL still respected eventually)\n- [ ] Fresh flag available for queries that need it\n\n**Files:** src/daemon/mod.rs, src/daemon/query_executor.rs","id":"bd-a5v","labels":[],"priority":2,"status":"closed","title":"Blocking freshness loads stall entire daemon","type":"bug"}
