{"_at":[1768448823313,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Segment writers are reused across multiple events (not one segment per mutation).\n- [ ] A single EventWal append API owns the write + fsync + index sequencing invariant.\n- [ ] Executor and replication ingest no longer manually open SegmentWriter directly.","closed_reason":"duplicate of bd-3m5.82","created_at":[1768444195661,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nEvery mutation opens a fresh `SegmentWriter` and creates a new WAL segment, so we effectively write one segment per event. There is no `EventWal` type that owns per‑namespace writers and enforces the append/index/fsync ordering invariant; instead, the executor and core manually sequence these steps.\n\n**Signals / Evidence**\n- `apply_mutation_request_inner` creates a new `SegmentWriter::open` for every mutation (`src/daemon/executor.rs`).\n- `ingest_remote_batch` also opens a new `SegmentWriter` per batch (`src/daemon/core.rs`).\n- `wal/mod.rs` exposes low‑level pieces but no high‑level append API; the invariants live in call sites.\n\n**Why this hurts velocity**\nWe keep duplicating WAL/index sequencing logic, and segment rotation logic never gets a chance to do its job. Any change to WAL invariants requires editing multiple call sites and is easy to get subtly wrong.","design":"**Design**\n- Introduce an `EventWal` (or `WalAppender`) struct in `src/daemon/wal` that owns per‑namespace active `SegmentWriter`s.\n- Provide append APIs that encapsulate: (1) allocate seq, (2) write record, (3) fsync, (4) index updates, (5) watermark updates.\n- Keep a per‑namespace writer in `StoreRuntime` (or in EventWal) so segments are reused and rotation is meaningful.\n- Update mutation and replication ingest to go through this API.\n\n**Design Notes**\nThis aligns with the plan’s “EventWal::append” responsibility and moves invariants into one type instead of scattered call sites.","id":"bd-l5k","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Introduce EventWal append API + reuse segment writers","type":"task"}
{"_at":[1768641208664,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Roster update + reload path exercised in e2e.\n- [ ] Store_epoch bump path exercised; peers reconnect without data loss.\n- [ ] Replication converges post-change.\n- [ ] Tests write only under ./tmp.","assignee":"darin@book","created_at":[1768636580824,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWe do not test dynamic replica roster changes or store_epoch bumps. These are high-risk paths for long-running deployments and upgrades.","design":"**Design**\n- Add integration helpers to update roster (and/or replication config) at runtime and trigger a reload via admin command.\n- If no admin API exists to bump store_epoch, add one (or document the intended mechanism), then simulate an epoch bump and ensure peers reconnect.\n- Add slow e2e that changes roster/epoch mid-flight and asserts continued convergence.","id":"bd-mmoi","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Roster/epoch change e2e for replication","type":"bug"}
