{"_at":[1768282017214,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1768178715136,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nHLC state must be persisted to prevent stamp regression after restart or wall-clock rollback. Recovery must reconstruct HLC from WAL if SQLite is missing.\n\n**Context**\n- REALTIME_PLAN.md §2.8 (write stamps explicit requirements)\n- §6.2 (hlc table in SQLite schema)\n\n**Design**\n- Add `hlc` table to SQLite schema: (actor_id TEXT PK, last_physical_ms INTEGER, last_logical INTEGER)\n- On startup: initialize HLC from max(persisted, system_time)\n- On mint: clamp forward jumps to HLC_MAX_FORWARD_DRIFT_MS (default 600s), log anomaly\n- On index rebuild: scan WAL records for hlc_max and take max per ActorId\n- Persist HLC in same critical section as WAL append/index commit\n\n**Acceptance**\n- [ ] HLC state persisted in SQLite hlc table\n- [ ] Restart recovers HLC without stamp regression\n- [ ] Forward jump clamping logged as anomaly\n- [ ] Index rebuild reconstructs HLC from WAL hlc_max\n\n**Files:** src/daemon/wal/index.rs, src/core/time.rs, src/daemon/mutation_engine.rs","id":"bd-3m5.26","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 4: HLC persistence + recovery","type":"task"}
{"_at":[1768254389567,0],"_by":"darin@darinsmcstudio2.lan","closed_reason":"empty stub - no description","created_at":[1768245306934,0],"created_by":"darin@darinsmcstudio2.lan","description":"","id":"bd-97v","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Crash recovery","type":"task"}
{"_at":[1768619188872,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] `NodeOptions::in_memory()` runs with no WAL files written on disk.\n- [ ] In-memory WAL supports append/flush/rotation and index rebuild paths used in production.\n- [ ] Error handling matches disk WAL semantics (same EventWalError variants).\n- [ ] Add/extend tests: in-memory WAL roundtrip and replication convergence.\n- [ ] All existing tests continue to pass; no regression in disk WAL behavior.","assignee":"darin@book","created_at":[1768616058276,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`NodeOptions::in_memory()` still uses the on-disk Event WAL (with `SegmentSyncMode::None`) and only swaps the index to memory. This means tests still hit the filesystem, depend on WAL directory layout, and can’t run as fully in-memory deterministic simulations. It also makes it harder to test failure cases or performance without disk variability.\n\nWe need a true in-memory Event WAL backend that uses the same logical paths as the production WAL but stores segments/frames in memory (no fsync, no disk IO). This should integrate cleanly with the existing apply/replay/index pipeline and keep error handling parity with the disk WAL.\n\n**Files:** new in-memory WAL module, updates to WAL plumbing and test harness.","design":"**Design**\n- Introduce an Event WAL abstraction (e.g. `EventWalHandle` enum or `EventWalBackend` trait) that covers the methods used by daemon code: `append`, `flush`, `active_segment`, segment snapshot, etc.\n- Implement `MemoryEventWal`:\n  - Store per-namespace segments in memory (Vec<u8> frames), track SegmentHeader/SegmentId, last offsets, sealed/rotation state.\n  - Reuse existing frame/record encoding (`encode_frame`, `SegmentHeader`) so replay logic can be shared.\n  - Generate SegmentRow metadata identically to disk WAL to keep index updates identical.\n  - Provide read helpers for replay/catch-up (either adapt `rebuild_index`/`catch_up_index` to accept a segment source trait, or add `rebuild_index_from_memory` used in tests).\n- Wiring:\n  - Allow StoreRuntime/test harness to swap in memory WAL + memory index for in-memory nodes.\n  - Ensure no WAL files are created on disk for `NodeOptions::in_memory()`.\n- Error parity:\n  - Use the same `EventWalError` variants for corrupt frames/headers so callers get the same error payloads.\n\n**Files:** src/daemon/wal/event_wal.rs (abstraction), src/daemon/wal/memory_wal.rs (new), src/daemon/store/runtime.rs, src/test_harness/mod.rs, tests/e2e.rs or new integration tests.","id":"bd-dxmk","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Implement in-memory Event WAL backend (no filesystem)","type":"feature"}
{"_at":[1769553515194,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1768952743443,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nPR #2 (perf-optimizations) rewrites src/daemon/run.rs accept loop from non-blocking polling to blocking accept + signal wake pattern. bd-4rhy adds span propagation to spawned threads, but targets the old structure.\n\n**Design**\nAfter PR #2 merges:\n1. Keep state_handle and git_handle span propagation (unchanged)\n2. Move client handler span propagation into the new accept_handle's loop\n3. Add span propagation to the new accept_handle thread itself\n\nThe new accept_handle structure:\n```rust\nlet accept_span = tracing::Span::current();\nlet accept_handle = std::thread::spawn(move || {\n    accept_span.in_scope(|| {\n        loop {\n            // ... accept logic ...\n            let client_span = tracing::Span::current();\n            std::thread::spawn(move || {\n                client_span.in_scope(|| handle_client(...));\n            });\n        }\n    });\n});\n```\n\n**Acceptance**\n- [ ] state_handle has span propagation\n- [ ] git_handle has span propagation  \n- [ ] accept_handle has span propagation\n- [ ] client handler threads have span propagation\n- [ ] cargo test passes\n- [ ] Traces show proper parent-child relationships across threads\n\n**Files:** src/daemon/run.rs\n**Depends on:** PR #2 merge","id":"bd-hips","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Adapt bd-4rhy span propagation for PR #2 accept loop rewrite","type":"chore"}
