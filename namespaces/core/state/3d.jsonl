{"_at":[1768450850071,1],"_by":"darin@book","_v":{"acceptance_criteria":[[1768444163141,1],"darin@book"],"claim":[[1768450019804,1],"darin@book"],"description":[[1768444163141,1],"darin@book"],"design":[[1768444163141,1],"darin@book"],"estimated_minutes":[[1768444163141,1],"darin@book"],"external_ref":[[1768444163141,1],"darin@book"],"labels":[[1768444163141,1],"darin@book"],"priority":[[1768444163141,1],"darin@book"],"source_repo":[[1768444163141,1],"darin@book"],"title":[[1768444163141,1],"darin@book"],"type":[[1768444163141,1],"darin@book"]},"assignee":"darin@book","assignee_at":[1768450019804,1],"assignee_expires":1768453619804,"closed_at":[1768450850071,1],"closed_by":"darin@book","created_at":[1768444163141,1],"created_by":"darin@book","description":"**Problem**\nREALTIME_PLAN §5.2.3/§5.2.3 require marking rotated segments as sealed with final_len recorded in wal.sqlite. Current runtime writes segments with sealed=false and never updates them when rotation happens (AppendOutcome.rotated is unused). Sealing only occurs during replay rebuild, so live index misses sealed/final_len invariants.\n\nEvidence:\n- src/daemon/executor.rs:264–282 upsert_segment always uses sealed=false, final_len=None.\n- src/daemon/core.rs:1041–1066 does the same for replication ingest.\n- SegmentWriter::append returns AppendOutcome.rotated, but no caller updates sealed/final_len.\n\n**Why this violates plan**\nPlan mandates sealed segments be recorded at rotation time and validated on startup (file_len == final_len). Without this, on-disk corruption and partial writes can go undetected.\n\n**Acceptance**\n- [ ] On segment rotation, mark previous segment sealed=1 and final_len in wal.sqlite.\n- [ ] Ensure index updates are atomic with segment rotation.\n- [ ] Admin/status and replay enforce sealed invariants for live-written segments, not just rebuild.","id":"bd-3m5.83","labels":[],"priority":1,"status":"closed","title":"WAL segment sealing not recorded on rotation","type":"bug"}
{"_at":[1766124452636,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1766116455465,0],"darin@dusk"],"claim":[[1766124452535,0],"darin@dusk"],"description":[[1766116455465,0],"darin@dusk"],"design":[[1766116455465,0],"darin@dusk"],"estimated_minutes":[[1766116455465,0],"darin@dusk"],"external_ref":[[1766116455465,0],"darin@dusk"],"labels":[[1766116455465,0],"darin@dusk"],"priority":[[1766116455465,0],"darin@dusk"],"source_repo":[[1766116455465,0],"darin@dusk"],"title":[[1766116455465,0],"darin@dusk"],"type":[[1766116455465,0],"darin@dusk"]},"assignee":"darin@dusk","assignee_at":[1766124452535,0],"assignee_expires":1766128052535,"closed_at":[1766124452636,0],"closed_by":"darin@dusk","created_at":[1766116455465,0],"created_by":"darin@dusk","description":"**Problem**\n`init_beads_ref` fetches and force-updates `refs/heads/beads/store` to remote even if a local ref already exists. If local has data, this can overwrite it.\n\n**Design**\nIf local ref exists, treat init as a no-op (already initialized). Only fast-forward local when it does not exist. Never force-update without preserving local history. Add a test that ensures init does not modify an existing local ref.\n\n**Acceptance**\n- [ ] init is a no-op when local ref exists\n- [ ] No forced updates on existing local refs\n- [ ] Tests cover init with existing local ref\n- [ ] Tests pass\n\n**Files:** src/git/sync.rs","id":"bd-vb0","labels":[],"priority":0,"status":"closed","title":"init_beads_ref must not overwrite existing local ref","type":"bug"}
