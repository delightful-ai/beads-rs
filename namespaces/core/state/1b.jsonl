{"_at":[1769551924541,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `read_range` rejects gaps after the first item (returns MissingRange/GapInRange).\n- [ ] `read_range` validates `prev_sha256` consistency between WAL index and record headers.\n- [ ] A new type (or explicit validation) guarantees contiguous ordering before sending.\n- [ ] Tests cover: contiguous success, internal gap failure, prev_sha mismatch failure.\n- [ ] `cargo test` passes.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769502945242,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`WalRangeReader::read_range` assumes the WAL index returns contiguous sequences starting at `from_seq_excl.next()`, but it only verifies the first item. If `iter_from` yields a gap (or if index `prev_sha` diverges from the record header), we still build and send frames. This violates the implicit contract of WANT responses and can cause:\n- repeated WANT loops (gap never filled),\n- divergence / PrevMismatch at the receiver,\n- hiding index corruption until much later.\n\nThe type system does not encode “contiguous ordered frames,” so illegal batches are representable.\n\n**Files**\n- `crates/beads-rs/src/daemon/repl/runtime.rs` (WalRangeReader::read_range)\n- `crates/beads-rs/src/daemon/wal/index.rs` (iter_from ordering)","design":"**Design**\nEncode contiguity + ordering as a type and validate at construction:\n\n- Introduce `ContiguousFrames` (or `ContiguousEventBatch`) newtype:\n  - Holds `Vec<EventFrameV1>` that is strictly increasing by `origin_seq` with no gaps.\n  - Optional: store `from_seq_excl` for debug/validation.\n\n- In `WalRangeReader::read_range`:\n  - Track `expected_seq = from_seq_excl.next()`.\n  - For each `IndexedRangeItem`:\n    - If `item.event_id.origin_seq != expected_seq`, return `WalRangeError::MissingRange` (or new `GapInRange` error).\n    - Read record and verify:\n      - `record.header().origin_replica_id/seq` already checked.\n      - `record.header().prev_sha256` matches `item.prev_sha` (if present).\n      - `record.header().prev_sha256` matches the previous frame’s sha (for seq>1).\n    - Push frame, increment expected_seq.\n  - Return `ContiguousFrames` (convert to Vec for encode), preserving canonical ordering.\n\n**Ordering / invariants preserved**\n- Always emit frames in ascending `origin_seq` order.\n- Ensure `prev_sha256` chain is consistent (no hidden gaps).","id":"bd-47c6","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"WalRangeReader must return contiguous, validated frame batches","type":"bug"}
{"_at":[1769757839727,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] There is a shared `validated` module in `beads-core` for ID/namespace/dep-kind validation.\n- [ ] CLI/daemon/event/repl entrypoints use the validated constructors instead of local parsing helpers.\n- [ ] Duplicate parse/normalize helpers are removed or reduced to thin adapters.\n- [ ] Tests cover invalid inputs rejected consistently across at least two boundaries (CLI + repl).","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769573965941,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nBoundary parsing/normalization is duplicated across layers:\n- CLI normalization in `crates/beads-rs/src/cli/mod.rs`\n- Daemon mutation parsing in `crates/beads-rs/src/daemon/mutation_engine.rs`\n- Event CBOR decode in `crates/beads-core/src/event.rs`\n- Repl proto decode in `crates/beads-rs/src/daemon/repl/proto.rs`\n\nExample: `parse_namespace` exists in both event CBOR decode and repl proto decode; bead IDs and dep kinds are re-parsed in multiple entrypoints. This is scatter + drift risk: invariants are enforced differently depending on boundary.\n\n**Files:**\n- `crates/beads-rs/src/cli/mod.rs`\n- `crates/beads-rs/src/daemon/mutation_engine.rs`\n- `crates/beads-core/src/event.rs`\n- `crates/beads-rs/src/daemon/repl/proto.rs`\n- `crates/beads-rs/src/daemon/coord.rs`","design":"**Design**\nIntroduce shared validated boundary types for IDs/namespaces/dep kinds and require all ingress paths to construct them once.\n\nConcrete plan:\n1) Add a `validated` module in `beads-core` with types like `ValidatedBeadId`, `ValidatedNamespaceId`, `ValidatedDepKind`, `ValidatedActorId`, etc.\n2) Provide constructors that return structured errors and perform canonicalization (trim, case, allowed charset).\n3) Update CLI normalization helpers to return validated types instead of raw strings/IDs.\n4) Update daemon mutation parsing to accept validated inputs (e.g., `ValidatedBeadId`) and remove duplicate parsing/normalization logic.\n5) Update event CBOR and repl proto decoders to share the same validated constructors (no local parse_* helpers).\n\n**Design Notes**\n- Keep serialization compatibility by implementing `Display`/`Serialize` on validated types.\n- Make validated types lightweight wrappers around the core types so they’re cheap to pass around.","id":"bd-7m9a","labels":{"cc":{"max":{}},"entries":{"scatter":[{"counter":18048143335217658867,"replica":"844315d5-314a-f32d-1b09-67d33894cce8"}],"types":[{"counter":14188388958699452498,"replica":"cf986fd1-9b61-71e3-9420-ce8d39bbb84d"}],"validation":[{"counter":1845922927161849912,"replica":"e3b3d51e-d715-9dae-67e9-86304d51e705"}]}},"priority":2,"status":"closed","title":"Unify boundary parsing via validated core types","type":"chore"}
{"_at":[1768721474879,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768710056437,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nModel runs use a fixed 60s timeout; baselines are harder to compare and re-run at known limits.\n\n**Design**\n- Add a --timeout-secs <u64> flag to repl_core_machine.\n- Print timeout in the config line.\n- Thread the value into checker().timeout(Duration::from_secs(...)).\n\n**Acceptance**\n- [ ] Timeout defaults to current 60s.\n- [ ] Passing --timeout-secs overrides both check + explore.\n- [ ] Example run documented in output or README comment.\n\n**Files**\n- beads_stateright_models/examples/repl_core_machine.rs","id":"bd-pdje","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Stateright repl: add --timeout-secs for repeatable baselines","type":"chore"}
{"_at":[1768622489084,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622489084,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nbeads-rs lacks the Role issue type - role definition beads that specify agent behavior, responsibilities, and capabilities. Roles are referenced by agent beads via the role_bead field, enabling separation of agent identity (who) from agent behavior (what/how).\n\n**What Role Beads Do (from Go beads)**\nRole beads define:\n- Agent responsibilities and scope\n- Behavioral patterns and workflows\n- Coordination protocols with other roles\n- Skills and capabilities\n\nEach agent bead references a role bead (via role_bead field). This enables:\n- Multiple agents with same role (e.g., multiple polecats)\n- Role updates without touching agent beads\n- Role composition and inheritance\n- Clear separation of identity vs behavior\n\nKnown roles (from internal/types/types.go and agent.go):\n- polecat: Individual contributor, claims and completes work\n- crew: Team-based work, multiple crew members collaborate\n- witness: Monitoring and health checks, timeout detection\n- refinery: Code review and quality gates, merge approval\n- mayor: Town-level orchestration and policy\n- deacon: Operational support, cleanup, maintenance\n\n**Go Implementation**\nType definition (internal/types/types.go):\n- IssueType = TypeRole (line 491)\n- Uses standard Issue fields (no custom fields)\n- Description/Design fields hold role specification\n- Title: Role name (e.g., \"Polecat Role\", \"Witness Role\")\n\nAgent linkage:\n- Agent.RoleBead string field points to role bead ID\n- Agent.RoleType string field holds role name for filtering\n- Labels: role_type:<name> for queries\n\nCLI usage:\n- bd create --type role \"Polecat Role\" - Create role definition\n- bd slot set <agent> role <role-id> - Link agent to role\n- bd list --type role - List all role definitions\n\nRole bead content structure (convention):\n```markdown\n# Polecat Role\n\n## Responsibilities\n- Claim ready work from bd ready\n- Execute tasks independently\n- Report progress via state updates\n- Signal completion or stuck state\n\n## Workflows\n1. Spawn: gt-<rig>-polecat-<name> bead created\n2. Idle: Wait for work\n3. Claim: bd claim <bead-id>\n4. Work: Execute and update state\n5. Complete: bd close <bead-id>\n6. Repeat or Done\n\n## Coordination\n- Reports to: Witness (heartbeat)\n- Escalates to: Mayor (when stuck)\n- Interacts with: Refinery (for merge approval)\n```\n\n**Design for Rust**\nData model (src/core/):\nNo special fields needed - roles are regular beads with:\n- Type = Role\n- Rich markdown in Description/Design\n- Referenced by agent beads via role_bead field\n\nCLI (src/cli/):\n- bd create --type role \"Role name\"\n- bd show <role-id> (render markdown description)\n- bd list --type role\n- bd slot set <agent> role <role-id>\n\nRole discovery:\n- bd list --type role shows available roles\n- Agents parse role_bead to understand behavior\n\n**Design Notes**\n- Roles are configuration/specification, not runtime state\n- Role beads should be pinned (persistent, not work items)\n- Consider: Role versioning for behavior evolution\n- Consider: Role inheritance/composition (roles referencing other roles)\n- Consider: Machine-readable role spec (YAML/JSON in description?)\n- Town-level roles (mayor, deacon) vs rig-level (witness, polecat, crew, refinery)\n\n**Acceptance**\n- [ ] Role type constant defined\n- [ ] bd create --type role works\n- [ ] bd list --type role shows role beads\n- [ ] bd show <role-id> displays role description\n- [ ] bd slot set links agent to role\n- [ ] Agent.role_bead field populated\n- [ ] Role beads can be pinned (persistent context)\n- [ ] Tests for role creation and linking\n- [ ] Migration from Go beads preserves role type\n\n**Files to study in Go beads:**\n- tmp/beads/internal/types/types.go (line 491: TypeRole)\n- tmp/beads/cmd/bd/agent.go (parseAgentIDFields: role classification)\n- tmp/beads/cmd/bd/slot.go (role slot management)","id":"bd-ze0x.35","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":18246825264147717891,"replica":"6e2239f0-8c35-bba1-235f-0b56baa46874"}]}},"priority":2,"status":"open","title":"Add Role issue type support","type":"feature"}
