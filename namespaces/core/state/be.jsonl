{"_at":[1768704520098,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768704221218,0],"created_by":"darin@darinsmcstudio2.lan","description":"Full cargo test run failed in tests/critical_path.rs for test_dependencies and test_reopen_closed (unexpected stdout), but both pass when run individually. Investigate shared state or ordering issues in critical_path harness.","id":"bd-w9og","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Flaky critical_path tests test_dependencies/test_reopen_closed","type":"bug"}
{"_at":[1769521639117,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] There is no public API that can create a seq/head snapshot with invalid combinations.\n- [ ] `Hello`/`Welcome`/`Ack` decoding fails fast on invalid seq/head pairs.\n- [ ] Session/gap buffer code consumes typed `Watermark<K>` directly (no runtime `watermark_state_from_snapshot`).\n- [ ] No `unreachable!` remains in repl paths for `HeadStatus::Unknown`.\n- [ ] Tests cover invalid snapshots (missing head for seq>0, head present for seq=0) and round‑trip encoding.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769495915565,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nReplication watermarks are encoded as *two separate maps*: `WatermarkMap` (seqs) and `WatermarkHeads` (heads). This lets illegal states exist after parsing:\n- seq > 0 with missing head\n- seq = 0 with head present\n- heads map missing namespace/origin entries that exist in seq map\n\nWe then reconstruct `Watermark<K>` at runtime via `watermark_state_from_snapshot` and assume this “can’t be wrong” in downstream logic (`unreachable!` on unknown head). The compiler cannot enforce the invariant, and a malformed peer snapshot or refactor can surface as internal errors or panics.\n\nKey refs:\n- `crates/beads-rs/src/daemon/repl/proto.rs:22` — separate map types.\n- `crates/beads-rs/src/daemon/repl/session.rs:946` — runtime validation.\n- `crates/beads-rs/src/daemon/repl/gap_buffer.rs:293` — `unreachable!` on unknown head.\n\n**Impact**\nRepl correctness + robustness risk at protocol boundary. Invalid snapshots can crash or poison state.","design":"**Design (opinionated)**\nRepresent watermark invariants *in the type* at the protocol boundary.\n\n1) Replace split maps with a per‑origin entry type:\n- `struct WireWatermark { seq: Seq0, head: Option<Sha256> }`\n- `TryFrom<WireWatermark> for Watermark<K>` enforces:\n  - `seq == 0` => `head == None`\n  - `seq > 0` => `head == Some`\n\n2) Use a single snapshot map:\n- `type WatermarkSnapshotWire = BTreeMap<NamespaceId, BTreeMap<ReplicaId, WireWatermark>>`\n- Update `Hello`/`Welcome`/`Ack` to use `WatermarkSnapshotWire` (for durable/applied).\n\n3) Wire compatibility:\n- If backward compatibility is required, keep the same on‑wire shape but *decode into* `WireWatermark` and validate immediately. Encoding should never produce invalid pairs.\n\n4) Remove `watermark_state_from_snapshot` from callers.\n- Session/gap buffer should operate on `Watermark<K>` directly.\n- Eliminate `HeadStatus::Unknown` from the repl/session path or keep it strictly internal.\n\nThis makes snapshot invariants unrepresentable and catches mistakes at compile time.","id":"bd-zp59","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Encode watermark snapshot invariants in repl protocol types","type":"bug"}
