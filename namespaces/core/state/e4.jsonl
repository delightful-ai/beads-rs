{"_at":[1768254941652,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1768252042894,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWAL replay truncates on any corruption, including mid-file CRC/record decode errors, because scan_segment doesn't distinguish tail vs mid-file. This violates REALTIME_PLAN.md 5.2 (online vs offline boundary), which requires fail-fast on mid-file corruption and only tail truncation repairs.\n\n**Design**\nIn src/daemon/wal/replay.rs scan_segment, detect tail vs mid-file:\n- tail: remaining < FRAME_HEADER_LEN, frame_len > remaining, or crc mismatch where offset+frame_len == file_len.\n- mid-file: return explicit WalReplayError (new variant) with path+offset; do not truncate.\nOnly truncate in tail cases when repair_tail=true. Surface operator action to run bd store fsck.\nAdd tests for mid-file corruption (expect error) and tail corruption (truncate) using WAL fixtures.\n\n**Acceptance**\n- [ ] Mid-file corruption during replay returns error and does not truncate.\n- [ ] Tail corruption still truncates and continues.\n- [ ] Tests cover mid-file vs tail behavior; cargo test passes.\n\n**Files:** src/daemon/wal/replay.rs, tests/phase3_wal.rs","id":"bd-a0s","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"WAL replay mid-file corruption should fail fast","type":"bug"}
{"_at":[1769501517889,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] There is no public API that can construct an `OrSet` from raw parts without validation.\n- [ ] All decode/import paths use validated construction (wire, checkpoint import, WAL legacy snapshot).\n- [ ] Invalid OR‑Set input fails fast at the boundary (or is explicitly normalized only in migration paths).\n- [ ] Tests cover: dominated dot pruning, dot collision resolution, empty‑entry removal, and rejection of duplicate‑dot collisions.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769495892464,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`OrSet::from_parts` constructs an OR‑Set from arbitrary `entries` + `cc` with no validation or normalization. That means invalid CRDT states can enter core from untrusted decode/import paths and still pass the type checker.\n\nInvalid but representable states today:\n- Dots dominated by `cc` still present in `entries` (should be pruned).\n- The same dot appears under multiple values (collision unresolved).\n- Empty dot sets remain as live values.\n- `cc` not normalized, leaving redundant dots / inconsistent dominance.\n\nWe currently call `OrSet::from_parts` from wire + checkpoint + legacy snapshot decode paths, so malformed data can deterministically corrupt CRDT state.\n\nKey refs:\n- `crates/beads-core/src/orset.rs:208` — unchecked constructor.\n- `crates/beads-rs/src/git/wire.rs:669` — wire decode uses it.\n- `crates/beads-rs/src/git/checkpoint/import.rs:834` / `:854` — checkpoint import uses it.\n- `crates/beads-rs/src/daemon/wal_legacy_snapshot.rs:103` / `:337` — legacy snapshot uses it.\n\n**Impact**\nCore CRDT corruption from untrusted inputs. This is P0: it breaks determinism and can persist invalid state through joins/merges.","design":"**Design (opinionated)**\nMake OR‑Set construction validated/typed and remove unchecked construction from public API.\n\n1) Introduce a validated constructor:\n- `pub fn try_from_parts(entries, cc) -> Result<OrSet<Normalized>, OrSetError>`.\n- Validation steps (must be deterministic):\n  - `cc.normalize()`\n  - prune dominated dots\n  - resolve dot collisions deterministically\n  - drop empty entries\n  - optionally error if duplicate dots are found under multiple values *before* normalization (prefer strictness for network inputs)\n\n2) Typestate or wrapper:\n- `OrSet<Normalized>` vs `OrSet<Raw>` (or `OrSetParts` -> `OrSet`), so only normalized sets can enter `LabelState::from_parts` / `DepStore::from_parts`.\n- Make the unchecked `from_parts` `pub(crate)` or delete it.\n\n3) Boundary‑specific behavior:\n- For network/wire decode: reject invalid OR‑Sets with a clear error (fail fast).\n- For legacy/import paths: provide an explicit `normalize_for_import` that returns a normalized set but logs/warns (so corruption doesn’t leak silently).\n\n4) Update all decode/import call sites to use the validated constructor.\n\nThis turns “oops, forgot to normalize” into a compile error.","id":"bd-xyce","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"OrSet from_parts allows invalid CRDT state","type":"bug"}
{"_at":[1768622238197,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622238197,0],"created_by":"darin@darinsmcstudio2.lan","description":"## Overview\nEpic for tracking features from Go beads (v0.22-v0.47+) that should be ported to beads-rs.\n\n## Purpose\nThis is a **human review queue** - beads under this epic require design review before implementation. Most are tagged `human-needed` because they involve architectural decisions about how to adapt Go patterns to Rust idioms.\n\n## Categories\n- Core types & data model extensions\n- Molecules, formulas, and workflow templates  \n- Dependencies and graph link types\n- Status states and workflow\n- CLI/UX improvements\n- Sync, storage, and maintenance\n- Design-heavy features (mail, routing)\n\n## Process\n1. Review each bead's description and design options\n2. Make architectural decisions\n3. Remove `human-needed` label when design is settled\n4. Implementation can proceed\n\n## Exclusions\n- Features that are already implemented in beads-rs\n- Features that don't make sense for the Rust rewrite\n\n---\n*Created from: changelog analysis of Go beads v0.22-v0.47*","id":"bd-ze0x","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"open","title":"Port Go beads features to beads-rs","type":"epic"}
