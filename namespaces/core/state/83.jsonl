{"_at":[1766124419956,0],"_by":"darin@dusk","_v":{"acceptance_criteria":[[1766116455765,0],"darin@dusk"],"claim":[[1766124419880,0],"darin@dusk"],"description":[[1766116455765,0],"darin@dusk"],"design":[[1766116455765,0],"darin@dusk"],"estimated_minutes":[[1766116455765,0],"darin@dusk"],"external_ref":[[1766116455765,0],"darin@dusk"],"labels":[[1766116455765,0],"darin@dusk"],"priority":[[1766116455765,0],"darin@dusk"],"source_repo":[[1766116455765,0],"darin@dusk"],"title":[[1766116455765,0],"darin@dusk"],"type":[[1766116455765,0],"darin@dusk"]},"assignee":"darin@dusk","assignee_at":[1766124419880,0],"assignee_expires":1766128019880,"closed_at":[1766124419956,0],"closed_by":"darin@dusk","created_at":[1766116455765,0],"created_by":"darin@dusk","description":"**Problem**\n`remote.fetch(&[\"refs/heads/beads/store\"], ...)` relies on libgit2 refspec defaults; it may only update FETCH_HEAD and leave `refs/remotes/origin/beads/store` stale. Fetch errors are also ignored, so the daemon can sync against stale remote state without any signal.\n\n**Design**\nUse an explicit refspec (`refs/heads/beads/store:refs/remotes/origin/beads/store`) and return/propagate fetch errors (or at least surface them in status/IPC). Keep a best-effort path for offline reads but make failures visible.\n\n**Acceptance**\n- [ ] Fetch updates `refs/remotes/origin/beads/store`\n- [ ] Fetch errors are surfaced (status/IPC/logs)\n- [ ] Tests cover refspec + fetch failure behavior\n\n**Files:** src/git/sync.rs, src/daemon/git_worker.rs","id":"bd-v9i","labels":[],"priority":1,"status":"closed","title":"Git fetch should use explicit refspec + surface errors","type":"bug"}
