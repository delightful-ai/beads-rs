{"_at":[1768497048898,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Issue detail output includes namespace line\n- [ ] Issue lists include namespace indicator\n- [ ] Formatting is deterministic and covered by tests","assignee":"darin@book","created_at":[1768495449924,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nHuman CLI output (show/list/ready/blocked/stale) does not display namespace, which is critical when multiple namespaces are in play.\n\n**Design**\nExtend render helpers in src/cli/render.rs to show `namespace` for issue detail and list rows. Keep formatting concise and deterministic.\n\n**Files**\n- src/cli/render.rs","id":"bd-1qt","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Show namespace in CLI issue outputs","type":"feature"}
{"_at":[1770502825860,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] CLI/integration tests no longer import daemon internals directly\n- [ ] Daemon-internal tests live under daemon-owned boundaries\n- [ ] Critical integration suites still pass","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1770498508099,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIntegration suites still import `beads_rs::daemon::*`, which will break crate extraction.","design":"Move tests/fixtures to surface/daemon-core boundaries and keep daemon-internal coverage in daemon-owned test modules.","id":"bd-21eg.29","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Migrate integration tests/fixtures off daemon-internal imports","type":"task"}
{"_at":[1768271110142,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Encode/decode roundtrip tests for each replication message type.\n- [ ] VerifiedEvent typestate prevents forwarding events with deferred prev checks.\n- [ ] Oversized frames and batches are rejected deterministically with correct error codes.\n- [ ] Error frames serialize to the same schema as IPC ErrorPayload.","assignee":"darin@darinsmacstudio.lan","created_at":[1768177879615,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nReplication needs a typed, verifiable on wire protocol. Today there are no CBOR frame types or verification state; without a typestate pipeline, callers can accidentally skip hash or prev link checks and still treat events as valid.\n\n**Context**\n- REALTIME_PLAN.md ยง9.1-9.6 (frame definitions and rules), ยง0.6 (hashing over EventBody bytes)\n- REALTIME_ERRORS.md (error payload shape)\n- Stateright model: beads_stateright_models/src/realtime_types_sketch.rs (EventBytes, EventFrameV1, VerifiedEventAny)\n\n**Files:** src/daemon/repl/frame.rs (new), src/daemon/repl/proto.rs (new), src/daemon/repl/mod.rs (new), src/core/event.rs","design":"**Design**\n- Define CBOR envelope `{ v, type, body }` and per-message bodies (HELLO, WELCOME, EVENTS, ACK, WANT, ERROR) with spec field names.\n- Introduce EventFrameV1 that carries EventId, sha256, prev_sha256, and EventBytes<Opaque>.\n- Add verification pipeline types: VerifiedEvent<PrevVerified> vs VerifiedEvent<PrevDeferred> (or equivalent) so callers cannot treat a deferred prev check as fully verified.\n- Enforce MAX_FRAME_BYTES, MAX_EVENT_BATCH_BYTES, and decoding limits before allocating large buffers; reject oversize frames with ERROR(code=\"frame_too_large\").\n- Keep ErrorPayload consistent with IPC; ERROR frames use the same schema and codes.","id":"bd-3m5.15","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Phase 5: Replication protocol types + framing","type":"task"}
{"_at":[1768824584088,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- repo_has_branch returns BranchPresence enum\\n- call sites updated\\n- cargo check, cargo clippy -D warnings, cargo test pass","assignee":"darin@book","created_at":[1768824438235,0],"created_by":"darin@darinsmcstudio2.lan","description":"tests/integration/fixtures/git.rs returns bool for branch presence. Replace with a BranchPresence enum to avoid bool ambiguity and update call sites.","id":"bd-kh1y","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Replace repo_has_branch bool with enum","type":"chore"}
{"_at":[1768535163198,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] No duplicate hard-coded record header length remains.\n- [ ] `estimated_record_bytes` uses the shared record header size.","assignee":"darin@book","created_at":[1768506367556,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`mutation_engine.rs` defines `RECORD_HEADER_BASE_LEN = 88`, duplicating the canonical constant in `wal/record.rs`. If the WAL header layout changes, `estimated_record_bytes` will silently become wrong, causing brittle sizing logic.\n\n**Files**\n- src/daemon/mutation_engine.rs\n- src/daemon/wal/record.rs\n","design":"**Design**\n- Expose a shared constant or accessor from `wal/record.rs` (e.g., `RecordHeader::base_len()` or `RECORD_HEADER_BASE_LEN` as `pub(crate)`).\n- Replace the magic number in `mutation_engine.rs` with the shared value.","id":"bd-yiof","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Deduplicate WAL record header base length constant","type":"chore"}
{"_at":[1765773848939,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@dusk","created_at":[1765744929887,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIn `src/git/collision.rs`, collision resolution remaps the loser and writes a tombstone for the old ID using a \"resolution stamp\". But the merge rule in `core/state.rs` is: tombstone wins unless the beads `updated_stamp()` is strictly newer.\n\nIf the tombstone stamp is newer than the winner beads updated stamp (likely, since resolution stamp is generated \"now\"), **the winner gets deleted during join**. This violates spec ยง4.1.1 (\"winner retains original id\") and is catastrophic.\n\n**Design Options**\n\n*Option A (cleanest):* Lineage-scoped tombstones\nTombstone includes the losing beads `created` stamp (or content-hash) so it only kills that lineage, not the winner occupying the ID.\n\n*Option B (minimal change):* Emit two stamps on collision resolution\n- `t_del` for the loser-id tombstone  \n- `t_win` for a no-op \"bump\" on the winner bead so `t_win > t_del`\nThis makes the winner survive the delete rule while preventing loser resurrection.\n\n**Acceptance**\n- [ ] Deterministic test: collision where winner is older, loser is newer, resolution happens later\n- [ ] Winner survives resolution in all timestamp orderings\n- [ ] Loser cannot resurrect after resolution\n- [ ] Spec compliance verified\n\n**Files:** src/git/collision.rs, src/core/state.rs","id":"bd-zvn","labels":{"cc":{"max":{}},"entries":{}},"priority":0,"status":"closed","title":"Fix collision resolution: winner can be deleted by resolution tombstone","type":"bug"}
