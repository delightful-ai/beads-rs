{"_at":[1768510077718,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Replication protocol code uses `Seq0`-typed watermark values internally.\n- [ ] Encode/decode preserves the existing on-wire format.\n- [ ] All conversions from raw `u64` removed from session/peer_acks paths.","assignee":"darin@book","created_at":[1768503254251,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nReplication protocol types (`WatermarkMap`, `Want`, `Ack`) use raw `u64` sequence numbers in `src/daemon/repl/proto.rs`. Multiple layers then convert these to `Seq0`/`Watermark`, which is easy to misuse and obscures invariants.\n\n**Files**\n- src/daemon/repl/proto.rs\n- src/daemon/repl/session.rs\n- src/daemon/repl/peer_acks.rs\n- src/daemon/repl/runtime.rs\n- src/daemon/repl/want.rs","design":"Introduce a typed wire map (e.g., `WireSeq0` or `WireWatermarkMap`) that stores `Seq0` in memory and encodes/decodes as `u64` on the wire. Replace `WatermarkMap` aliases with the typed version across replication logic, and update CBOR encoding/decoding accordingly. This keeps all internal code on `Seq0`/`Watermark` while preserving the protocol format.","id":"bd-4f5","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Replication watermarks should use Seq0 typed values","type":"chore"}
{"_at":[1768800003256,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","created_at":[1768777663149,0],"created_by":"darin@darinsmcstudio2.lan","description":"tests/integration/fixtures/repl_rig.rs assert_converged + assert_peers_seen poll admin_status in a loop. Add a wait-style IPC (or extend admin/status with wait semantics) so tests can block on watermarks/peer visibility without sleep polling. Update repl_e2e to use the wait helper.","id":"bd-j5q1","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"ReplRig convergence/peers checks poll admin_status; add wait-based IPC helper","type":"chore"}
{"_at":[1768622517435,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622517435,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIssues in one repository often depend on work in another repository. Current dependency system only supports local references. Need to represent cross-repo dependencies using `external:<repo>:<id>` syntax.\n\n**What the Feature Does**\nDependencies can reference issues in other repositories:\n\n```bash\n# Issue in beads-rs blocks on beads-go capability\nbd dep add bd-123 external:beads-go:mol-run-assignee --type blocks\n\n# Shipping a capability (in beads-go)\nbd label add bd-456 export:mol-run-assignee\nbd ship mol-run-assignee\n# → Adds provides:mol-run-assignee label\n\n# Check if external dependency is satisfied\nbd show bd-123\n# Shows: Blocked by external:beads-go:mol-run-assignee (resolved: yes)\n\n# Move issue to another repo\nbd ship bd-123 --to ~/other-repo\n# → Moves issue, preserves dependencies\n```\n\nExternal refs resolve via:\n1. Prefix-based routing (routes.jsonl)\n2. Explicit repo configuration (config.yaml)\n3. Capability labels (provides:xxx)\n\n**Why It Needs Design Work**\n\n1. **Resolution Strategy**:\n   - How to look up external issues?\n   - Option A: Always route via routes.jsonl (prefix-based)\n   - Option B: Explicit repo registry (config: `repos.beads-go = ~/path`)\n   - Option C: Both (try routes, fall back to registry)\n   - What if target repo not found?\n\n2. **Dependency Validation**:\n   - Can we validate external deps exist?\n   - Or treat as opaque references?\n   - Lazy resolution (only when needed)?\n   - Cache resolution results?\n\n3. **Sync Behavior**:\n   - External deps stored as strings in JSONL\n   - How to represent in SQLite? (separate table? JSON column?)\n   - Need foreign key constraints? (probably not - external!)\n   - How to detect broken external refs?\n\n4. **Ready Queue Calculation**:\n   - Issue blocked by external:foo:bar\n   - Is it ready? Need to check external repo\n   - Performance implications (opening multiple dbs)\n   - Caching strategy?\n\n**Key Decisions to Make**\n\n1. **Storage Schema**:\n   ```rust\n   // Option A: Extend Dependency type\n   enum DependencyTarget {\n       Local(IssueId),\n       External { repo: String, id: String },\n   }\n   \n   // Option B: Separate external_deps table\n   struct ExternalDep {\n       issue_id: String,\n       dep_type: DepType,\n       target_repo: String,\n       target_id: String,\n       resolved: Option<bool>, // cache\n   }\n   ```\n\n2. **Repo Registry**:\n   ```toml\n   # .beads/config.toml\n   [repos]\n   beads-go = \"~/projects/beads-go\"\n   beads-rs = \".\"\n   olympus = \"../olympus\"\n   ```\n   \n   Or use routes.jsonl for everything?\n\n3. **Capability System**:\n   - Labels: `export:xxx` (planned capability), `provides:xxx` (shipped)\n   - Command: `bd ship <capability>` adds provides label\n   - Resolution: Look for closed issue with `provides:xxx` in target repo\n   - Alternative: Dedicated capabilities table?\n\n4. **Migration Command**:\n   ```bash\n   bd ship bd-123 --to <repo>\n   # What does this do?\n   # 1. Export issue as JSONL\n   # 2. Import to target repo\n   # 3. Update dependencies?\n   # 4. Leave tombstone in source?\n   ```\n\n**Trade-offs to Consider**\n\n1. **Validation vs Flexibility**:\n   - Strict: Validate external refs exist (slow, fragile)\n   - Loose: Treat as opaque strings (fast, might break)\n   - Middle: Lazy validation, cache results\n\n2. **Performance vs Accuracy**:\n   - Accurate ready queue = check all external deps (slow)\n   - Fast ready queue = assume external deps met (might be wrong)\n   - Solution: Async background resolution?\n\n3. **Coupling**:\n   - Tight: Routes.jsonl + capability labels + repo config\n   - Loose: Just store strings, resolve at display time\n   - Tight enables better UX but more complex\n\n4. **Naming**:\n   - `external:<repo>:<id>` (current Go syntax)\n   - `<repo>::<id>` (Rust-style)\n   - `@<repo>/<id>` (GitHub-style)\n   - Stick with Go for compatibility?\n\n**Reference Files in Go Beads**\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/cmd/bd/ship.go` - Ship command\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/routing/routes.go` - ResolveToExternalRef\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/storage/sqlite/external_deps.go` - Storage\n- Search for \"external:\" in codebase for usage examples\n\n**Go Implementation Details**\n- External deps stored as `external:<project>:<id>` strings\n- `ResolveToExternalRef(id, beadsDir)` - Converts local ID to external ref\n- Capability labels: `export:xxx` (planning), `provides:xxx` (shipped)\n- Resolution: Check if target has closed issue with `provides:` label\n- No automatic validation (treat as opaque until needed)\n\n**Use Cases to Support**\n\n1. **Cross-Project Blocking**:\n   - beads-rs feature blocked on beads-go API\n   - Show dependency in `bd show`, `bd ready`\n\n2. **Capability Shipping**:\n   - Team A provides feature for Team B\n   - Team B depends on `external:teamA:feature-x`\n   - Team A ships when ready\n\n3. **Issue Migration**:\n   - Move issue between repos (fork → upstream)\n   - Preserve dependency graph\n\n4. **Multi-Repo Planning**:\n   - Epic spans multiple repos\n   - Child issues in different repos\n   - Still show unified dependency tree\n\n**Open Design Questions**\n\n1. Should external deps be bidirectional?\n   - If A depends on external:B:foo, does B know?\n   - Need reverse index?\n\n2. How to handle repo renames?\n   - External refs by name can break\n   - Use repo URL instead?\n   - Migration tool?\n\n3. Offline behavior?\n   - External repo not available\n   - Show as unresolved? Error?\n   - Grace degradation?\n\n4. Security/trust?\n   - Can malicious external refs DoS by forcing db opens?\n   - Rate limiting? Allowlist?\n\n**Acceptance**\n- [ ] Design document for external reference system\n- [ ] Storage schema (how to represent in SQLite + JSONL)\n- [ ] Resolution algorithm (routes vs config vs both)\n- [ ] Capability label system design\n- [ ] Ship command spec\n- [ ] Ready queue calculation with external deps\n- [ ] Performance considerations (caching, lazy loading)\n- [ ] Error handling (missing repos, missing issues)\n- [ ] Migration/promotion workflow\n- [ ] Repo registry format and management","id":"bd-ze0x.41","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":15662987394879421415,"replica":"24b5f755-5d7c-853c-3999-8d03ee61cd6d"}]}},"priority":2,"status":"open","title":"Multi-repo dependencies - External reference system","type":"feature"}
