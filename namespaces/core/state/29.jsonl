{"_at":[1768338835347,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1768271719727,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nIPC JSON decode errors currently map to legacy parse_error, and semantic request validation failures get mislabeled as parse_error because decode_request_with_limits deserializes directly into Request. REALTIME_PLAN.md/REALTIME_ERRORS.md require malformed_payload for invalid JSON and invalid_request for valid JSON with semantic issues.\n\n**Where**\n- src/daemon/ipc.rs: decode_request_with_limits, From<IpcError> for ErrorPayload\n\n**Design**\n- Separate JSON parsing from Request validation (e.g., parse to serde_json::Value first), then validate/deserialize with explicit error mapping.\n- Map malformed JSON to code malformed_payload with details {parser:\"json\"...}, and semantic validation to invalid_request.\n- Ensure payload shape uses realtime fields {code,message,retryable,retry_after_ms?,details?,receipt?}.\n\n**Acceptance**\n- Invalid JSON yields malformed_payload (not parse_error).\n- Semantically invalid JSON yields invalid_request.\n- IPC error payloads remain realtime-shaped and include details where applicable.\n\n**Files**\n- src/daemon/ipc.rs","id":"bd-3m5.67","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"IPC: split malformed_payload vs invalid_request for JSON decode","type":"bug"}
{"_at":[1768494044027,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Test fails if any REALTIME_ERRORS.md code is not recognized by ErrorCode::parse\n- [ ] Test passes without introducing new error codes or touching runtime logic","assignee":"darin@book","created_at":[1768493910635,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nREALTIME_ERRORS.md is the authoritative list of realtime error codes, but we do not currently guard against drift in ErrorCode mappings. A missing code would silently break IPC compatibility.\n\n**Design**\nAdd a test that parses REALTIME_ERRORS.md and asserts every documented code parses to a concrete ErrorCode (not Unknown). Keep parsing lightweight (table rows) and deterministic.\n\n**Files**\n- src/core/error.rs (tests) or tests/realtime_errors.rs","id":"bd-c5h","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Spec-guard realtime error codes against REALTIME_ERRORS.md","type":"chore"}
{"_at":[1765744476427,0],"_by":"darin@darinsmcstudio2.lan","closed_reason":"Superseded by epic bd-2fr - broken into individual beads","created_at":[1765690392595,0],"created_by":"darin@darinsmcstudio2.lan","description":"## What's Wrong\nDaemon query/executor code uses many `unwrap()` calls that rely on invariants (e.g., `repo_state(&remote).unwrap()`). If invariants are ever violated due to a bug or partial state load, the daemon can panic.\n\nMost of these unwraps aren't \"I forgot to handle an error\" - they're \"I proved X earlier, but the borrow checker made me re-fetch, so now I assert X with `unwrap()`\". The *proof* isn't represented in the types, so it gets re-stated as a panic.\n\n## Where\n- src/daemon/query_executor.rs:27 and similar (repo_state(...).unwrap())\n- src/daemon/executor.rs: numerous repo_state_mut/get_live_mut unwraps\n\n## Why It Matters\nPanics in the daemon take down the local serialization point. For swarms, this is a reliability cliff: a single unexpected state leads to a hard crash instead of a structured error.\n\n---\n\n## Type-Design Moves to Eliminate This Pattern\n\n### 1) Introduce \"proof types\" for states already established\n\n**LoadedRemote proof:** `ensure_repo_loaded()` returns `RemoteUrl`, then callers do `self.repo_state_mut(&remote).unwrap()` everywhere. Encode the postcondition:\n\n```rust\npub struct LoadedRemote(RemoteUrl);\n\nimpl Daemon {\n    pub fn ensure_repo_loaded(...) -> Result<LoadedRemote, OpError> { ... }\n    \n    fn repo_state(&self, r: &LoadedRemote) -> &RepoState {\n        self.repos.get(&r.0).expect(\"LoadedRemote guarantees presence\")\n    }\n    \n    fn repo_state_mut(&mut self, r: &LoadedRemote) -> &mut RepoState {\n        self.repos.get_mut(&r.0).expect(\"LoadedRemote guarantees presence\")\n    }\n}\n```\n\nNow all those \"invariant unwraps\" disappear from call sites, and the invariant is centralized at the boundary. If you truly want *zero panics*, make those `expect(...)` become `Result<&RepoState, OpError::Internal(...)>` instead.\n\n**LiveBeadRef/LiveBeadMut:** In `daemon/executor.rs`, pattern is: check existence (and not tombstoned), drop borrow, tick clock, then `get_live_mut(...).unwrap()`. Create core-level lookup that returns a proof:\n\n```rust\npub enum LookupLiveError {\n    NotFound,\n    Deleted, // optionally carry Tombstone/Stamp\n}\n\npub struct LiveBeadMut<'a> { bead: &'a mut Bead }\n\nimpl CanonicalState {\n    pub fn require_live_mut(&mut self, id: &BeadId) -> Result<LiveBeadMut<'_>, LookupLiveError> {\n        if self.tombstones.contains_key(id) { return Err(LookupLiveError::Deleted); }\n        self.live.get_mut(id)\n            .map(|b| LiveBeadMut { bead: b })\n            .ok_or(LookupLiveError::NotFound)\n    }\n}\n```\n\nThen daemon maps `LookupLiveError` → `OpError::{NotFound, BeadDeleted}`. No `unwrap`, and the \"is it live?\" fact becomes a value you can pass around.\n\n### 2) Transaction helper for borrow-checker forced re-fetches\n\nThe biggest reason you end up with `unwrap()` is this sequencing constraint:\n- you borrow `repo_state` to check something\n- you need `&mut self` to tick the clock\n- so you drop the borrow and later re-borrow and `unwrap()`\n\nWrap mutation in a helper that ticks before handing out the borrow:\n\n```rust\nimpl Daemon {\n    fn with_mutation<R>(\n        &mut self,\n        repo: &Path,\n        git_tx: &Sender<GitOp>,\n        f: impl FnOnce(&mut RepoState, Stamp, &RemoteUrl) -> Result<R, OpError>,\n    ) -> Result<R, OpError> {\n        let remote = self.ensure_repo_loaded(repo, git_tx)?;      // ensures entry exists\n        let write = self.clock_mut().tick();\n        let stamp = Stamp { at: write, by: self.actor().clone() };\n\n        let rs = self.repo_state_mut(&remote);                    // infallible via LoadedRemote\n        f(rs, stamp, &remote.0)\n    }\n}\n```\n\nNow `apply_update`/`apply_close`/`apply_claim` can do \"check + mutate\" in one borrow, without \"check then unwrap later\".\n\n### 3) Make invariant-breaking APIs impossible\n\n`CanonicalState` claims \"live ∩ tombstones = ∅ (enforced by construction)\", but `insert_tombstone` can violate it. Two options:\n\n**Option A: Capability-gate dangerous methods**\n\n```rust\npub struct RawStateToken(());\npub(crate) fn raw_token() -> RawStateToken { RawStateToken(()) }\n\nimpl CanonicalState {\n    pub fn insert(&mut self, bead: Bead) -> Result<(), CoreError> { ... }     // safe\n    pub fn delete(&mut self, tomb: Tombstone) { ... }                         // safe\n    pub(crate) fn insert_tombstone_raw(&mut self, _t: &RawStateToken, tomb: Tombstone) { ... }\n}\n```\n\n**Option B: Single-map representation**\n\n```rust\nenum Entry { Live(Bead), Tombstone(Tombstone) }\nentries: BTreeMap<BeadId, Entry>\n```\n\n### 4) Remove duplicated keys from values\n\n`DepKey` stored both as map key and inside `DepEdge.key`. Remove duplication to make \"key/value mismatch\" impossible.\n\n### 5) Decide invariant violation strategy\n\nReturn `OpError::Internal(\"invariant violated: ...\")` instead of panicking. Add `bd validate` for reporting/auto-repairing violations.\n\n---\n\n## Recommended Implementation Sequence\n\n1. **First:** `LoadedRemote` + `with_mutation(...)` - deletes majority of daemon unwraps\n2. **Then:** Live proofs, capability tokens, single-map entries become easier\n\n## Acceptance\n- No `unwrap()` in non-test daemon paths where failures can be caused by repo state/git IO.\n- Add a regression test that exercises a failure path and ensures daemon responds with an error, not panic.","id":"bd-d37","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Daemon: remove unwraps in query/executor; enforce invariants via types","type":"chore"}
