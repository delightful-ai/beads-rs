{"_at":[1768513032904,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Append path uses sync_data instead of sync_all.\n- [ ] Directory fsync happens only on new segment creation/rotation.\n- [ ] WAL tests updated to account for new sync behavior.","assignee":"darin@book","created_at":[1768503231152,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`SegmentWriter::append` currently uses `sync_all`, which fsyncs file metadata and directory on every append. The realtime plan specifies syncing file data per record and only syncing the directory when a new segment file is created/rotated. The current behavior is significantly slower and diverges from the intended design.\n\n**Files**\n- src/daemon/wal/segment.rs\n- src/daemon/wal/event_wal.rs\n- src/daemon/store_runtime.rs (if metrics/limits need adjustments)","design":"Implement the plan’s fsync policy:\n- Use `File::sync_data()` (or equivalent) for normal record appends.\n- Only `sync_all()` when creating a new segment file or sealing/rotating a segment.\n- Fsync the namespace directory when a new segment file path is created.\nUpdate metrics to distinguish data fsync vs full fsync if needed.","id":"bd-0it","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"WAL append fsync policy should follow realtime plan","type":"chore"}
{"_at":[1769770055609,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] `StoreState` uses a single map keyed by `NamespaceId` with core present.\n- [ ] Call sites no longer branch on `namespace.is_core()` for state access.\n- [ ] Core namespace presence is enforced at construction (cannot be missing).\n- [ ] Tests cover: core always present; non-core namespaces behave identically.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769581943539,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nNamespaces are modeled as a special-case “core + other map” in `StoreState`, and callers must branch on `namespace.is_core()`.\n\nEvidence:\n- `StoreState` stores `core` separately from `other` (`crates/beads-core/src/namespaced_state.rs`).\n- Call sites repeatedly do `if namespace.is_core()` in daemon and checkpoint import paths.\n\nThis is translation + scatter: the domain is “map of namespace → state,” but the code forces special casing and manual branching at every use site.\n\n**Files:**\n- `crates/beads-core/src/namespaced_state.rs`\n- `crates/beads-rs/src/git/checkpoint/import.rs`\n- `crates/beads-rs/src/daemon/core.rs`\n- `crates/beads-rs/src/daemon/executor.rs`","design":"**Design**\nRepresent namespaced state uniformly as a map with an always-present core entry.\n\nConcrete plan:\n1) Replace `StoreState { core, other }` with `StoreState { by_namespace: BTreeMap<NamespaceId, CanonicalState> }`.\n2) Enforce presence of `NamespaceId::core()` on construction and ensure `core()`/`core_mut()` are just lookups.\n3) Remove `if namespace.is_core()` branches in call sites by using uniform lookup helpers.\n4) Add `NonCoreNamespaceId` APIs only at boundaries that require them (creation), not throughout the storage layer.\n\n**Design Notes**\n- This preserves the “core always exists” invariant while eliminating translation noise.\n- If performance is a concern, keep a cached pointer to core, but the public API should be uniform.","id":"bd-jvih","labels":{"cc":{"max":{}},"entries":{"consistency":[{"counter":9090177277684016813,"replica":"a311aa90-4636-2059-2f92-20adc75fe2b5"}],"translation":[{"counter":10743120924843639153,"replica":"3e5e1e41-cf19-71b9-c467-86e56b14f6a9"}],"types":[{"counter":9864828405016069975,"replica":"c5b5cf6c-29ea-7f72-4ea1-11e3828c7617"}]}},"priority":2,"status":"closed","title":"Unify StoreState namespace representation","type":"chore"}
{"_at":[1768622561219,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622561219,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nUsers need to extend beads with custom automation: notifications, integrations, analytics, etc. A hooks system allows executable scripts to run after beads events, enabling extensibility without modifying core code.\n\n**What the Feature Does**\nHooks are executable scripts in `.beads/hooks/` that run after events:\n\n**Supported Events**:\n- `on_create` - After issue created\n- `on_update` - After issue updated (status, priority, etc.)\n- `on_close` - After issue closed\n\n**Hook Interface**:\n```bash\n#!/bin/bash\n# .beads/hooks/on_create\n# Receives issue JSON on stdin\n# Exit 0 = success, non-zero = logged as warning\n\nissue=$(cat)\nid=$(echo \"$issue\" | jq -r '.id')\ntitle=$(echo \"$issue\" | jq -r '.title')\n\n# Send Slack notification\ncurl -X POST \"$SLACK_WEBHOOK\" \\\n  -d \"{\\\"text\\\": \\\"New issue: $id - $title\\\"}\"\n```\n\n**Example Hooks**:\n```bash\n# .beads/hooks/on_create\n- Send Slack/Discord notification\n- Create GitHub issue mirror\n- Update analytics dashboard\n- Trigger CI pipeline\n\n# .beads/hooks/on_update  \n- Notify assignee of status change\n- Log to audit system\n- Update external tracker\n\n# .beads/hooks/on_close\n- Archive to long-term storage\n- Update burndown chart\n- Send completion notification\n```\n\n**Why It Needs Design Work**\n\n1. **Execution Model**:\n   - Synchronous (block command) vs Asynchronous (fire-and-forget)?\n   - Go implementation: Async by default, RunSync for testing\n   - Timeout handling? (Go: 10s default)\n   - Retry logic?\n   - Error handling - fail command or just log?\n\n2. **Hook Data Format**:\n   - What JSON structure to pass on stdin?\n   - Full Issue object? Minimal info?\n   - Include event type? Actor? Timestamp?\n   - Before/after diff for updates?\n\n3. **Security**:\n   - Hooks are arbitrary code execution\n   - How to prevent malicious hooks in shared repos?\n   - Allowlist/denylist?\n   - Sandboxing?\n   - Warn on first run?\n\n4. **Daemon Interaction**:\n   - Daemon vs direct mode - both should support hooks\n   - Who runs the hook - CLI or daemon?\n   - If daemon: How to pass output back to CLI?\n   - Environment variables inheritance?\n\n**Key Decisions to Make**\n\n1. **Hook Execution Context**:\n   ```rust\n   struct HookContext {\n       event: Event,           // create, update, close\n       issue: Issue,           // full issue object\n       actor: String,          // who triggered\n       changes: Vec<Change>,   // what changed (for updates)\n       timestamp: DateTime,\n   }\n   ```\n\n2. **Hook Discovery**:\n   - Check `.beads/hooks/<event_name>` exists and is executable\n   - Support subdirectories? (`.beads/hooks/on_create/01-slack.sh`)\n   - Hook ordering if multiple per event?\n   - Platform-specific: Unix permissions vs Windows?\n\n3. **Error Handling**:\n   ```\n   Hook fails:\n   - Option A: Ignore, log warning\n   - Option B: Rollback operation, fail command\n   - Option C: Configurable per hook\n   \n   Go approach: Async fire-and-forget, errors ignored\n   ```\n\n4. **Additional Events** (Future):\n   - `on_message` - For mail system\n   - `on_sync` - Before/after git sync\n   - `on_assign` - When assignee changes\n   - `on_label` - When labels change\n   - Keep minimal or allow arbitrary events?\n\n**Trade-offs to Consider**\n\n1. **Sync vs Async**:\n   - Sync: Hooks can modify operation (validation)\n   - Async: No latency, but can't affect outcome\n   - Go choice: Async for speed, RunSync for tests\n   - Rust: Same approach or different?\n\n2. **Richness vs Simplicity**:\n   - Rich: Pass full context, before/after, all metadata\n   - Simple: Just issue ID, user looks up details\n   - Middle: Issue JSON + event type\n\n3. **Security vs Convenience**:\n   - Strict: Require hook approval, sandboxing\n   - Loose: Just run them (Git hook model)\n   - Middle: Warning on first run\n\n4. **Extensibility vs Maintenance**:\n   - Many event types = flexible but complex\n   - Few event types = simple but limiting\n   - Start minimal, add as needed\n\n**Reference Files in Go Beads**\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/hooks/hooks.go` - Core hook system\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/hooks/hooks_unix.go` - Unix implementation  \n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/hooks/hooks_windows.go` - Windows implementation\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/cmd/bd/templates/hooks/` - Example hooks\n\n**Go Implementation Details**\n- `Runner` struct with `hooksDir` and `timeout`\n- `Run(event, issue)` - Async execution\n- `RunSync(event, issue)` - Sync execution (for tests)\n- `HookExists(event)` - Check if hook present\n- Hook receives issue as JSON on stdin\n- 10s timeout default\n- Executable permission check (Unix)\n- Fire-and-forget error handling\n\n**Hook Input Format** (Go):\n```json\n{\n  \"id\": \"bd-abc123\",\n  \"title\": \"Issue title\",\n  \"status\": \"open\",\n  \"priority\": 1,\n  \"type\": \"bug\",\n  \"created\": \"2025-01-16T12:00:00Z\",\n  \"updated\": \"2025-01-16T12:00:00Z\",\n  \"created_by\": \"agent-alice\",\n  \"description\": \"Full description...\",\n  \"labels\": [\"bug\", \"urgent\"],\n  \"assignee\": \"agent-bob\"\n}\n```\n\n**Platform Considerations**\n- Unix: Check executable bit (`mode & 0111`)\n- Windows: Check file extension (.bat, .ps1, .exe)\n- Cross-platform hook template examples\n- Environment variable handling\n\n**Use Cases to Support**\n\n1. **Notifications**:\n   - Slack/Discord on issue create\n   - Email on high-priority bugs\n   - Mobile push on assignment\n\n2. **Integration**:\n   - Mirror to Jira/Linear\n   - Create GitHub issues\n   - Update project management tools\n\n3. **Analytics**:\n   - Track cycle time\n   - Generate metrics\n   - Update dashboards\n\n4. **Automation**:\n   - Auto-assign based on labels\n   - Trigger CI jobs\n   - Update documentation\n\n5. **Compliance**:\n   - Audit logging\n   - Security scanning\n   - Policy enforcement\n\n**Open Design Questions**\n\n1. Should hooks be able to modify the issue?\n   - Pro: Enables validation, auto-correction\n   - Con: Complexity, need before/after, rollback\n   - Go approach: No (read-only)\n\n2. Template hooks included in init?\n   - Provide examples in `.beads/hooks.example/`?\n   - Auto-install on `bd init --hooks`?\n\n3. Hook for message events?\n   - `on_message` for mail system\n   - Separate design or include now?\n\n4. Disable mechanism?\n   - `--no-hooks` flag?\n   - Config setting?\n   - Just remove executable bit?\n\n**Acceptance**\n- [ ] Design document for hooks system architecture\n- [ ] Hook execution model (sync vs async, timeouts)\n- [ ] Hook data format (JSON schema for stdin)\n- [ ] Event types and lifecycle\n- [ ] Security considerations (sandboxing, warnings)\n- [ ] Error handling strategy\n- [ ] Platform-specific implementation (Unix vs Windows)\n- [ ] Integration with daemon mode\n- [ ] Example hook templates\n- [ ] Testing strategy for hooks","id":"bd-ze0x.48","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":9355462451292902946,"replica":"2ab046a9-4f9d-8973-dea1-b3f2b6358b88"}]}},"priority":2,"status":"open","title":"Hooks system - Event-driven extensibility","type":"feature"}
