{"_at":[1769763183845,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] Core error types implement a single `IntoErrorPayload` (or equivalent) trait.\n- [ ] IPC error mapping becomes a thin adapter or is removed entirely.\n- [ ] Repl error mapping uses the same trait-based conversion.\n- [ ] Adding a new error requires changes in one place only (the error definition).\n- [ ] Tests cover at least two error conversions to payloads.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769574001578,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nError semantics are translated into transport payloads by large, hand-written mappings:\n- `crates/beads-rs/src/daemon/ipc/error_mapping.rs` contains extensive match logic mapping many error types to `ErrorPayload` and details.\n- Similar translation patterns exist in repl/session error handling.\n\nThis is scatter + drift: error meaning is split between the original error type and the mapping layer. Adding a new error requires updating multiple sites, and mismatches are easy to introduce.\n\n**Files:**\n- `crates/beads-rs/src/daemon/ipc/error_mapping.rs`\n- `crates/beads-core/src/error.rs`\n- `crates/beads-rs/src/daemon/repl/error.rs`","design":"**Design**\nMake error types the single source of truth for payload shape and codes.\n\nConcrete plan:\n1) Add a trait in `beads-core` (e.g., `IntoErrorPayload`) implemented by core error types.\n2) Move payload construction into the error types themselves (or a shared error module), so transport layers are mechanical.\n3) Update IPC and repl layers to call the trait method, removing large match blocks.\n4) Ensure error detail structs live with the error definitions, not the transport mapping.\n\n**Design Notes**\n- If some errors are transport-specific, create a thin wrapper error type in core that implements the trait.\n- Avoid cyclic dependencies: trait should live in core and be used by beads-rs.","id":"bd-8ugn","labels":{"cc":{"max":{}},"entries":{"consistency":[{"counter":6546726640297200438,"replica":"7230ea28-508f-04ea-7500-d05ea0911b70"}],"errors":[{"counter":15808547355598526237,"replica":"aa69f226-b8df-2c91-213c-087acbecfd17"}],"scatter":[{"counter":4127335126144153865,"replica":"484472db-921d-c51a-0e4a-26d3bdc0af90"}]}},"priority":2,"status":"closed","title":"Make error payloads derive from core error types","type":"chore"}
{"_at":[1768528250108,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] `StoreRuntime::open` rejects incompatible `StoreMeta` versions with a structured error.\n- [ ] Only one canonical set of format/protocol constants exists.\n- [ ] Tests cover version mismatch and regression on constant drift.","assignee":"darin@book","created_at":[1768506341917,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`StoreRuntime::open` accepts existing `StoreMeta` without validating `store_format_version`, `wal_format_version`, `checkpoint_format_version`, `replication_protocol_version`, or `index_schema_version`. This means a daemon can silently run against an unsupported store layout. Also, format/version constants are duplicated across modules (`store_runtime.rs`, `wal/segment.rs`, `wal/index.rs`, `repl/proto.rs`), which is brittle and can drift.\n\n**Files**\n- src/daemon/store_runtime.rs\n- src/core/store_meta.rs\n- src/daemon/wal/segment.rs\n- src/daemon/wal/index.rs\n- src/daemon/repl/proto.rs\n","design":"**Design**\n- Add a single source of truth for format/protocol versions (e.g., `core::versions` or `StoreMetaVersions::current()` with associated consts).\n- In `StoreRuntime::open`, validate existing `StoreMeta` against the current versions and return a dedicated error (e.g., `StoreRuntimeError::UnsupportedVersion { expected, got }`) on mismatch.\n- Update WAL/index/proto modules to import the shared constants instead of redefining their own.\n- Add tests to cover mismatch handling and ensure constants are used consistently.","id":"bd-rfit","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Validate StoreMeta versions + centralize format constants","type":"chore"}
{"_at":[1768622460298,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Human has decided on sync strategy for interactions.jsonl\n- [ ] AuditEntry type defined in src/core\n- [ ] Append-only writes to .beads/interactions.jsonl\n- [ ] bd audit record command works\n- [ ] bd audit label command works\n- [ ] JSON stdin input supported\n- [ ] Entry IDs generated with int- prefix\n- [ ] Thread-safe concurrent writes\n- [ ] Auto-creates file if missing","created_at":[1768622460298,0],"created_by":"darin@darinsmcstudio2.lan","description":"","design":"Port the audit trail feature from Go beads to beads-rs, with redesign for Rust architecture.\n\n## Problem\n\nNeed to log agent interactions (LLM calls, tool invocations) for:\n1. Auditing: \"Why did the agent do that?\"\n2. Dataset generation: SFT/RL fine-tuning\n3. Debugging agent behavior\n\n## Go beads approach\n\nAppend-only JSONL file at `.beads/interactions.jsonl` with:\n- `bd audit record`: Append an interaction entry\n- `bd audit label`: Append a label referencing a parent entry\n\nEntry types:\n- `llm_call`: Model, prompt, response, error\n- `tool_call`: Tool name, exit code, error\n- `label`: Parent entry ID, label value (good/bad), reason\n\n## Redesign needed for beads-rs\n\n**Key question**: Should this be daemon-managed or file-based?\n\n**Option A: Daemon-managed (recommended)**\n- Audit entries go through daemon like other operations\n- Ensures consistency with db state\n- Allows querying audit log via RPC\n- Syncs via git with rest of state\n\n**Option B: Pure file-based**\n- CLI directly appends to JSONL\n- No daemon dependency\n- Simple but less integrated\n\n## Implementation approach (Option A)\n\n**Core types** (`src/core/audit.rs`):\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AuditEntry {\n    pub id: String,           // int-xxxxxxxx\n    pub kind: AuditKind,\n    pub created_at: DateTime<Utc>,\n    pub actor: Option<String>,\n    pub issue_id: Option<String>,\n    // Kind-specific fields\n    pub model: Option<String>,\n    pub prompt: Option<String>,\n    pub response: Option<String>,\n    pub error: Option<String>,\n    pub tool_name: Option<String>,\n    pub exit_code: Option<i32>,\n    pub parent_id: Option<String>,  // for labels\n    pub label: Option<String>,\n    pub reason: Option<String>,\n    pub extra: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum AuditKind {\n    LlmCall,\n    ToolCall,\n    Label,\n}\n```\n\n**Storage** (`src/daemon/audit.rs`):\n- Write to `.beads/interactions.jsonl` \n- Append-only operations\n- Thread-safe file writes\n- Auto-create file if missing\n\n**CLI commands**:\n```bash\nbd audit record --kind llm_call --model claude-opus-4 --prompt \"...\" --response \"...\"\nbd audit record --stdin < entry.json\nbd audit label <entry-id> --label good --reason \"correct analysis\"\n```\n\n**Daemon operations**:\n- `OpAuditRecord`: Append audit entry\n- `OpAuditLabel`: Append label entry\n- Returns entry ID\n\n## Files to reference\n\nGo implementation:\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/cmd/bd/audit.go`\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/audit/audit.go`\n\n## Design notes\n\n**CRITICAL REDESIGN QUESTION**: Should audit log:\n1. Live in `.beads/` and sync via git store ref?\n2. Have its own sync mechanism?\n3. Be optional/opt-in feature?\n\n**Sync considerations**:\n- Audit log can grow large quickly\n- May want separate retention/cleanup policy\n- Should it be in beads/store branch or separate?\n\n**ID format**: `int-xxxxxxxx` (8 hex chars, same as Go)\n\n**File permissions**: 0644 (intended to be shared via git)\n\n**Timestamp**: Always UTC\n\n## Questions for human\n\n1. **Where should interactions.jsonl live?** Same git ref as beads data, or separate?\n2. **Sync strategy?** Include in normal sync or separate mechanism?\n3. **Size limits?** Should we auto-rotate or prune old entries?\n4. **Privacy?** Any PII concerns with logging prompts/responses?\n5. **Schema version?** Add schema_version field for future evolution?","id":"bd-ze0x.24","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":13245693131981583272,"replica":"fc00a13d-4e3b-5c88-24ff-700f43dc8547"}]}},"priority":3,"status":"open","title":"Implement agent audit trail - .beads/interactions.jsonl for LLM call logging","type":"feature"}
{"_at":[1768622598117,0],"_by":"darin@darinsmcstudio2.lan","created_at":[1768622598117,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nbeads-rs lacks the Slot issue type - exclusive access primitives that coordinate shared resources with a holder and waiters queue. Slots enforce mutual exclusion for resources like merge queues, deployment slots, or critical sections.\n\n**What Slot Beads Do (from Go beads)**\nSlot beads manage exclusive access:\n- One holder at a time (mutual exclusion)\n- Waiters queue for access\n- Automatic slot release when holder closes/releases\n- Used for: merge queues, deployment slots, exclusive workflows\n\nSlot lifecycle:\n1. Create slot (empty, no holder)\n2. Agent claims slot (becomes holder)\n3. Agent uses resource\n4. Agent releases slot (holder becomes empty)\n5. Next waiter (if any) is notified\n\nMerge-slot gate pattern:\n- Refinery uses merge-slot to serialize merges\n- Only one PR can merge at a time\n- Other PRs wait in queue\n\n**Go Implementation**\nType definition (internal/types/types.go):\n- IssueType = TypeSlot (line 495)\n- Fields (lines 99-100):\n  - Holder string: Who currently holds the slot (empty = available)\n  - Waiters []string: Queue of waiting agents\n\nSlot operations (cmd/bd/slot.go for agent slots, cmd/bd/merge_slot.go for merge slots):\n- Claim slot: Set holder if empty, else add to waiters\n- Release slot: Clear holder, notify first waiter\n- Check slot: Query holder and waiters\n\nAgent slots (cmd/bd/slot.go):\nDifferent concept - slots ON agent beads (hook, role)\nThese are fields, not separate slot issue types.\n\nMerge-slot example (cmd/bd/merge_slot.go):\n- Create merge-slot bead for rig\n- Refinery claims slot before merge\n- Other refineries wait\n- Release on merge complete\n\n**Design for Rust**\nData model (src/core/):\n```rust\npub struct SlotData {\n    holder: Option<String>,  // Current holder (empty = available)\n    waiters: Vec<String>,    // Queue of waiting agents\n}\n```\n\nAdd to Bead or use optional fields.\n\nSlot operations (src/daemon/ or src/api/):\n```rust\npub fn claim_slot(slot_id: &str, claimant: &str) -> Result<ClaimResult, Error>;\npub fn release_slot(slot_id: &str, holder: &str) -> Result<(), Error>;\npub fn slot_status(slot_id: &str) -> Result<SlotStatus, Error>;\n\npub enum ClaimResult {\n    Claimed,       // You are now the holder\n    Queued,        // Added to waiters\n    AlreadyHolder, // You already hold it\n}\n\npub struct SlotStatus {\n    holder: Option<String>,\n    waiters: Vec<String>,\n    position: Option<usize>, // Your position if in waiters\n}\n```\n\nCLI (src/cli/):\n- bd slot-claim <slot-id> [<agent>] - Claim or join queue\n- bd slot-release <slot-id> [<agent>] - Release and notify next\n- bd slot-status <slot-id> - Show holder and queue\n- bd create --type slot \"Merge queue\"\n\nNotification:\n- When slot released, notify first waiter\n- Integration with message system or external notification\n\n**Design Notes**\n- Slots vs agent slots: Different concepts!\n  - Slot issue type: Exclusive resource coordination\n  - Agent slot fields: Work/role references on agents\n- Fairness: FIFO queue for waiters\n- Consider: Slot timeout (auto-release if holder doesn't heartbeat)\n- Consider: Slot priority (high-priority claims jump queue)\n- Consider: Multi-slot (lease N slots from pool)\n- Consider: Deadlock detection (slot dependency cycles)\n\n**Acceptance**\n- [ ] Slot type constant defined\n- [ ] SlotData struct with holder, waiters\n- [ ] claim_slot operation implemented\n- [ ] release_slot operation implemented\n- [ ] slot_status query implemented\n- [ ] bd slot-claim works\n- [ ] bd slot-release works\n- [ ] bd slot-status shows holder and queue\n- [ ] bd create --type slot works\n- [ ] Claim enforces mutual exclusion\n- [ ] Release notifies next waiter\n- [ ] Tests for slot claim/release\n- [ ] Tests for waiter queue ordering\n- [ ] Migration from Go beads preserves slot type and fields\n\n**Files to study in Go beads:**\n- tmp/beads/internal/types/types.go (lines 99-100: holder field, line 495: TypeSlot)\n- tmp/beads/cmd/bd/merge_slot.go (merge-slot coordination example)\n- tmp/beads/cmd/bd/slot.go (agent slot management - different concept)","id":"bd-ze0x.51","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":7715948808307674258,"replica":"09b410db-654b-c21f-f566-460deaca92e2"}]}},"priority":2,"status":"open","title":"Add Slot issue type support","type":"feature"}
