{"_at":[1766127066937,0],"_by":"darin@darinsmcstudio2.lan","closed_reason":"test cleanup","created_at":[1766127054411,0],"created_by":"darin@darinsmcstudio2.lan","description":"","id":"bd-70v.2","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Subtask B","type":"task"}
{"_at":[1769516460227,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"**Acceptance**\n- [ ] There is no way to add `Blocks`/`Parent` deps in core without a `NoCycleProof` (compile‑time enforced).\n- [ ] Replication/WAL ingestion validates acyclicity for DAG kinds before apply.\n- [ ] Non‑DAG kinds remain unaffected and do not require cycle checks.\n- [ ] Tests cover: rejecting a cycle from replicated input, and successful add for acyclic DAG edges.","assignee":"darin@darins-Mac-Studio-2.local","created_at":[1769494178815,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\n`DepKind::Blocks` and `DepKind::Parent` are documented as DAG‑only (acyclic), but core apply does not enforce acyclicity. Only the mutation engine checks cycles for local ops; replicated/WAL events can introduce cycles that violate domain invariants.\n\nBecause core accepts raw `WireDepAddV1` with `DepKind` and no proof, the compiler cannot enforce that DAG checks happened. This is a correctness gap: cycles can silently enter CanonicalState and break ready/blocked semantics.\n\nKey refs:\n- `crates/beads-core/src/domain.rs:77` — `Blocks`/`Parent` require DAG.\n- `crates/beads-core/src/apply.rs:284` — no cycle check in core apply.\n- `crates/beads-rs/src/daemon/mutation_engine.rs:1119` — cycle check only in mutation engine.\n\n**Impact**\nDomain invariants are violated by replicated input. Ready/blocked computation can be wrong; parent semantics can become ambiguous.","design":"**Design (opinionated)**\nMake DAG enforcement a *type boundary* so cycle checks cannot be skipped.\n\n1) Split dependency edge types by invariant:\n- `struct AcyclicDepKey(DepKey)` for `Blocks`/`Parent` only.\n- `struct FreeDepKey(DepKey)` for `Related`/`DiscoveredFrom`.\n\n2) Require explicit proof for DAG edges:\n- `CanonicalState::check_no_cycle(from, to, kind) -> Result<NoCycleProof, DepError>`.\n- `AcyclicDepKey::new(from, to, kind, proof)` consumes `NoCycleProof`.\n\n3) Narrow core apply API:\n- `apply_dep_add` for DAG kinds requires `AcyclicDepKey`.\n- `apply_dep_add` for non‑DAG kinds accepts `FreeDepKey`.\n- This forces every insertion site (including repl/WAL) to perform the cycle check before creating the key.\n\n4) Event boundary conversion:\n- When decoding `WireDepAddV1`, convert to `AcyclicDepKey` only if `kind.requires_dag()`, otherwise to `FreeDepKey`.\n- Failed cycle checks return a deterministic error at the ingest boundary (not deep in apply).\n\nThis makes “forgot to check DAG” a compile‑time error.","id":"bd-7abk","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Encode acyclic ordering deps in types","type":"bug"}
{"_at":[1767992684012,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] New model file exists (e.g., beads_stateright_models/examples/gc_floor_machine.rs) and compiles\n- [ ] Properties cover: floor monotonicity, old events do not mutate state, old events still advance contiguity/ACK, and deterministic convergence (todo.md Model #5)\n- [ ] Model doc comments reference REALTIME_PLAN.md §2.4 and §9.4\n- [ ] Example runs via cargo run --example gc_floor_machine (or equivalent)","assignee":"darin@darinsmacstudio.lan","created_at":[1767985320945,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nGC floor enforcement is correctness-sensitive but currently unmodeled. We need a Stateright model that matches REALTIME_PLAN.md §2.4 (NamespaceGcMarker) and the GC floor rules described in todo.md Model #5 so we do not accidentally stall contiguity or resurrect old state.\n\n**Design Notes**\nThe model should separate state mutation from contiguity/ACK advancement.","design":"**Design**\nCreate a model that introduces NamespaceGcMarker events, tracks gc_floor_ms per namespace, and enforces the rule: events with event_time_ms <= gc_floor are ignored as state mutations but still advance contiguity and ACK (Plan §2.4 + §9.4). Use a tiny state digest (e.g., set of applied event_ids) to test resurrection behavior.\n\nAllow nondeterministic emission of GC markers by the authority replica and ensure floor monotonicity (todo.md Model #5).\n\nReference the apply logic seam in realtime_types_sketch.rs or a small local helper to keep plan alignment.","id":"bd-hjm.5","labels":{"cc":{"max":{}},"entries":{"modeling":[{"counter":9148099286657671107,"replica":"2f1f2236-69ec-51b5-73e3-679cd3bde3e0"}],"realtime":[{"counter":12172777823378883667,"replica":"79b0c253-3888-9464-1a85-1746182a1e14"}],"stateright":[{"counter":1273907525516143466,"replica":"1469fba7-9ea3-5279-9c24-01c47d55d177"}]}},"priority":2,"status":"closed","title":"Stateright: GC markers + floor semantics","type":"feature"}
{"_at":[1769214728374,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Invariant test: dep_indexes contains exactly dep_store.values().\\n- [ ] Regression test: delete then re-add a dep restores membership and indexes.\\n- [ ] Dependency tests cover both outgoing and incoming index paths.","assignee":"darin@book","created_at":[1769209838121,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\nInvariant checks do not validate dep_indexes against dep_store, and there is no regression test for delete-then-readd of the same dependency.\\n\\n**Files**: src/core/state.rs, tests/integration/core/apply.rs","design":"**Design**\\n- Add invariant assertion that dep_indexes exactly reflect dep_store values.\\n- Add regression test: dep add -> remove -> re-add results in membership and indexes reflecting the re-added edge.\\n- Include dependency-specific tests as requested.","id":"bd-qz97.14","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"DepStore invariants: dep_indexes parity + delete/re-add regression","type":"task"}
