{"_at":[1767999599816,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1766116457266,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nNote IDs are random 8-char base58; collisions are unlikely but possible. A collision overwrites an existing note in the CRDT map.\n\n**Design**\nInclude actor + timestamp in note IDs or retry generation until unique in-bead. Add a test that forces collision handling.\n\n**Acceptance**\n- [ ] Note ID generation is collision-safe\n- [ ] Tests cover collision path\n\n**Files:** src/core/identity.rs, src/daemon/executor.rs","id":"bd-2rw","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Note ID collisions should be guarded","type":"chore"}
{"_at":[1768432627654,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@book","closed_reason":"OpResponse now carries optional Issue for Created ops; daemon attaches issue from state, CLI reuses it to skip extra show; added executor test.","created_at":[1768431978064,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\nCLI create does a mutation then immediately queries show to render JSON/human output. In integration tests this doubles IPC round-trips and shows up as wait time in profiling.\\n\\n**Design**\\nAdd an optional Issue payload on OpResponse. When the mutation result is Created, attach Issue::from_bead from the updated state. CLI should consume OpResponse.issue when present and skip the follow-up show; fall back to current behavior when missing.\\n\\n**Acceptance**\\n- [ ] OpResponse serializes issue when created\\n- [ ] CLI create uses issue when present and avoids extra IPC query\\n- [ ] Existing JSON output shape remains (QueryResult::Issue)\\n- [ ] Tests updated/added to cover issue attachment\\n\\n**Files**: src/daemon/executor.rs, src/daemon/ipc.rs, src/cli/commands/create.rs","id":"bd-75w","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Create op should return Issue to skip extra show","type":"task"}
{"_at":[1767991683829,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] New model file exists (e.g., beads_stateright_models/examples/durability_quorum_machine.rs) and compiles\n- [ ] Properties enforce: no false durability, quorum correctness for k, no counting ineligible replicas, and honest timeout receipts (todo.md Model #2)\n- [ ] Model doc comments reference REALTIME_PLAN.md §10, §0.12, and §0.11\n- [ ] Example runs via cargo run --example durability_quorum_machine (or equivalent)","assignee":"darin@darinsmacstudio.lan","created_at":[1767985289433,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nWe need a durability coordinator model that matches REALTIME_PLAN.md §10 and §0.12. Existing watermarks_machine.rs only models monotonic counters and does not exercise ReplicatedFsync(k), eligible replica selection, or timeout semantics.\n\n**Design Notes**\nThis should align with Plan §10.1-§10.5 and the applied vs durable watermark distinction in §0.12.","design":"**Design**\nBuild a Stateright model that separates applied vs durable watermarks and explicitly models persistence as a boolean per event. Add a coordinator that waits for ReplicatedFsync(k), using an eligibility roster (Plan §10.2) and rejecting ineligible replicas. Include timeout behavior that returns retryable errors with receipts (Plan §10.5 + §0.11).\n\nLeverage the existing watermarks_machine.rs for structure but extend to include: multiple replicas, a quorum counter, and ACK-driven durable advancement. Ensure ACKs cannot advance durable beyond locally persisted events (Plan §9.5 + §0.12).","id":"bd-hjm.2","labels":{"cc":{"max":{}},"entries":{"modeling":[{"counter":556570083957757761,"replica":"795ddba2-1131-fbd0-b1bd-72a1e25e430b"}],"realtime":[{"counter":175663632081681690,"replica":"ab56c7a7-1da1-09f1-bfda-00d3d0e26ad6"}],"stateright":[{"counter":6531753168502953956,"replica":"0ef1c03f-8a69-36db-4adf-d3aa2f85c8e8"}]}},"priority":1,"status":"closed","title":"Stateright: durability semantics + ReplicatedFsync(k)","type":"feature"}
