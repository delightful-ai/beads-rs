{"_at":[1768494200580,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Test asserts exact human output for a representative FsckReport (repairs + evidence)\n- [ ] No changes to fsck runtime logic","assignee":"darin@book","created_at":[1768493923720,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nREALTIME_PLAN recommends golden corpus tests for `bd store fsck` output stability, but we currently have no CLI-level rendering tests. Output drift can silently break operator workflows.\n\n**Design**\nAdd a unit test for render_fsck_human in src/cli/commands/store.rs using a hand-built FsckReport that includes repairs and evidence. Assert exact output to lock formatting.\n\n**Files**\n- src/cli/commands/store.rs","id":"bd-7tx","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Add golden output test for bd store fsck","type":"chore"}
{"_at":[1768622590654,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Schema has deleted_at, deleted_by, delete_reason, original_type\n- [ ] is_tombstone() and is_expired() methods work\n- [ ] bd delete creates tombstones instead of removing\n- [ ] Tombstones exported to JSONL\n- [ ] Tombstones imported from JSONL\n- [ ] Prune removes expired tombstones with no open deps\n- [ ] Kept tombstones if open issues depend on them\n- [ ] Default TTL is 30 days\n- [ ] bd compact --prune works\n- [ ] bd compact --purge works","created_at":[1768622590654,0],"created_by":"darin@darinsmcstudio2.lan","description":"","design":"Port the inline tombstone system from Go beads to beads-rs.\n\n## Problem\n\nWhen issues are deleted, we need to:\n1. Preserve delete markers for sync (CRDT tombstones)\n2. Support 3-way merge of deletions\n3. Eventually garbage collect old tombstones\n4. Keep dependency graph intact during TTL period\n\n## Go beads approach\n\nDeleted issues become tombstones with:\n- `deleted_at`: Timestamp of deletion\n- `deleted_by`: Actor who deleted\n- `delete_reason`: Why deleted\n- `original_type`: Issue type before deletion\n\nTombstones are:\n- Inline in issues table (not separate deletions.jsonl)\n- Exported to JSONL like normal issues\n- Pruned after TTL (default 30 days)\n- Kept if open issues still depend on them\n\n## Implementation approach\n\n**Schema changes** (`src/storage/schema.sql`):\n```sql\nALTER TABLE issues ADD COLUMN deleted_at DATETIME;\nALTER TABLE issues ADD COLUMN deleted_by TEXT DEFAULT '';\nALTER TABLE issues ADD COLUMN delete_reason TEXT DEFAULT '';\nALTER TABLE issues ADD COLUMN original_type TEXT DEFAULT '';\n\n-- Partial index for efficient TTL queries\nCREATE INDEX idx_issues_deleted_at \n    ON issues(deleted_at) \n    WHERE deleted_at IS NOT NULL;\n```\n\n**Core types** (`src/core/types.rs`):\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Issue {\n    pub id: String,\n    pub title: String,\n    pub status: Status,\n    // ... other fields ...\n    \n    // Tombstone fields\n    pub deleted_at: Option<DateTime<Utc>>,\n    pub deleted_by: Option<String>,\n    pub delete_reason: Option<String>,\n    pub original_type: Option<IssueType>,\n}\n\nimpl Issue {\n    /// Check if issue is a tombstone\n    pub fn is_tombstone(&self) -> bool {\n        self.deleted_at.is_some()\n    }\n    \n    /// Check if tombstone is expired (past TTL)\n    pub fn is_expired(&self, ttl: Duration) -> bool {\n        if let Some(deleted_at) = self.deleted_at {\n            Utc::now() - deleted_at > ttl\n        } else {\n            false\n        }\n    }\n}\n\n/// Default tombstone TTL\npub const DEFAULT_TOMBSTONE_TTL: Duration = Duration::days(30);\n\n/// Minimum tombstone TTL for safety\npub const MIN_TOMBSTONE_TTL: Duration = Duration::days(7);\n```\n\n**Delete operation** (`src/daemon/operations.rs`):\n```rust\npub fn delete_issue(\n    state: &mut CanonicalState,\n    issue_id: &str,\n    actor: &str,\n    reason: Option<&str>,\n) -> Result<()> {\n    let mut issue = state.get_issue_mut(issue_id)?;\n    \n    // Convert to tombstone\n    issue.deleted_at = Some(Utc::now());\n    issue.deleted_by = Some(actor.to_string());\n    issue.delete_reason = reason.map(|s| s.to_string());\n    issue.original_type = Some(issue.issue_type.clone());\n    \n    // Mark dirty for export\n    state.mark_dirty(issue_id);\n    \n    Ok(())\n}\n```\n\n**Tombstone pruning** (`src/daemon/compact.rs`):\n```rust\n/// Prune expired tombstones that have no open dependencies\npub fn prune_tombstones(\n    state: &mut CanonicalState,\n    ttl: Duration,\n) -> Result<PruneResult> {\n    let mut result = PruneResult::default();\n    \n    // Find expired tombstones\n    let expired: Vec<_> = state.issues()\n        .filter(|i| i.is_expired(ttl))\n        .map(|i| i.id.clone())\n        .collect();\n    \n    // Build dependency map: tombstone_id -> [dependent_issue_ids]\n    let deps_map = build_reverse_deps(state);\n    \n    // Only prune tombstones with no open dependents\n    for tombstone_id in expired {\n        if let Some(dependents) = deps_map.get(&tombstone_id) {\n            let has_open_deps = dependents.iter()\n                .any(|dep_id| {\n                    state.get_issue(dep_id)\n                        .map(|i| i.status == Status::Open)\n                        .unwrap_or(false)\n                });\n            \n            if has_open_deps {\n                result.kept.push(tombstone_id.clone());\n                continue;\n            }\n        }\n        \n        // Safe to delete\n        state.remove_issue(&tombstone_id)?;\n        result.deleted.push(tombstone_id);\n    }\n    \n    Ok(result)\n}\n\n#[derive(Debug, Default)]\npub struct PruneResult {\n    pub deleted: Vec<String>,\n    pub kept: Vec<String>,\n}\n```\n\n**CLI commands**:\n```bash\nbd delete <issue-id> --reason \"duplicate of bd-abc\"\nbd compact --prune  # Age-based pruning (default 30d)\nbd compact --purge  # Dependency-aware purging\nbd compact --older-than 60  # Custom TTL\n```\n\n## Files to reference\n\nGo implementation:\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/cmd/bd/compact_tombstone.go`\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/storage/sqlite/migrations/018_tombstone_columns.go`\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/storage/sqlite/migrations/028_tombstone_closed_at.go`\n\n## Design notes\n\n**Why inline tombstones**:\n- Simpler than separate deletions.jsonl\n- Better 3-way merge support\n- Tombstones visible in normal queries\n- Export/import just works\n\n**TTL-based expiration**:\n- Default 30 days gives time for sync\n- Minimum 7 days safety check\n- Dependency-aware: keep if open deps exist\n- Manual override via --older-than\n\n**Sync behavior**:\n- Tombstones exported to JSONL normally\n- Import detects deleted_at and preserves tombstone\n- 3-way merge uses deleted_at for conflict resolution\n- Pruned tombstones just disappear from JSONL\n\n**Migration from deletions.jsonl**:\n- Need migration command to import old deletions\n- Convert deleted_id -> issue with deleted_at\n- Preserve delete metadata\n\n## Questions\n\n1. Should tombstones show in `bd list` by default?\n2. Filter flag: `bd list --include-deleted`?\n3. Should `bd show` work on tombstones?\n4. Warn when deleting issue with open dependents?\n5. Auto-prune on sync or explicit command only?","id":"bd-ze0x.50","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":13108053629378298605,"replica":"4cb4eb26-817e-53fc-2b41-d767695cf95f"}]}},"priority":3,"status":"open","title":"Implement inline tombstones - Deleted issues as status=deleted with TTL-based expiration","type":"feature"}
{"_at":[1768622628528,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] parse_conflicts extracts all conflict regions\n- [ ] Mechanical mode uses LWW merge semantics\n- [ ] Same-ID issues merged correctly\n- [ ] Different-ID issues both included\n- [ ] Backup created before writing\n- [ ] Atomic write via temp file\n- [ ] Dry-run shows what would be resolved\n- [ ] JSON output includes conflict details\n- [ ] Works on issues.jsonl by default\n- [ ] Handles malformed conflicts gracefully","created_at":[1768622628528,0],"created_by":"darin@darinsmcstudio2.lan","description":"","design":"Port the conflict resolution feature from Go beads to beads-rs.\n\n## Problem\n\nWhen git merge fails on issues.jsonl, files end up with conflict markers:\n```\n<<<<<<< HEAD\n{\"id\":\"bd-abc\",\"title\":\"Old title\",...}\n=======\n{\"id\":\"bd-abc\",\"title\":\"New title\",...}\n>>>>>>> branch-name\n```\n\nNormal git mergetools don't understand beads merge semantics (LWW by updated_at).\n\n## Go beads solution\n\n`bd resolve-conflicts` command that:\n1. Parses conflict markers in JSONL\n2. Applies beads merge semantics (updated_at wins, arrays merge, etc.)\n3. Writes resolved JSONL atomically\n4. Supports dry-run and JSON output\n\n## Implementation approach\n\n**Core conflict parsing** (`src/merge/conflict_parser.rs`):\n```rust\n#[derive(Debug)]\npub struct ConflictRegion {\n    pub start_line: usize,\n    pub end_line: usize,\n    pub left_side: Vec<String>,   // Between <<<<<<< and =======\n    pub right_side: Vec<String>,  // Between ======= and >>>>>>>\n    pub left_label: String,        // e.g., \"HEAD\"\n    pub right_label: String,       // e.g., \"branch-name\"\n}\n\npub fn parse_conflicts(content: &str) -> Result<(Vec<ConflictRegion>, Vec<String>)> {\n    let mut conflicts = Vec::new();\n    let mut clean_lines = Vec::new();\n    let mut in_conflict = false;\n    let mut current_region: Option<ConflictRegion> = None;\n    \n    for (line_num, line) in content.lines().enumerate() {\n        if line.starts_with(\"<<<<<<<\") {\n            // Start of conflict\n            in_conflict = true;\n            current_region = Some(ConflictRegion {\n                start_line: line_num,\n                left_label: line[7..].trim().to_string(),\n                ..Default::default()\n            });\n        } else if line.starts_with(\"=======\") && in_conflict {\n            // Switch to right side\n            // ...\n        } else if line.starts_with(\">>>>>>>\") && in_conflict {\n            // End of conflict\n            current_region.right_label = line[7..].trim().to_string();\n            conflicts.push(current_region.take().unwrap());\n            in_conflict = false;\n        } else if !in_conflict {\n            clean_lines.push(line.to_string());\n        } else {\n            // Inside conflict, accumulate\n            // ...\n        }\n    }\n    \n    Ok((conflicts, clean_lines))\n}\n```\n\n**Conflict resolution** (`src/merge/conflict_resolver.rs`):\n```rust\npub enum ResolutionMode {\n    Mechanical,     // Use LWW rules automatically\n    Interactive,    // Prompt user (future)\n}\n\npub struct ConflictResolver {\n    mode: ResolutionMode,\n}\n\nimpl ConflictResolver {\n    pub fn resolve(&self, region: &ConflictRegion) -> Result<Vec<String>> {\n        match self.mode {\n            ResolutionMode::Mechanical => self.resolve_mechanical(region),\n            ResolutionMode::Interactive => unimplemented!(\"Interactive mode\"),\n        }\n    }\n    \n    fn resolve_mechanical(&self, region: &ConflictRegion) -> Result<Vec<String>> {\n        // Parse JSONL from both sides\n        let left_issues = self.parse_jsonl(&region.left_side)?;\n        let right_issues = self.parse_jsonl(&region.right_side)?;\n        \n        // Build issue map by ID\n        let mut merged = HashMap::new();\n        \n        for issue in left_issues {\n            merged.insert(issue.id.clone(), issue);\n        }\n        \n        for issue in right_issues {\n            if let Some(existing) = merged.get(&issue.id) {\n                // Same ID - merge using LWW rules\n                let resolved = merge_issues(existing, &issue)?;\n                merged.insert(issue.id.clone(), resolved);\n            } else {\n                // New issue from right\n                merged.insert(issue.id.clone(), issue);\n            }\n        }\n        \n        // Serialize back to JSONL\n        let mut lines = Vec::new();\n        for issue in merged.values() {\n            lines.push(serde_json::to_string(issue)?);\n        }\n        \n        Ok(lines)\n    }\n    \n    fn parse_jsonl(&self, lines: &[String]) -> Result<Vec<Issue>> {\n        lines.iter()\n            .filter(|line| !line.is_empty())\n            .map(|line| serde_json::from_str(line))\n            .collect()\n    }\n}\n```\n\n**CLI command**:\n```rust\n#[derive(Parser)]\npub struct ResolveConflictsArgs {\n    /// File to resolve (defaults to .beads/issues.jsonl)\n    file: Option<PathBuf>,\n    \n    #[arg(long, default_value = \"mechanical\")]\n    mode: ResolutionMode,\n    \n    #[arg(long)]\n    dry_run: bool,\n    \n    #[arg(long)]\n    json: bool,\n    \n    #[arg(long)]\n    path: Option<PathBuf>,\n}\n\npub fn resolve_conflicts(args: ResolveConflictsArgs) -> Result<()> {\n    let file_path = args.file.unwrap_or_else(|| {\n        args.path.unwrap_or_else(|| PathBuf::from(\".\"))\n            .join(\".beads/issues.jsonl\")\n    });\n    \n    // Read file\n    let content = fs::read_to_string(&file_path)?;\n    \n    // Parse conflicts\n    let (conflicts, clean_lines) = parse_conflicts(&content)?;\n    \n    if conflicts.is_empty() {\n        println!(\"No conflict markers found\");\n        return Ok(());\n    }\n    \n    // Resolve each conflict\n    let resolver = ConflictResolver::new(args.mode);\n    let mut resolved_lines = clean_lines;\n    \n    for conflict in &conflicts {\n        let resolved = resolver.resolve(conflict)?;\n        resolved_lines.extend(resolved);\n    }\n    \n    if args.dry_run {\n        println!(\"Would resolve {} conflicts\", conflicts.len());\n        return Ok(());\n    }\n    \n    // Create backup\n    let backup_path = file_path.with_extension(\"jsonl.pre-resolve\");\n    fs::copy(&file_path, &backup_path)?;\n    \n    // Write resolved file atomically\n    let temp_path = file_path.with_extension(\"jsonl.tmp\");\n    fs::write(&temp_path, resolved_lines.join(\"\\n\"))?;\n    fs::rename(&temp_path, &file_path)?;\n    \n    println!(\"Resolved {} conflicts\", conflicts.len());\n    println!(\"Backup: {}\", backup_path.display());\n    \n    Ok(())\n}\n```\n\n## Files to reference\n\nGo implementation:\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/cmd/bd/resolve_conflicts.go`\n- `/Users/darin/Projects/beads-rs-macstudio/tmp/beads/internal/merge/merge.go`\n\n## Design notes\n\n**Mechanical resolution rules**:\n1. If issue IDs match: Use LWW merge (latest updated_at wins)\n2. If different IDs: Include both\n3. Merge arrays (labels, deps) by union\n4. Lww fields use timestamp comparison\n\n**Backup strategy**:\n- Always create backup before writing\n- Backup path: `{file}.pre-resolve`\n- Preserve backup even on success\n- Atomic write via temp file + rename\n\n**Error handling**:\n- Invalid JSON in conflict region: report line number\n- Malformed conflict markers: detailed error\n- I/O errors: preserve original file\n\n**Future: Interactive mode**:\n- Show both versions side-by-side\n- Prompt: [L]eft, [R]ight, [M]erge, [E]dit\n- Store choices for replay\n\n## Questions\n\n1. Should this be a CLI-only command or daemon operation?\n2. Auto-resolve on `bd sync` if conflicts detected?\n3. Support for molecules.jsonl and other JSONL files?\n4. Should we mark git conflict as resolved after fixing?","id":"bd-ze0x.54","labels":{"cc":{"max":{}},"entries":{"human-needed":[{"counter":9298302758019665171,"replica":"e3bc4d60-0ed0-b5d5-36e8-05cfb9e043df"}]}},"priority":2,"status":"open","title":"Implement bd resolve-conflicts - JSONL merge conflict resolution with timestamp rules","type":"feature"}
