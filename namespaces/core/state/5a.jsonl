{"_at":[1767998586056,0],"_by":"darin@darinsmcstudio2.lan","assignee":"darin@darinsmacstudio.lan","created_at":[1765745476440,0],"created_by":"darin@darinsmcstudio2.lan","description":"When dependencies are updated via bd dep add/remove, the git sync commits don't include meaningful messages about what changed. Should capture the operation in the commit message for traceability.","id":"bd-7dy","labels":{"cc":{"max":{}},"entries":{}},"priority":3,"status":"closed","title":"Dep updates don't get commit messages","type":"bug"}
{"_at":[1768527608416,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] MutationEngine::plan no longer accepts origin_seq or returns pre-encoded bytes tied to a seq.\n- [ ] WAL append path is the only place that allocates origin_seq for local mutations.\n- [ ] Executor no longer holds a WAL index txn open during mutation planning/encoding.\n- [ ] Existing mutation and WAL tests pass or are updated to the new flow.","assignee":"darin@book","created_at":[1768503775259,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nMutationEngine::plan takes origin_seq and returns fully-encoded EventBody bytes. Executor pre-allocates origin_seq via WalIndex and passes it into planning (src/daemon/executor.rs). This leaks WAL sequencing into the planner, forces long-lived SQLite txns during planning/encoding, and violates REALTIME_PLAN ยง0.5/ยง5.6 (origin_seq allocated inside WAL append). It is easy to misuse for batching/retries and makes the \"event id not assigned yet\" invariant impossible to encode in types.\n\n**Files:** src/daemon/mutation_engine.rs, src/daemon/executor.rs, src/daemon/wal/event_wal.rs, src/daemon/wal/index.rs, src/core/event.rs","design":"**Design**\n- Introduce an unsequenced event draft type (e.g., EventDraft without origin_seq/bytes) that carries delta + stamps + request_sha256.\n- Move origin_seq allocation into the WAL append path (append_local) using WalIndexTxn::next_origin_seq and durable head lookup, then build EventBody with the assigned seq and encode canonical bytes inside append.\n- Replace direct next_origin_seq calls in executor with append_local results (EventId + bytes + sha + prev_sha).\n- Keep request_sha256 computed from canonicalized mutation request; do not include origin_seq in that digest.\n- Update tests to cover seq allocation boundaries and idempotent retries.","id":"bd-eqn","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"Decouple mutation planning from origin_seq allocation","type":"chore"}
{"_at":[1768508452669,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] No WAL-facing APIs use raw `u64` for origin sequence inside the codebase.\n- [ ] Record header encoding/decoding remains identical on the wire.\n- [ ] Executor/WAL range paths no longer need to validate `Seq1::from_u64`.","assignee":"darin@book","created_at":[1768503221515,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\nRealtime WAL code uses raw `u64` for origin sequences in multiple layers (`RecordHeader.origin_seq`, wal index APIs, wal range reader). Callers must manually convert to `Seq1` and check for zero. This weakens invariants and makes it easy to forget a check.\n\n**Files**\n- src/daemon/wal/record.rs\n- src/daemon/wal/index.rs\n- src/daemon/wal/event_wal.rs\n- src/daemon/repl/runtime.rs\n- src/daemon/executor.rs","design":"Refactor WAL APIs to use `Seq1`/`Seq0`:\n- `RecordHeader.origin_seq: Seq1` (convert to/from u64 only when encoding/decoding bytes).\n- WalIndex `next_origin_seq` returns `Seq1`; `iter_from`/`max_origin_seq` accept/return `Seq0` where appropriate.\n- `WalRangeReader::read_range` and any `from_seq_excl` parameters should be `Seq0`.\nUpdate callers and tests accordingly to remove `Seq1::from_u64` checks.","id":"bd-iq0","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"WAL: use Seq0/Seq1 types instead of raw u64","type":"chore"}
{"_at":[1769213597875,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Unit test: apply two label ops out of order; label stamp remains max.\\n- [ ] Unit test: adding a new dot for an existing label updates label stamp even if membership unchanged.\\n- [ ] Determinism test: apply same label/dep ops in different orders with different stamps => identical serialized state.\\n- [ ] Dep stamp behavior mirrors label stamp behavior in tests.","assignee":"darin@book","created_at":[1769209799770,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\nLabelState.stamp (and DepStore.stamp) is assigned directly on membership change; out-of-order apply can regress stamps and updated_stamp. Also, OR-Set internal changes (new dot, cc merge) can occur without membership change but currently do not update stamps.\\n\\n**Files**: src/core/state.rs, src/core/orset.rs, src/core/bead.rs, src/git/wire.rs","design":"**Design**\\n- Use max(existing, incoming) for stamp updates to enforce monotonicity.\\n- Extend OrSetChange to indicate internal state mutation (not only membership diff).\\n- Update apply_label_add/remove and apply_dep_add/remove to update stamps when internal OR-Set state changes, not just membership diff.\\n\\nKeep updated_stamp behavior aligned with CRDT_OVERHAUL.md (labels/notes/fields max).","id":"bd-qz97.3","labels":{"cc":{"max":{}},"entries":{}},"priority":1,"status":"closed","title":"Label/dep stamp monotonicity + stamp on internal OR-Set change","type":"bug"}
{"_at":[1769212590237,0],"_by":"darin@darinsmcstudio2.lan","acceptance_criteria":"- [ ] Unit test: DepKind ordering matches chosen canonical order.\\n- [ ] Git wire test: serialized deps.jsonl order is stable and matches canonical order.\\n- [ ] CRDT_OVERHAUL.md updated if spec language changes.","assignee":"darin@book","created_at":[1769209800798,0],"created_by":"darin@darinsmcstudio2.lan","description":"**Problem**\\nDepKind derives Ord by enum order. If spec expects lexical ordering, deps.jsonl sort order may be ambiguous or inconsistent across implementations.\\n\\n**Files**: src/core/domain.rs, src/git/wire.rs, CRDT_OVERHAUL.md","design":"**Design**\\nChoose one canonical ordering and enforce it:\\n- Preferred: implement Ord for DepKind by as_str() lexical order.\\n- Alternatively: document enum order as canonical and add tests to lock it.\\nUpdate docs accordingly.","id":"bd-qz97.8","labels":{"cc":{"max":{}},"entries":{}},"priority":2,"status":"closed","title":"DepKind canonical ordering for deterministic deps.jsonl","type":"chore"}
